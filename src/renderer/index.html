<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StudioLive MIDI Controller</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif;
      background: #0d0d0d;
      color: #e0e0e0;
      padding: 0;
      min-height: 100vh;
      padding-bottom: 50px; /* Space for status bar */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: 100%;
      margin: 0;
      padding: 15px;
    }

    /* Header with activity indicators */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 10px 15px;
      background: rgba(20, 20, 20, 0.8);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    h1 {
      font-size: 1.5rem;
      color: #e0e0e0;
      font-weight: 600;
    }

    .mix-page-badge {
      background: rgba(74, 155, 127, 0.2);
      border: 1px solid #4a9b7f;
      color: #4a9b7f;
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    /* Top right status indicators */
    .header-right {
      display: flex;
      align-items: center;
      gap: 15px;
      font-size: 0.85rem;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(30, 30, 30, 0.6);
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .connection-status:hover {
      background: rgba(40, 40, 40, 0.8);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
    }

    .status-dot.connected {
      background: #4a9b7f;
      box-shadow: 0 0 8px rgba(74, 155, 127, 0.6);
    }

    .activity-indicator {
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.3);
      transition: all 0.15s;
      font-weight: bold;
    }

    .activity-indicator::before {
      content: '‚Üï';
    }

    .activity-indicator.active {
      text-shadow: 0 0 8px currentColor;
    }

    .activity-indicator.active.midi { color: #5b9bd5; }
    .activity-indicator.active.mixer { color: #d97c4e; }

    /* Main layout */
    .main-layout {
      display: block;
      position: relative;
    }

    /* Collapsible Sidebar */
    .sidebar {
      position: fixed;
      left: -320px;
      top: 0;
      bottom: 50px; /* Above status bar */
      width: 320px;
      background: rgba(15, 15, 15, 0.98);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      transition: left 0.3s ease;
      z-index: 1000;
      overflow-y: auto;
      padding: 80px 15px 15px 15px; /* Top padding for header */
    }

    .sidebar.open {
      left: 0;
    }

    .sidebar-toggle {
      position: fixed;
      left: 10px;
      top: 80px;
      width: 40px;
      height: 40px;
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
      transition: all 0.2s;
      color: #e0e0e0;
    }

    .sidebar-toggle:hover {
      background: rgba(40, 40, 40, 0.9);
      border-color: #4a9b7f;
    }

    .sidebar.open + .sidebar-toggle {
      left: 330px;
    }

    .status-card {
      background: rgba(30, 30, 30, 0.6);
      border-radius: 8px;
      padding: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 15px;
    }

    .status-card h2 {
      font-size: 1rem;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      color: #b0b0b0;
      font-weight: 600;
    }

    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff4444;
      box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
    }

    .status-indicator.connected {
      background: #4a9b7f;
      box-shadow: 0 0 10px rgba(74, 155, 127, 0.5);
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 0.85rem;
    }

    .info-row:last-child {
      border-bottom: none;
    }

    .info-label {
      color: #888;
    }

    .info-value {
      font-weight: 500;
      color: #e0e0e0;
    }

    .btn {
      background: rgba(74, 155, 127, 0.2);
      border: 1px solid rgba(74, 155, 127, 0.4);
      color: #4a9b7f;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      width: 100%;
      margin-top: 10px;
      font-weight: 500;
    }

    .btn:hover {
      background: rgba(74, 155, 127, 0.3);
      border-color: #4a9b7f;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 0;
    }

    .tab {
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: #888;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      font-weight: 500;
    }

    .tab:hover {
      color: #b0b0b0;
      border-bottom-color: rgba(74, 155, 127, 0.3);
    }

    .tab.active {
      color: #4a9b7f;
      border-bottom-color: #4a9b7f;
    }

    .tab-content {
      display: none;
      flex: 1;
      overflow: hidden;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    /* Content area */
    .content-area {
      background: rgba(20, 20, 20, 0.4);
      border-radius: 8px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      flex-direction: column;
      height: calc(100vh - 130px); /* Full height minus header and status bar */
    }

    /* Faders view */
    #faders-view {
      display: flex;
      flex-direction: column;
    }

    .faders-toolbar {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
      padding: 6px 8px;
      background: rgba(30, 30, 30, 0.5);
      border-radius: 6px;
      flex-wrap: nowrap;
      align-items: center;
      overflow-x: auto;
    }

    .faders-toolbar .btn {
      margin: 0;
      padding: 5px 10px;
      font-size: 0.75rem;
      width: auto;
      white-space: nowrap;
    }

    .toolbar-spacer {
      flex: 1;
      min-width: 10px;
    }

    .mute-groups {
      display: flex;
      gap: 4px;
      align-items: center;
      margin-left: auto;
    }

    .mute-group-btn {
      min-width: 38px;
      padding: 5px 8px;
      font-size: 0.7rem;
      font-weight: bold;
      background: rgba(60, 60, 60, 0.8);
      border: 2px solid #555;
      transition: all 0.2s ease;
      position: relative;
    }

    .mute-group-btn:hover {
      background: rgba(80, 80, 80, 0.9);
      border-color: #777;
    }

    .mute-group-btn.active {
      background: #d32f2f;
      border-color: #f44336;
      color: #fff;
      box-shadow: 0 0 8px rgba(211, 47, 47, 0.6);
    }

    .mute-group-btn.active:hover {
      background: #f44336;
      border-color: #ff5252;
    }

    .mute-group-btn.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .mute-group-btn.active.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 8px rgba(211, 47, 47, 0.6), 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .mute-group-btn .midi-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 6px;
      height: 6px;
      background: #4CAF50;
      border-radius: 50%;
    }

    .faders-grid {
      display: flex;
      gap: 6px;
      flex: 1;
      align-items: stretch;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 10px;
      position: relative;
    }

    .faders-scrollable {
      display: flex;
      gap: 6px;
      align-items: stretch;
      flex: 0 1 auto;
      overflow-x: auto;
      overflow-y: hidden;
      min-width: 0;
      flex-wrap: nowrap;
    }

    .faders-main {
      display: flex;
      gap: 6px;
      align-items: stretch;
      padding-left: 12px;
      border-left: 2px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
      width: auto;
    }

    .fader-channel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      background: rgba(80, 80, 80, 0.8);
      padding: 6px 4px;
      border-radius: 4px;
      min-width: 65px;
      max-width: 75px;
      flex-shrink: 0;
      height: 100%;
      transition: box-shadow 0.3s ease;
    }

    /* Change source indicators */
    .fader-channel.change-midi {
      box-shadow: 0 0 12px rgba(91, 155, 213, 0.6);
    }

    .fader-channel.change-api {
      box-shadow: 0 0 12px rgba(217, 124, 78, 0.6);
    }

    .fader-channel.change-ui {
      box-shadow: 0 0 12px rgba(74, 155, 127, 0.6);
    }

    .fader-channel.selected {
      box-shadow: 0 0 16px rgba(91, 155, 213, 0.8);
      outline: 2px solid rgba(91, 155, 213, 0.6);
      outline-offset: 2px;
    }

    .fader-value {
      font-size: 0.65rem;
      font-weight: 600;
      color: #b0b0b0;
      min-height: 14px;
    }

    .fader-indicators {
      display: flex;
      gap: 3px;
      justify-content: center;
      margin-bottom: 2px;
      min-height: 16px;
    }

    .fader-indicator {
      font-size: 0.5rem;
      font-weight: bold;
      padding: 1px 3px;
      border-radius: 2px;
      line-height: 1;
    }

    .fader-indicator.main-assign {
      font-size: 0.65rem;
      font-weight: 600;
      padding: 3px 6px;
      border-radius: 3px;
      min-height: 18px;
      min-width: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 45px;
    }

    .fader-indicator.main-assign.assigned {
      background: rgba(210, 180, 140, 0.9); /* Tan */
      color: #333;
    }

    .fader-indicator.main-assign.unassigned {
      background: rgba(100, 100, 100, 0.6); /* Grey */
      color: #e0e0e0;
    }

    .fader-indicator.input-source {
      background: rgba(100, 100, 100, 0.6);
      color: #e0e0e0;
      font-size: 0.65rem;
      font-weight: 600;
      padding: 3px 6px;
      border-radius: 3px;
      min-height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fader-indicator.input-source.source-analog {
      background: rgba(76, 175, 80, 0.9);
      color: #fff;
    }

    .fader-indicator.input-source.source-network {
      background: rgba(156, 39, 176, 0.9);
      color: #fff;
    }

    .fader-indicator.input-source.source-usb {
      background: rgba(33, 150, 243, 0.9);
      color: #fff;
    }

    .fader-indicator.input-source.source-sdcard {
      background: rgba(255, 152, 0, 0.9);
      color: #fff;
    }

    .fader-icon {
      font-size: 1.2rem;
      text-align: center;
      padding: 2px 0;
      width: 100%;
      min-height: 24px; /* Fixed height to ensure consistent alignment */
    }

    .fader-channel-number {
      font-size: 1rem;
      font-weight: bold;
      text-align: center;
      color: #e0e0e0;
      padding: 2px 0;
      width: 100%;
      min-height: 20px;
    }

    .fader-label {
      font-size: 0.65rem;
      font-weight: 600;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.1;
      padding: 3px 4px;
      border-radius: 3px;
      width: 100%;
      min-height: 18px; /* Fixed height to ensure consistent alignment */
      /* Color will be set inline based on background brightness */
    }

    .fader-mapping-info {
      font-size: 0.65rem;
      font-weight: 600;
      color: #ffffff;
      text-align: center;
      padding: 3px 5px;
      line-height: 1.2;
      width: 100%;
      min-height: 18px; /* Fixed height to ensure consistent alignment */
      background: rgba(0, 0, 0, 0.3);
      border-radius: 3px;
      opacity: 0.95;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .fader-mapping-info.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .mute-btn {
      width: 28px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background: rgba(30, 30, 30, 0.6);
      color: rgba(255, 255, 255, 0.5);
      border-radius: 3px;
      font-size: 0.65rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      padding: 0;
    }

    .mute-btn:hover {
      background: rgba(50, 50, 50, 0.8);
      border-color: rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 0.8);
    }

    .mute-btn.active {
      background: #c74a3a;
      border-color: #c74a3a;
      color: #fff;
      box-shadow: 0 0 8px rgba(199, 74, 58, 0.5);
    }

    .mute-btn.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .mute-btn.active.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 8px rgba(199, 74, 58, 0.5), 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .solo-btn {
      width: 28px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background: rgba(30, 30, 30, 0.6);
      color: rgba(255, 255, 255, 0.5);
      border-radius: 3px;
      font-size: 0.65rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      padding: 0;
    }

    .solo-btn:hover {
      background: rgba(50, 50, 50, 0.8);
      border-color: rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 0.8);
    }

    .solo-btn.active {
      background: #f4c430;
      border-color: #f4c430;
      color: #000;
      box-shadow: 0 0 8px rgba(244, 196, 48, 0.5);
    }

    .solo-btn.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .solo-btn.active.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 8px rgba(244, 196, 48, 0.5), 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .fader-controls {
      display: flex;
      gap: 4px;
      justify-content: center;
      margin-bottom: 4px;
    }

    .fader-container {
      width: 24px;
      height: 100%; /* Fill available height */
      min-height: 200px;
      background: rgba(50, 50, 50, 0.95);
      border-radius: 12px;
      position: relative;
      border: 2px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.08);
      overflow: hidden;
      cursor: pointer;
      user-select: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    /* Stereo fader - half width for dual L/R display */
    .fader-container.stereo {
      width: 11px;
    }

    .fader-container:hover {
      border-color: rgba(74, 155, 127, 0.5);
    }

    .fader-container.dragging {
      border-color: #4a9b7f;
    }

    .fader-container.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .fader-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to bottom, #4a9b7f, #3d7a63);
      border-radius: 0 0 13px 13px;
      transition: height 0.1s;
      min-height: 2px;
    }

    .fader-midi-indicator {
      position: absolute;
      left: -8px;
      right: -8px;
      height: 2px;
      background: #ff9800;
      box-shadow: 0 0 4px rgba(255, 152, 0, 0.8);
      pointer-events: none;
      z-index: 10;
      transition: bottom 0.1s ease-out;
    }

    /* Zero line indicator at 0dB (75% height) */
    .fader-container::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: 75%; /* 0dB is at 75% */
      height: 2px;
      background: rgba(255, 255, 255, 0.4);
      z-index: 10;
      pointer-events: none;
    }

    .fader-wrapper {
      display: flex;
      align-items: stretch; /* Stretch to fill height */
      justify-content: flex-start; /* Align to start */
      gap: 3px;
      flex: 1;
    }

    .fader-levels {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      min-height: 200px;
      font-size: 0.55rem;
      color: rgba(255, 255, 255, 0.3);
      line-height: 1;
      min-width: 18px;
      text-align: right;
      flex-shrink: 0; /* Don't shrink the levels */
    }

    /* Wrapper for fader-container to center it */
    .fader-container-wrapper {
      display: flex;
      justify-content: center;
      align-items: stretch;
      flex: 1;
    }

    /* Mappings view */
    .mappings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .mappings-list {
      display: grid;
      gap: 15px;
    }

    .mapping-card {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .mapping-activity {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transition: all 0.15s;
    }

    .mapping-activity.active {
      background: #00ff88;
      box-shadow: 0 0 10px #00ff88;
    }

    .mapping-info {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 15px;
      align-items: center;
    }

    .mapping-source, .mapping-target {
      font-size: 0.9rem;
    }

    .mapping-arrow {
      font-size: 1.5rem;
      opacity: 0.6;
    }

    .btn-small {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .btn-small:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-small.danger:hover {
      background: rgba(255, 68, 68, 0.3);
      border-color: rgba(255, 68, 68, 0.5);
    }

    .icon-btn {
      background: transparent;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 1.1rem;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .icon-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: rgba(30, 30, 30, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 4px 0;
      min-width: 150px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.8);
      z-index: 2000;
      display: none;
    }

    .context-menu.show {
      display: block;
    }

    .context-menu-header {
      padding: 6px 16px;
      color: #4CAF50;
      font-weight: bold;
      font-size: 0.85rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 4px;
    }

    .context-menu-item {
      padding: 8px 16px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }

    .context-menu-item:hover {
      background: rgba(74, 155, 127, 0.3);
    }

    .context-menu-item.danger:hover {
      background: rgba(255, 68, 68, 0.3);
    }

    .context-menu-separator {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 4px 0;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: rgba(20, 20, 20, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 20px;
      max-width: 500px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
    }

    .modal-content h2 {
      margin-bottom: 15px;
      margin-top: 0;
      color: #e0e0e0;
      font-size: 1.3rem;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9rem;
      color: #b0b0b0;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 10px 15px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(30, 30, 30, 0.8);
      color: #e0e0e0;
      font-size: 1rem;
    }

    .form-group input::placeholder {
      color: rgba(255, 255, 255, 0.3);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .mixer-list {
      display: grid;
      gap: 10px;
      margin: 15px 0;
    }

    .mixer-item {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .mixer-info {
      flex: 1;
    }

    .mixer-item .btn {
      min-width: 80px;
      width: auto;
      padding: 8px 16px;
    }

    .mixer-name {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 5px;
    }

    .midi-section-header {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #888;
      padding: 8px 2px 4px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      margin-bottom: 8px;
    }

    .mixer-item.connected-device {
      border-color: #4a9b7f;
      background: rgba(74, 155, 127, 0.1);
    }

    .btn.listening {
      background: #ff9800;
      color: #000;
      animation: pulse-orange 1s ease-in-out infinite;
    }

    @keyframes pulse-orange {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .mixer-details {
      opacity: 0.8;
      font-size: 0.9rem;
    }

    .empty-state {
      text-align: center;
      padding: 40px;
      opacity: 0.5;
      color: #666;
    }

    /* Bottom Status Bar */
    .status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40px;
      background: rgba(15, 15, 15, 0.95);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      font-size: 0.85rem;
      z-index: 900;
    }

    .status-bar-left, .status-bar-center, .status-bar-right {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .status-bar-center {
      flex: 1;
      justify-content: center;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-item-label {
      color: #666;
      font-size: 0.8rem;
    }

    .status-item-value {
      color: #b0b0b0;
      font-weight: 500;
    }

    .status-item-value.connected {
      color: #4a9b7f;
    }

    .status-item-value.disconnected {
      color: #c74a3a;
    }

    /* MIDI Log Window */
    .midi-log-window {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 400px;
      height: 300px;
      background: rgba(20, 20, 20, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      display: none;
      flex-direction: column;
      z-index: 999;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
    }

    .midi-log-window.show {
      display: flex;
    }

    .midi-log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(30, 30, 30, 0.8);
      border-radius: 8px 8px 0 0;
    }

    .midi-log-header h3 {
      margin: 0;
      font-size: 0.9rem;
      color: #e0e0e0;
    }

    .midi-log-controls {
      display: flex;
      gap: 8px;
    }

    .midi-log-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #e0e0e0;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .midi-log-btn:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .midi-log-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      line-height: 1.4;
    }

    .midi-log-entry {
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.03);
    }

    .midi-log-entry.cc {
      border-left: 3px solid #4a9b7f;
    }

    .midi-log-entry.note {
      border-left: 3px solid #9b7f4a;
    }

    .midi-log-timestamp {
      color: #666;
      margin-right: 8px;
    }

    .midi-log-type {
      color: #4a9b7f;
      font-weight: bold;
      margin-right: 8px;
    }

    .midi-log-entry.note .midi-log-type {
      color: #9b7f4a;
    }

    .midi-log-details {
      color: #b0b0b0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1><img src="../assets/icon.png" style="width:32px;height:32px;vertical-align:middle;margin-right:8px;" /> StudioLive MIDI Controller</h1>
      </div>
      <div class="header-right">
        <button class="btn-small" onclick="showPreferences()" title="Preferences">‚öôÔ∏è</button>
        <button class="btn-small" onclick="showSavePreset()" title="Save Profile">üíæ Save</button>
        <button class="btn-small" onclick="showLoadPreset()" title="Load Profile">üìÇ Load</button>
        <button class="btn-small" onclick="showMappingsList()" title="View All Mappings">üìã Mappings</button>
        <button class="btn-small" onclick="toggleMidiLog()" title="Show MIDI Log">üìä MIDI Log</button>
        <div class="connection-status" onclick="openConnectionPanel('midi')" id="midi-connection-status" title="">
          <div class="status-dot" id="midi-status-dot"></div>
          <span id="midi-status-short">MIDI</span>
          <div class="activity-indicator midi" id="midi-activity"></div>
        </div>
        <div class="connection-status" onclick="openConnectionPanel('mixer')" id="mixer-connection-status" title="">
          <div class="status-dot" id="mixer-status-dot"></div>
          <span id="mixer-status-short">Mixer</span>
          <div class="activity-indicator mixer" id="mixer-activity"></div>
        </div>
      </div>
    </div>

    <div class="main-layout">
      <!-- Main content -->
      <div class="content-area">
        <div id="faders-view" class="tab-content active">
          <div class="faders-toolbar">
            <button class="btn" onclick="showAddMapping()" title="Add Channel">‚ûï</button>
            <select class="btn" id="filter-select" onchange="onFilterChange()" style="min-width: 150px;">
              <option value="all">üîç View: All</option>
              <option value="mapped">üîç View: Mapped</option>
            </select>
            <!-- Spacer to push mute groups to the right -->
            <div class="toolbar-spacer"></div>
            <!-- Mute groups (right-aligned) -->
            <div class="mute-groups" id="mute-groups-container">
              <!-- Mute group buttons will be dynamically added here -->
            </div>
          </div>
          <div class="faders-grid">
            <div id="faders-container" class="faders-scrollable"></div>
            <div id="faders-main-container" class="faders-main"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bottom Status Bar -->
  <div class="status-bar">
    <div class="status-bar-left">
      <div class="status-item">
        <span id="status-init" style="cursor: pointer; text-decoration: underline dotted;" onclick="showStatusLog()" title="Click to view initialization log">Initializing...</span>
      </div>
    </div>
    <div class="status-bar-center">
      <div class="status-item">
        <span class="status-item-label">Profile:</span>
        <span class="status-item-value" id="status-profile">None</span>
        <span id="status-unsaved" style="color: #ff9800; margin-left: 8px; display: none;">‚óè</span>
      </div>
      <div class="status-item">
        <span class="status-item-label">Last Saved:</span>
        <span class="status-item-value" id="status-last-saved">Never</span>
      </div>
    </div>
    <div class="status-bar-right">
      <div class="status-item">
        <span class="status-item-label">Version:</span>
        <span class="status-item-value" id="status-version">0.9.0</span>
      </div>
    </div>
  </div>

  <!-- Modals -->
  <div id="discovery-modal" class="modal">
    <div class="modal-content">
      <h2>üîç Find Mixer</h2>
      <button class="btn" id="scan-btn" onclick="scanForMixers()">Scan Network</button>
      <div id="mixer-list" class="mixer-list">
        <div class="empty-state">Click "Scan Network" to discover mixers</div>
      </div>
      <h3 style="margin-top: 20px; margin-bottom: 10px;">Manual Connection</h3>
      <div class="form-group">
        <input type="text" id="manual-ip" placeholder="Enter mixer IP (e.g., 192.168.1.100)" />
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="connectManual()">Connect</button>
        <button class="btn" onclick="hideDiscovery()">Close</button>
      </div>
    </div>
  </div>

  <div id="add-mapping-modal" class="modal">
    <div class="modal-content">
      <h2>‚ûï Create Mapping</h2>
      <!-- Mixer Settings (Top) -->
      <div class="form-group">
        <label>Mixer Channel Type</label>
        <select id="mixer-channel-type" onchange="updateChannelNumberOptions()">
          <option value="LINE">Line Input</option>
          <option value="RETURN">Digital Return (Dig Ret)</option>
          <option value="FXRETURN">FX Return</option>
          <option value="TALKBACK">Talkback</option>
          <option value="AUX">Aux Output</option>
          <option value="FX">FX Bus</option>
          <option value="SUB">Subgroup</option>
          <option value="MAIN">Main Mix</option>
          <option value="DCA">DCA Group</option>
        </select>
      </div>
      <div class="form-group">
        <label>Mixer Channel Number</label>
        <select id="mixer-channel-num" onchange="updateMidiSettingsForChannel()">
          <!-- Will be populated dynamically -->
        </select>
      </div>
      <div class="form-group">
        <label>Mixer Action</label>
        <select id="mixer-action" onchange="updateMidiTypeFields()">
          <option value="volume">Volume</option>
          <option value="mute">Mute</option>
          <option value="solo">Solo</option>
          <option value="pan">Pan</option>
        </select>
      </div>
      <!-- MIDI Settings (Bottom) -->
      <div class="form-group">
        <label>MIDI Type</label>
        <select id="midi-type" onchange="updateMidiTypeFields()">
          <option value="none">None</option>
          <option value="cc">Control Change (CC)</option>
          <option value="note">Note (Trigger)</option>
          <option value="note-value">Note (Value Mode)</option>
        </select>
      </div>
      <div class="form-group" id="cc-threshold-group" style="display:none;">
        <label>CC Threshold (for Mute/Solo)</label>
        <input type="number" id="midi-cc-threshold" value="64" min="0" max="127" />
        <small style="color: #888; display: block; margin-top: 5px;">Values >= threshold activate, values < threshold deactivate (default: 64 = middle)</small>
      </div>
      <div class="form-group" id="cc-group">
        <label>CC Type</label>
        <select id="midi-cc">
          <option value="0">CC0 - Bank MSB</option>
          <option value="1">CC1 - Modulation</option>
          <option value="2">CC2 - Breath</option>
          <option value="3">CC3 - Ctrl 3</option>
          <option value="4">CC4 - Foot Control</option>
          <option value="5">CC5 - Portamento Time</option>
          <option value="6">CC6 - Data MSB</option>
          <option value="7" selected>CC7 - MIDI Volume</option>
          <option value="8">CC8 - Balance</option>
          <option value="9">CC9 - Ctrl 9</option>
          <option value="10">CC10 - MIDI Pan</option>
          <option value="11">CC11 - Expression</option>
          <option value="12">CC12 - Effect #1 MSB</option>
          <option value="13">CC13 - Effect #2 MSB</option>
          <option value="14">CC14 - Ctrl 14</option>
          <option value="15">CC15 - Ctrl 15</option>
          <option value="16">CC16 - General #1</option>
          <option value="17">CC17 - General #2</option>
          <option value="18">CC18 - General #3</option>
          <option value="19">CC19 - General #4</option>
          <option value="20">CC20 - Ctrl 20</option>
          <option value="21">CC21 - Ctrl 21</option>
          <option value="22">CC22 - Ctrl 22</option>
          <option value="23">CC23 - Ctrl 23</option>
          <option value="24">CC24 - Ctrl 24</option>
          <option value="25">CC25 - Ctrl 25</option>
          <option value="26">CC26 - Ctrl 26</option>
          <option value="27">CC27 - Ctrl 27</option>
          <option value="28">CC28 - Ctrl 28</option>
          <option value="29">CC29 - Ctrl 29</option>
          <option value="30">CC30 - Ctrl 30</option>
          <option value="31">CC31 - Ctrl 31</option>
          <option value="32">CC32 - Bank LSB</option>
          <option value="33">CC33 - (#01 LSB)</option>
          <option value="34">CC34 - (#02 LSB)</option>
          <option value="35">CC35 - (#03 LSB)</option>
          <option value="36">CC36 - (#04 LSB)</option>
          <option value="37">CC37 - (#05 LSB)</option>
          <option value="38">CC38 - (#06 LSB)</option>
          <option value="39">CC39 - (#07 LSB)</option>
          <option value="40">CC40 - (#08 LSB)</option>
          <option value="41">CC41 - (#09 LSB)</option>
          <option value="42">CC42 - (#10 LSB)</option>
          <option value="43">CC43 - (#11 LSB)</option>
          <option value="44">CC44 - Effect #1 LSB</option>
          <option value="45">CC45 - Effect #2 LSB</option>
          <option value="46">CC46 - (#14 LSB)</option>
          <option value="47">CC47 - (#15 LSB)</option>
          <option value="48">CC48 - (#16 LSB)</option>
          <option value="49">CC49 - (#17 LSB)</option>
          <option value="50">CC50 - (#18 LSB)</option>
          <option value="51">CC51 - (#19 LSB)</option>
          <option value="52">CC52 - (#20 LSB)</option>
          <option value="53">CC53 - (#21 LSB)</option>
          <option value="54">CC54 - (#22 LSB)</option>
          <option value="55">CC55 - (#23 LSB)</option>
          <option value="56">CC56 - (#24 LSB)</option>
          <option value="57">CC57 - (#25 LSB)</option>
          <option value="58">CC58 - (#26 LSB)</option>
          <option value="59">CC59 - (#27 LSB)</option>
          <option value="60">CC60 - (#28 LSB)</option>
          <option value="61">CC61 - (#29 LSB)</option>
          <option value="62">CC62 - (#30 LSB)</option>
          <option value="63">CC63 - (#31 LSB)</option>
          <option value="64">CC64 - Sustain</option>
          <option value="65">CC65 - Portamento</option>
          <option value="66">CC66 - Sostenuto</option>
          <option value="67">CC67 - Soft Pedal</option>
          <option value="68">CC68 - Legato</option>
          <option value="69">CC69 - Hold 2</option>
          <option value="70">CC70 - Sound Variation</option>
          <option value="71">CC71 - Timbre</option>
          <option value="72">CC72 - Release Time</option>
          <option value="73">CC73 - Attack Time</option>
          <option value="74">CC74 - Brightness</option>
          <option value="75">CC75 - Decay Time</option>
          <option value="76">CC76 - Vibrato Rate</option>
          <option value="77">CC77 - Vibrato Depth</option>
          <option value="78">CC78 - Vibrato Delay</option>
          <option value="79">CC79 - Ctrl 79</option>
          <option value="80">CC80 - Decay</option>
          <option value="81">CC81 - HPF Frequency</option>
          <option value="82">CC82 - General #5</option>
          <option value="83">CC83 - General #6</option>
          <option value="84">CC84 - Portamento Control</option>
          <option value="85">CC85 - Ctrl 85</option>
          <option value="86">CC86 - Ctrl 86</option>
          <option value="87">CC87 - Ctrl 87</option>
          <option value="88">CC88 - High Resolution Velocity Prefix</option>
          <option value="89">CC89 - Ctrl 89</option>
          <option value="90">CC90 - Ctrl 90</option>
          <option value="91">CC91 - Reverb</option>
          <option value="92">CC92 - Tremolo Depth</option>
          <option value="93">CC93 - Chorus Send Level</option>
          <option value="94">CC94 - Celeste (Detune) Depth</option>
          <option value="95">CC95 - Phaser Depth</option>
          <option value="96">CC96 - Data Increment</option>
          <option value="97">CC97 - Data Decrement</option>
          <option value="98">CC98 - Non-Reg. LSB</option>
          <option value="99">CC99 - Non-Reg. MSB</option>
          <option value="100">CC100 - Reg.Par. LSB</option>
          <option value="101">CC101 - Reg.Par. MSB</option>
          <option value="102">CC102 - Ctrl 102</option>
          <option value="103">CC103 - Ctrl 103</option>
          <option value="104">CC104 - Ctrl 104</option>
          <option value="105">CC105 - Ctrl 105</option>
          <option value="106">CC106 - Ctrl 106</option>
          <option value="107">CC107 - Ctrl 107</option>
          <option value="108">CC108 - Ctrl 108</option>
          <option value="109">CC109 - Ctrl 109</option>
          <option value="110">CC110 - Ctrl 110</option>
          <option value="111">CC111 - Ctrl 111</option>
          <option value="112">CC112 - Ctrl 112</option>
          <option value="113">CC113 - Ctrl 113</option>
          <option value="114">CC114 - Ctrl 114</option>
          <option value="115">CC115 - Ctrl 115</option>
          <option value="116">CC116 - Ctrl 116</option>
          <option value="117">CC117 - Ctrl 117</option>
          <option value="118">CC118 - Ctrl 118</option>
          <option value="119">CC119 - Ctrl 119</option>
          <option value="120">CC120 - All Sound Off</option>
          <option value="121">CC121 - Reset All Controllers</option>
          <option value="122">CC122 - Local Control</option>
          <option value="123">CC123 - All Notes Off</option>
          <option value="124">CC124 - Omni Mode Off</option>
          <option value="125">CC125 - Omni Mode On</option>
          <option value="126">CC126 - Mono Mode On</option>
          <option value="127">CC127 - Poly Mode On</option>
        </select>
        <small style="color: #888; display: block; margin-top: 5px;">Logic Pro default: CC7 (Volume) with channel = mixer channel number</small>
      </div>
      <div class="form-group">
        <label>MIDI Channel (1-16)</label>
        <input type="number" id="midi-channel" value="1" min="1" max="16" />
        <small style="color: #888; display: block; margin-top: 5px;">Logic Pro uses channels 1-16 (MIDI 0-15 internally)</small>
      </div>
      <div class="form-group" id="midi-device-filter-group">
        <label>MIDI Device Filter</label>
        <select id="midi-device-filter">
          <option value="">Any connected device</option>
          <!-- Populated dynamically from connected devices -->
        </select>
        <small style="color: #888; display: block; margin-top: 5px;">Optional: only respond to signals from this specific device</small>
      </div>
      <div class="form-group" id="note-group" style="display:none;">
        <label>Note Number (Trigger)</label>
        <input type="number" id="midi-note" value="60" min="0" max="127" oninput="updateNoteDisplay()" />
        <small style="color: #888;" id="note-display">C4 (60)</small>
      </div>
      <div class="form-group" id="note-invert-group" style="display:none;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="midi-note-invert" style="width: auto; margin: 0;" />
          <span>Invert Note Logic (for Mute/Solo)</span>
        </label>
        <small style="color: #888; display: block; margin-top: 5px;">When checked: Note ON = deactivate, Note OFF = activate</small>
      </div>
      <div class="form-group" id="note-value-group" style="display:none;">
        <label>Note Range (C1-C4 = 24-60)</label>
        <div style="display: flex; gap: 10px; align-items: center;">
          <div style="flex: 1;">
            <label style="font-size: 0.75rem; color: #888;">Min Note</label>
            <input type="number" id="midi-note-min" value="24" min="0" max="127" oninput="updateNoteMinDisplay()" />
            <small style="color: #888; display: block;" id="note-min-display">C1 (24)</small>
          </div>
          <div style="flex: 1;">
            <label style="font-size: 0.75rem; color: #888;">Max Note</label>
            <input type="number" id="midi-note-max" value="60" min="0" max="127" oninput="updateNoteMaxDisplay()" />
            <small style="color: #888; display: block;" id="note-max-display">C4 (60)</small>
          </div>
        </div>
        <small style="color: #888; display: block; margin-top: 5px;">Note number maps to fader value (min=0%, max=100%)</small>
      </div>
      <div class="form-group" id="midi-listen-group">
        <label>MIDI Learn</label>
        <div style="display: flex; align-items: center; gap: 12px;">
          <button class="btn" id="midi-listen-btn" type="button" onclick="toggleMidiListen()">Learn</button>
          <span id="midi-listen-status" style="color: #888; font-size: 0.85rem;"></span>
        </div>
        <small style="color: #888; display: block; margin-top: 5px;">Click Learn, then send a MIDI signal to auto-detect type, channel, and CC/note</small>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="addMapping()">Add Mapping</button>
        <button class="btn" onclick="hideAddMapping()">Cancel</button>
      </div>
    </div>
  </div>

  <div id="save-preset-modal" class="modal">
    <div class="modal-content">
      <h2>üíæ Save Preset</h2>
      <div class="form-group">
        <label>Preset Name</label>
        <input type="text" id="preset-name" placeholder="My Preset" />
      </div>
      <div class="form-group">
        <label>Description (optional)</label>
        <input type="text" id="preset-description" placeholder="Description" />
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="savePreset()">Save</button>
        <button class="btn" onclick="hideSavePreset()">Cancel</button>
      </div>
    </div>
  </div>

  <div id="midi-select-modal" class="modal">
    <div class="modal-content">
      <h2>üéπ MIDI Connection</h2>
      <div id="midi-devices-list" class="mixer-list">
        <div class="empty-state">Loading MIDI devices...</div>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="refreshMidiDevices()">üîÑ Refresh</button>
        <button class="btn" onclick="hideMidiSelect()">Close</button>
      </div>
    </div>
  </div>

  <div id="preferences-modal" class="modal">
    <div class="modal-content">
      <h2>‚öôÔ∏è Preferences</h2>
      <div class="form-group">
        <label>Fader Smoothing</label>
        <input type="range" id="fader-smoothing" min="0" max="500" value="200" step="50" oninput="updateSmoothingDisplay()" />
        <small style="color: #888; display: block; margin-top: 5px;">
          Speed: <span id="smoothing-display">200</span>ms (relative to change amount)
        </small>
        <small style="color: #888; display: block; margin-top: 5px;">
          Lower = faster response, Higher = smoother transitions
        </small>
      </div>
      <div class="form-group" style="margin-top: 20px;">
        <label style="display: flex; align-items: center; cursor: pointer;">
          <input type="checkbox" id="midi-feedback-enabled" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;" />
          <span>Enable MIDI Feedback</span>
        </label>
        <small style="color: #888; display: block; margin-top: 5px;">
          Send fader positions back to MIDI controller (e.g., Logic Pro)
        </small>
        <small style="color: #ff9800; display: block; margin-top: 5px;">
          ‚ö†Ô∏è Disable if experiencing MIDI feedback loops
        </small>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="savePreferences()">Save</button>
        <button class="btn" onclick="hidePreferences()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Mappings List Modal -->
  <div id="mappings-list-modal" class="modal">
    <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
      <h2>üìã All MIDI Mappings</h2>
      <div id="mappings-list-view" style="margin: 20px 0;">
        <!-- Will be populated by JavaScript -->
      </div>
      <div class="modal-buttons">
        <button class="btn danger" onclick="clearAllMappingsFromList()" style="margin-right: auto;">üßπ Clear All Mappings</button>
        <button class="btn" onclick="hideMappingsList()">Close</button>
      </div>
    </div>
  </div>

  <!-- Context Menus -->
  <!-- Fader Volume Context Menu -->
  <div id="fader-context-menu" class="context-menu">
    <div class="context-menu-header">üéöÔ∏è Volume Fader</div>
    <div class="context-menu-item" onclick="contextMenuEditFader()">‚úèÔ∏è Edit Volume Mapping</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuClearFader()">üßπ Clear Volume Mapping</div>
  </div>

  <!-- Mute Button Context Menu -->
  <div id="mute-context-menu" class="context-menu">
    <div class="context-menu-header">üîá Mute Button</div>
    <div class="context-menu-item" onclick="contextMenuEditMute()">‚úèÔ∏è Edit Mute Mapping</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuClearMute()">üßπ Clear Mute Mapping</div>
  </div>

  <!-- Solo Button Context Menu -->
  <div id="solo-context-menu" class="context-menu">
    <div class="context-menu-header">üîä Solo Button</div>
    <div class="context-menu-item" onclick="contextMenuEditSolo()">‚úèÔ∏è Edit Solo Mapping</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuClearSolo()">üßπ Clear Solo Mapping</div>
  </div>

  <!-- Channel Context Menu -->
  <div id="channel-context-menu" class="context-menu">
    <div class="context-menu-header">üìª Channel</div>
    <div class="context-menu-item" onclick="contextMenuRemoveChannel()">üóëÔ∏è Remove Channel</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item danger" onclick="contextMenuClearAllMappings()">üßπ Clear All MIDI Mappings</div>
  </div>

  <!-- Mute Group Context Menu -->
  <div id="mutegroup-context-menu" class="context-menu">
    <div class="context-menu-header">üéöÔ∏è Mute Group</div>
    <div class="context-menu-item" onclick="contextMenuEditMuteGroup()">‚úèÔ∏è Edit Mute Group Mapping</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuClearMuteGroup()">üßπ Clear Mute Group Mapping</div>
  </div>

  <!-- MIDI Log Window -->
  <div id="midi-log-window" class="midi-log-window">
    <div class="midi-log-header">
      <h3>üìä MIDI Events</h3>
      <div class="midi-log-controls">
        <button class="midi-log-btn" onclick="clearMidiLog()">Clear</button>
        <button class="midi-log-btn" onclick="toggleMidiLog()">Close</button>
      </div>
    </div>
    <div class="midi-log-content" id="midi-log-content">
      <div style="color: #666; text-align: center; padding: 20px;">No MIDI events yet...</div>
    </div>
  </div>

  <!-- Status Log Modal -->
  <div id="status-log-modal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
      <h2>üìã Initialization Log</h2>
      <div style="max-height: 400px; overflow-y: auto; background: #1a1a1a; padding: 15px; border-radius: 4px; font-family: monospace; font-size: 12px;">
        <div id="status-log-content"></div>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="clearStatusLog()">Clear Log</button>
        <button class="btn" onclick="hideStatusLog()">Close</button>
      </div>
    </div>
  </div>

  <!-- Update Available Modal -->
  <div id="update-modal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
      <h2>üéâ Update Available</h2>
      <div style="padding: 20px 0;">
        <p style="font-size: 1.1rem; margin-bottom: 15px;">
          A new version of StudioLive MIDI Controller is available!
        </p>
        <div style="background: #1a1a1a; padding: 15px; border-radius: 4px; margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <span style="color: #888;">Current Version:</span>
            <span id="update-current-version" style="font-weight: bold;">-</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span style="color: #888;">Latest Version:</span>
            <span id="update-latest-version" style="font-weight: bold; color: #4CAF50;">-</span>
          </div>
        </div>
        <div id="update-release-notes" style="background: #1a1a1a; padding: 15px; border-radius: 4px; margin-bottom: 15px; max-height: 200px; overflow-y: auto; display: none;">
          <h3 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #4CAF50;">üìù Release Notes</h3>
          <div id="update-release-notes-content" style="color: #ccc; font-size: 0.85rem; line-height: 1.5; white-space: pre-wrap;"></div>
        </div>
        <p style="color: #888; font-size: 0.9rem;">
          Click "Download Update" to visit the release page and download the latest version.
        </p>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="hideUpdateModal()">Later</button>
        <button class="btn" onclick="downloadUpdate()" style="background: #4CAF50;">Download Update</button>
      </div>
    </div>
  </div>

  <script>
    console.log('[Renderer] Script starting...');
    const { ipcRenderer } = require('electron');
    console.log('[Renderer] ipcRenderer loaded');

    // Track mapping activity
    const mappingActivity = new Map();

    // Default color - grey so it's clear when mixer colors are applied
    const DEFAULT_COLOR = '#666666';

    // Store fader colors to preserve them across updates
    const faderColors = new Map();

    // Fader filter state: 'all' or 'mapped'
    let faderFilter = 'all';

    // Flag to prevent auto-updating MIDI settings when editing
    let isEditingMapping = false;

    // Channel data cache (shared across loadFaders and updateFilterDropdown)
    let channelDataCache = {};

    // Current mappings (shared across components)
    let currentMappings = [];

    // Flag to prevent multiple simultaneous loadFaders calls
    let isLoadingFaders = false;

    // Status log for tracking initialization and errors
    let statusLog = [];
    const MAX_LOG_ENTRIES = 100;

    // Add entry to status log
    function addStatusLog(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const entry = { timestamp, message, type };
      statusLog.push(entry);

      // Keep only last MAX_LOG_ENTRIES
      if (statusLog.length > MAX_LOG_ENTRIES) {
        statusLog.shift();
      }

      console.log(`[Status ${type.toUpperCase()}] ${message}`);
    }

    // Show status log modal
    function showStatusLog() {
      const modal = document.getElementById('status-log-modal');
      const content = document.getElementById('status-log-content');

      if (statusLog.length === 0) {
        content.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No log entries yet...</div>';
      } else {
        content.innerHTML = statusLog.map(entry => {
          let color = '#4CAF50'; // green for info
          let icon = '‚ÑπÔ∏è';

          if (entry.type === 'error') {
            color = '#f44336'; // red
            icon = '‚ùå';
          } else if (entry.type === 'warning') {
            color = '#ff9800'; // orange
            icon = '‚ö†Ô∏è';
          } else if (entry.type === 'success') {
            color = '#4CAF50'; // green
            icon = '‚úÖ';
          }

          return `<div style="margin-bottom: 8px; color: ${color};">
            <span style="color: #888;">[${entry.timestamp}]</span> ${icon} ${entry.message}
          </div>`;
        }).reverse().join(''); // Reverse to show newest first
      }

      modal.classList.add('show');
    }

    // Hide status log modal
    function hideStatusLog() {
      const modal = document.getElementById('status-log-modal');
      modal.classList.remove('show');
    }

    // Clear status log
    function clearStatusLog() {
      statusLog = [];
      const content = document.getElementById('status-log-content');
      content.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No log entries yet...</div>';
    }

    // Update modal functions
    let updateDownloadUrl = '';

    function showUpdateModal(currentVersion, latestVersion, downloadUrl, releaseNotes) {
      updateDownloadUrl = downloadUrl;
      document.getElementById('update-current-version').textContent = currentVersion;
      document.getElementById('update-latest-version').textContent = latestVersion;

      // Show release notes if available
      if (releaseNotes) {
        const notesContainer = document.getElementById('update-release-notes');
        const notesContent = document.getElementById('update-release-notes-content');
        notesContent.textContent = releaseNotes;
        notesContainer.style.display = 'block';
      } else {
        document.getElementById('update-release-notes').style.display = 'none';
      }

      const modal = document.getElementById('update-modal');
      modal.classList.add('show');
    }

    function hideUpdateModal() {
      const modal = document.getElementById('update-modal');
      modal.classList.remove('show');
    }

    function downloadUpdate() {
      if (updateDownloadUrl) {
        require('electron').shell.openExternal(updateDownloadUrl);
      }
      hideUpdateModal();
    }

    // Check for updates
    async function checkForUpdates() {
      try {
        console.log('[Renderer] Checking for updates...');
        const result = await ipcRenderer.invoke('check-for-updates');

        if (result.success) {
          console.log(`[Renderer] Update check: current=${result.currentVersion}, latest=${result.latestVersion}, available=${result.updateAvailable}`);
          addStatusLog(`Version check: ${result.currentVersion} (latest: ${result.latestVersion})`, 'info');

          if (result.updateAvailable) {
            console.log('[Renderer] Update available, showing modal');
            addStatusLog(`Update available: ${result.latestVersion}`, 'warning');
            // Show update modal after a short delay to not interrupt initialization
            setTimeout(() => {
              showUpdateModal(result.currentVersion, result.latestVersion, result.downloadUrl, result.releaseNotes);
            }, 2000);
          }
        } else {
          console.log(`[Renderer] Update check failed: ${result.error}`);
          addStatusLog(`Update check failed: ${result.error}`, 'warning');
        }
      } catch (error) {
        console.error('[Renderer] Error checking for updates:', error);
        addStatusLog(`Update check error: ${error.message || error}`, 'warning');
      }
    }

    // Update status bar initialization message
    function updateStatusInit(message) {
      const statusInit = document.getElementById('status-init');
      if (statusInit) {
        statusInit.textContent = message;
      }

      // Add to log (but not "Ready" messages to avoid spam)
      if (message !== 'Ready') {
        addStatusLog(message, 'info');
      } else {
        addStatusLog(message, 'success');
      }
    }

    // Update status with a minimum display time (so users can read it)
    // For now, just update immediately without delay to avoid blocking
    async function updateStatusInitWithDelay(message, minDisplayMs = 0) {
      updateStatusInit(message);
      // Small delay to allow UI to update
      if (minDisplayMs > 0) {
        await new Promise(resolve => setTimeout(resolve, minDisplayMs));
      }
    }

    // Update status bar profile
    function updateStatusProfile(profileName) {
      const statusProfile = document.getElementById('status-profile');
      if (statusProfile) {
        statusProfile.textContent = profileName || 'None';
      }
    }

    // Update status bar last saved
    function updateStatusLastSaved(timestamp) {
      const statusLastSaved = document.getElementById('status-last-saved');
      if (statusLastSaved) {
        if (timestamp) {
          const date = new Date(timestamp);
          statusLastSaved.textContent = date.toLocaleTimeString();
          // Clear unsaved indicator when saved
          markConfigSaved();
        } else {
          statusLastSaved.textContent = 'Never';
        }
      }
    }

    // Mark config as changed (unsaved)
    function markConfigChanged() {
      const unsavedIndicator = document.getElementById('status-unsaved');
      if (unsavedIndicator) {
        unsavedIndicator.style.display = 'inline';
        unsavedIndicator.title = 'Unsaved changes';
      }
    }

    // Mark config as saved
    function markConfigSaved() {
      const unsavedIndicator = document.getElementById('status-unsaved');
      if (unsavedIndicator) {
        unsavedIndicator.style.display = 'none';
      }
    }

    // Calculate text color based on background brightness
    function getTextColorForBackground(hexColor) {
      // Remove # if present
      const hex = hexColor.replace('#', '');

      // Convert to RGB
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);

      // Calculate relative luminance (perceived brightness)
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

      // Return dark text for light backgrounds, light text for dark backgrounds
      return luminance > 0.5 ? '#1a1a1a' : '#ffffff';
    }

    // Icon mapping from Universal Control icon IDs to emoji
    // Based on PreSonus StudioLive icon categories
    const ICON_MAP = {
      // Drums
      'drumpad': 'üéõÔ∏è',        // Digital drum pad
      'drumset': 'ü•Å',
      'drums': 'ü•Å',
      'kickin': 'ü•Å',
      'kickout': 'ü•Å',
      'kick': 'ü•Å',
      'snare': 'ü•Å',
      'snaretop': 'ü•Å',
      'snarebottom': 'ü•Å',
      'racktom': 'ü•Å',
      'floortom': 'ü•Å',
      'midtom': 'ü•Å',
      'hihat': 'ü•Å',
      'hightom': 'ü•Å',
      'ohleft': 'ü•Å',
      'ohright': 'ü•Å',
      'oh': 'ü•Å',

      // Guitars
      'electricguitar': 'üé∏',
      'electric2': 'üé∏',
      'electric': 'üé∏',
      'acousticguitar': '<img src="icons/acoustic-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'acoustic2': '<img src="icons/acoustic-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'acoustic': '<img src="icons/acoustic-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'bass': '<img src="icons/bass-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'bassguitar': '<img src="icons/bass-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'electricbass': '<img src="icons/bass-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'acousticbass': '<img src="icons/bass-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'upright': 'üéª',         // Upright/double bass uses violin emoji
      'uprightbass': 'üéª',
      'doublebass': 'üéª',
      'dobro': 'ü™ï',
      'banjo': 'ü™ï',
      'guitar': 'üé∏',
      'mandolin': 'ü™ï',
      'pedalsteel': 'üé∏',
      'shamisen': 'üé∏',
      'sitar': 'ü™ï',
      'ukulele': 'ü™ï',

      // Keyboards
      'piano': 'üéπ',
      'organ': 'üéπ',
      'pipeorgan': 'üéπ',
      'keys': 'üéπ',
      'keyboard': 'üéπ',
      'keyboardstier': 'üéπ',
      'synth': 'üéπ',
      'vibraphone': 'üéπ',
      'accordion': 'ü™ó',
      'clavinet': 'üéπ',
      'harpsichord': 'üéπ',

      // Other (most important for your use case)
      'metronome': 'üéº',       // Metronome/click (using musical score icon)
      'click': 'üéº',
      'computer': 'üíª',        // Computer/backing
      'backing': 'üíª',
      'headphones': 'üéß',      // Headphones/headset
      'headphone': 'üéß',
      'headset': 'üéß',
      'microphone': 'üé§',
      'mic': 'üé§',
      'broadcaster': 'üìª',
      'djbox': 'üéõÔ∏è',
      'externalfx': '‚ú®',
      'firewire': 'üîå',
      'fohmain': 'üîä',
      'handclap': 'üëè',
      'iem': 'üéß',
      'ipad': 'üì±',
      'ipod': 'üì±',
      'mix': 'üéõÔ∏è',
      'phone': 'üì±',
      'rock': 'üé∏',
      'sidefillmonitor': 'üîä',
      'smiley': 'üòä',
      'ssd': 'üíæ',
      'tablet': 'üì±',
      'talkback': 'üí¨',
      'telephone': '‚òéÔ∏è',
      'thumbup': 'üëç',
      'turntable': 'üíø',
      'video': 'üìπ',
      'wedgemonitor': 'üîä',
      'wirelessmic': 'üé§',
      'cryroom': 'üë∂',
      'delayfill': 'üîä',

      // Percussion
      'bell': 'üîî',
      'bongo': 'ü•Å',
      'chimes': 'üéê',
      'congas': 'ü•Å',
      'cowbell': 'üîî',
      'cymbal': 'ü•Å',
      'cymbals': 'ü•Å',
      'handpan': 'ü•Å',
      'kalimba': 'üéπ',
      'miscperc': 'ü•Å',
      'orchestrdrum': 'ü•Å',
      'shakers': 'ü•Å',
      'steeldrum': 'ü•Å',
      'tambourine': 'ü•Å',
      'timbales': 'ü•Å',
      'timpani': 'ü•Å',
      'triangle': 'üî∫',
      'washboard': 'ü•Å',
      'woodblock': 'ü•Å',
      'xylophone': 'üéπ',
      'percussion': 'ü•Å',

      // Strings
      'cello': 'üéª',
      'fiddle': 'üéª',
      'harp': 'üéª',
      'stringsection': 'üéª',
      'uprightbass': 'üéª',
      'viola': 'üéª',
      'violin': 'üéª',
      'strings': 'üéª',

      // Vocals
      'backupvocals': 'üé§',
      'choirsingle': 'üé§',
      'choir': 'üé§',
      'crowdambient': 'üé§',
      'leadvocals': 'üé§',
      'speech': 'üé§',
      'vocalcue': 'üé§',
      'vocalmic': 'üé§',
      'vocals': 'üé§',
      'vocal': 'üé§',

      // Woodwinds
      'altosaxophone': 'üé∑',
      'baritone': 'üé∑',
      'bassclarinet': 'üé∑',
      'bassoon': 'üé∑',
      'clarinet': 'üé∑',
      'flute': 'üé∑',
      'oboe': 'üé∑',
      'sax': 'üé∑',
      'saxophone': 'üé∑',
      'sopranophone': 'üé∑',
      'tenorsaphone': 'üé∑',
      'woodwinds': 'üé∑',

      // Brass
      'brasssection': 'üé∫',
      'brass': 'üé∫',
      'cornet': 'üé∫',
      'flugelhorn': 'üé∫',
      'frenchhorn': 'üé∫',
      'trombone': 'üé∫',
      'trumpet': 'üé∫',
      'tuba': 'üé∫',

      // FX and routing
      'fx': '‚ú®',
      'effect': '‚ú®',
      'return': '‚Ü©Ô∏è',
      'aux': 'üîä',
      'main': 'üîä',

      // Default
      'default': 'üéöÔ∏è'
    };

    function getIconForId(iconId, channelType, channelNum) {
      if (!iconId) return '';
      const id = iconId.toLowerCase().replace(/[_\s-\/]/g, '');  // Remove separators including slashes

      // Check for specific matches first (order matters - more specific before generic!)
      const orderedKeys = [
        // Specific drum parts first
        'drumpad', 'drumset', 'snarebottom', 'snaretop', 'racktom', 'floortom', 'midtom',
        'hightom', 'kickin', 'kickout', 'ohleft', 'ohright', 'hihat',
        // Then generic drums
        'kick', 'snare', 'drums', 'oh',
        // Specific guitars
        'electricguitar', 'electric2', 'acousticguitar', 'acoustic2', 'uprightbass',
        // Then generic guitars
        'electric', 'acoustic', 'bass', 'guitar', 'dobro', 'banjo', 'mandolin',
        'pedalsteel', 'shamisen', 'sitar', 'ukulele',
        // Keyboards - specific first
        'pipeorgan', 'keyboardstier', 'vibraphone', 'harpsichord',
        // Then generic keyboards
        'piano', 'organ', 'keys', 'keyboard', 'synth', 'accordion', 'clavinet',
        // Other (important for your channels)
        'metronome', 'computer', 'headphones', 'headphone', 'headset', 'microphone',
        'broadcaster', 'djbox', 'externalfx', 'firewire', 'fohmain', 'handclap',
        'sidefillmonitor', 'wedgemonitor', 'wirelessmic', 'cryroom', 'delayfill',
        'iem', 'ipad', 'ipod', 'mix', 'phone', 'rock', 'smiley', 'ssd', 'tablet',
        'talkback', 'telephone', 'thumbup', 'turntable', 'video',
        // Percussion - specific first
        'orchestrdrum', 'miscperc', 'steeldrum', 'bassclarinet', 'altosaxophone',
        'tenorsaphone', 'sopranophone', 'brasssection', 'stringsection', 'backupvocals',
        'leadvocals', 'choirsingle', 'crowdambient', 'vocalcue', 'vocalmic',
        // Then generic percussion
        'bell', 'bongo', 'chimes', 'congas', 'cowbell', 'cymbal', 'cymbals', 'handpan',
        'kalimba', 'shakers', 'tambourine', 'timbales', 'timpani', 'triangle',
        'washboard', 'woodblock', 'xylophone', 'percussion',
        // Strings
        'cello', 'fiddle', 'harp', 'viola', 'violin', 'strings',
        // Vocals
        'choir', 'speech', 'vocals', 'vocal', 'mic',
        // Woodwinds
        'bassoon', 'baritone', 'clarinet', 'flute', 'oboe', 'saxophone', 'sax', 'woodwinds',
        // Brass
        'frenchhorn', 'flugelhorn', 'cornet', 'trombone', 'trumpet', 'tuba', 'brass',
        // FX and routing
        'fx', 'effect', 'return', 'aux', 'main'
      ];

      for (const key of orderedKeys) {
        if (id.includes(key)) {
          return ICON_MAP[key];
        }
      }

      return ICON_MAP.default;
    }

    // Sidebar toggle
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('open');
    }

    // Open specific connection panel
    function openConnectionPanel(type) {
      if (type === 'midi') {
        showMidiSelect();
      } else if (type === 'mixer') {
        showDiscovery();
      }
    }

    // Flash activity indicator (supports multiple IDs)
    function flashActivity(baseId) {
      // Flash both header and status bar indicators
      const ids = [baseId, `status-${baseId}`];
      ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.classList.add('active');
          setTimeout(() => el.classList.remove('active'), 150);
        }
      });
    }

    // Add change source indicator to fader
    let changeIndicatorTimeouts = new Map();
    function indicateFaderChange(channelType, channelNum, source) {
      const faderId = `${channelType}-${channelNum}`;
      const faderChannel = document.querySelector(`[data-fader-id="${faderId}"]`)?.closest('.fader-channel');

      if (faderChannel) {
        // Clear existing timeout
        const key = faderId;
        if (changeIndicatorTimeouts.has(key)) {
          clearTimeout(changeIndicatorTimeouts.get(key));
        }

        // Remove all change classes
        faderChannel.classList.remove('change-midi', 'change-api', 'change-ui');

        // Add appropriate class
        if (source === 'midi') {
          faderChannel.classList.add('change-midi');
        } else if (source === 'api') {
          faderChannel.classList.add('change-api');
        } else if (source === 'ui') {
          faderChannel.classList.add('change-ui');
        }

        // Remove after 300ms
        const timeout = setTimeout(() => {
          faderChannel.classList.remove('change-midi', 'change-api', 'change-ui');
          changeIndicatorTimeouts.delete(key);
        }, 300);

        changeIndicatorTimeouts.set(key, timeout);
      }
    }

    // MIDI Log functionality
    const midiLogEntries = [];
    const MAX_MIDI_LOG_ENTRIES = 100;

    function toggleMidiLog() {
      const logWindow = document.getElementById('midi-log-window');
      logWindow.classList.toggle('show');
    }

    function clearMidiLog() {
      midiLogEntries.length = 0;
      const logContent = document.getElementById('midi-log-content');
      logContent.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No MIDI events yet...</div>';
    }

    function addMidiLogEntry(midiMessage) {
      const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });

      let type = 'unknown';
      let details = '';

      if (midiMessage.type === 'cc') {
        type = 'cc';
        details = `CC${midiMessage.controller} Ch${midiMessage.channel} = ${midiMessage.value}`;
      } else if (midiMessage.type === 'note_on') {
        type = 'note';
        const noteName = getNoteNameFromNumber(midiMessage.note);
        details = `Note ON ${noteName} (${midiMessage.note}) Ch${midiMessage.channel} Vel=${midiMessage.value}`;
      } else if (midiMessage.type === 'note_off') {
        type = 'note';
        const noteName = getNoteNameFromNumber(midiMessage.note);
        details = `Note OFF ${noteName} (${midiMessage.note}) Ch${midiMessage.channel}`;
      } else if (midiMessage.type === 'pitch_bend') {
        type = 'cc';
        details = `Pitch Bend Ch${midiMessage.channel} = ${midiMessage.value}`;
      }

      const entry = { timestamp, type, details };
      midiLogEntries.push(entry);

      // Keep only last MAX_MIDI_LOG_ENTRIES
      if (midiLogEntries.length > MAX_MIDI_LOG_ENTRIES) {
        midiLogEntries.shift();
      }

      // Update UI
      const logContent = document.getElementById('midi-log-content');
      const entryDiv = document.createElement('div');
      entryDiv.className = `midi-log-entry ${type}`;
      entryDiv.innerHTML = `<span class="midi-log-timestamp">${timestamp}</span><span class="midi-log-type">${type.toUpperCase()}</span><span class="midi-log-details">${details}</span>`;

      logContent.appendChild(entryDiv);

      // Remove placeholder if exists
      const placeholder = logContent.querySelector('div[style*="color: #666"]');
      if (placeholder) {
        placeholder.remove();
      }

      // Auto-scroll to bottom
      logContent.scrollTop = logContent.scrollHeight;

      // Keep only last MAX_MIDI_LOG_ENTRIES in DOM
      while (logContent.children.length > MAX_MIDI_LOG_ENTRIES) {
        logContent.removeChild(logContent.firstChild);
      }
    }

    function getNoteNameFromNumber(noteNumber) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const octave = Math.floor(noteNumber / 12) - 1;
      const noteName = noteNames[noteNumber % 12];
      return `${noteName}${octave}`;
    }

    // Helper function to get CC shorthand name
    function getCCShorthand(ccNumber) {
      const CC_SHORTHAND = {
        1: 'Mod',
        2: 'Breath',
        7: 'Vol',
        10: 'Pan',
        11: 'Expr',
        64: 'Sus',
        71: 'Res',
        74: 'Bright',
        91: 'Rev',
        93: 'Chor',
        102: 'Vol2',
        103: 'Pan2',
        104: 'Expr2'
      };
      return CC_SHORTHAND[ccNumber] || `CC${ccNumber}`;
    }

    // Listen for preset loaded event (from default preset on startup)
    ipcRenderer.on('preset-loaded', async (event, data) => {
      if (data.name) {
        updateStatusProfile(data.name);
        updateStatusLastSaved(new Date().toLocaleTimeString());

        // Load fader filter state from preset
        const filter = await ipcRenderer.invoke('get-fader-filter');
        if (filter) {
          faderFilter = filter;
          const filterSelect = document.getElementById('filter-select');
          if (filterSelect) {
            filterSelect.value = faderFilter;
          }
        }
      }
    });

    // Listen for MIDI activity
    ipcRenderer.on('midi-activity', async (event, midiMessage) => {
      flashActivity('midi-activity');
      addMidiLogEntry(midiMessage);

      // MIDI learn: intercept and auto-fill form fields
      if (midiLearnActive && (midiMessage.type === 'cc' || midiMessage.type === 'note_on')) {
        applyMidiLearnResult(midiMessage, midiMessage.device);
        return;
      }

      // Update MIDI indicator for CC messages
      if (midiMessage.type === 'cc') {
        // Find the mapping for this MIDI message to get the channel
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mapping = mappings.find(m =>
          m.midi.type === 'cc' &&
          m.midi.channel === midiMessage.channel &&
          m.midi.controller === midiMessage.controller
        );
        if (mapping) {
          const channelType = mapping.mixer.channel.type || 'LINE';
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          updateMidiIndicator(channelType, channelNum, midiMessage.value);
          indicateFaderChange(channelType, channelNum, 'midi');
        }
      }
    });

    // Listen for mixer activity
    ipcRenderer.on('mixer-activity', (event, mixerCommand) => {
      flashActivity('mixer-activity');

      // Update fader if it's a volume command
      if (mixerCommand.action === 'volume' && mixerCommand.value !== undefined && mixerCommand.channel) {
        const channelType = mixerCommand.channel.type || 'LINE';
        const channelNum = mixerCommand.channel.channel;
        updateFaderByValue(channelType, channelNum, mixerCommand.value);
        indicateFaderChange(channelType, channelNum, 'midi');
      }
    });

    // Listen for mixer level changes (from physical mixer or Universal Control)
    ipcRenderer.on('mixer-level', (event, data) => {
      flashActivity('mixer-activity');
      // data.channel.type, data.channel.channel, data.level
      // Update fader for any channel type (LINE, MAIN, AUX, etc.)
      if (data.channel) {
        updateFaderByValue(data.channel.type, data.channel.channel, data.level);
        indicateFaderChange(data.channel.type, data.channel.channel, 'api');

        // Update MIDI indicator to match fader position when quiescent
        updateMidiIndicatorToFader(data.channel.type, data.channel.channel, data.level);
      }
    });

    // Listen for mixer state ready event (when channel names are available)
    let mixerStateReadyHandled = false;
    let mixerStateReadyTimestamp = 0;
    ipcRenderer.on('mixer-state-ready', async () => {
      const now = Date.now();
      console.log('[Renderer] mixer-state-ready event received, mixerStateReadyHandled:', mixerStateReadyHandled, 'isLoadingFaders:', isLoadingFaders, 'time since last:', now - mixerStateReadyTimestamp);

      // Prevent duplicate handling if event fires multiple times within 15 seconds
      if (mixerStateReadyHandled && (now - mixerStateReadyTimestamp) < 15000) {
        console.log('[Renderer] mixer-state-ready: Already handled recently, skipping duplicate');
        return;
      }
      mixerStateReadyHandled = true;
      mixerStateReadyTimestamp = now;

      console.log('[Renderer] mixer-state-ready: Processing event...');

      // Get mixer info now that state is ready
      const mixerStatus = await ipcRenderer.invoke('get-mixer-status');
      console.log('[Renderer] Mixer status:', mixerStatus);

      // Prefer deviceName, then model, then name
      // Don't show both if they're the same
      const deviceName = mixerStatus.deviceName || '';
      const model = mixerStatus.model || '';
      const name = mixerStatus.name || '';

      let displayText = 'Unknown';
      if (deviceName && model && deviceName !== model) {
        displayText = `${deviceName} (${model})`;
      } else if (deviceName) {
        displayText = deviceName;
      } else if (model) {
        displayText = model;
      } else if (name) {
        displayText = name;
      }

      await updateStatusInitWithDelay(`Connected to ${displayText}`);
      await updateStatusInitWithDelay('Mixer connected - loading channels...');

      // Load mappings first (populates currentMappings global variable)
      await loadMappings();

      // Then load faders (which will call loadMuteGroups at the end)
      loadFaders().then(() => {
        // loadFaders will set status to 'Ready' when complete
        // Don't reset mixerStateReadyHandled here - keep it true to prevent duplicates
        console.log('[Renderer] loadFaders completed successfully');
      }).catch(err => {
        console.error('[Renderer] Error in mixer-state-ready handler:', err);
        const errorMsg = `Error: ${err.message || 'Failed to load channels'}`;
        updateStatusInit(errorMsg);
        addStatusLog(errorMsg, 'error');
        // Don't reset on error either - the duplicate is not helpful
      });
    });

    // Listen for connection events (initial connect or reconnect)
    ipcRenderer.on('connection-restored', (event, data) => {
      if (data.type === 'midi') {
        addStatusLog(`MIDI connected: ${data.device}`, 'success');
      } else if (data.type === 'mixer') {
        addStatusLog(`Mixer connected: ${data.ip}`, 'success');
      }
      updateStatus();
    });

    // Listen for mixer mute changes (from physical mixer or Universal Control)
    ipcRenderer.on('mixer-mute', (event, data) => {
      // data.channel.type, data.channel.channel, data.status
      if (data.channel) {
        updateMuteButton(data.channel.type, data.channel.channel, data.status);
      }
    });

    // Listen for mixer solo changes (from physical mixer or Universal Control)
    ipcRenderer.on('mixer-solo', (event, data) => {
      // data.channel.type, data.channel.channel, data.status
      if (data.channel) {
        updateSoloButton(data.channel.type, data.channel.channel, data.status);
      }
    });

    // Listen for mixer property changes (main assignment, input source, etc.)
    ipcRenderer.on('mixer-property-change', async (event, data) => {
      // Log all property changes to see what we're getting
      console.log('[Renderer] mixer-property-change:', data);

      // data.channel.type, data.channel.channel, data.value, data.type
      if (data.channel && data.type) {
        const channelType = data.channel.type;
        const channelNum = data.channel.channel;

        if (data.type === 'lr') {
          // Main assignment changed
          updateMainAssignIndicator(channelType, channelNum, data.value);
        } else if (data.type === 'inputsrc') {
          // Input source changed
          updateInputSourceIndicator(channelType, channelNum, data.value);
        } else if (data.type === 'icon') {
          // Channel icon changed
          updateChannelIcon(channelType, channelNum, data.value);
        } else if (data.type === 'name') {
          // Channel name changed
          updateChannelName(channelType, channelNum, data.value);
        } else if (data.type === 'link') {
          // Channel link status changed - need to reload faders
          loadFaders();
        } else if (data.type === 'mute') {
          // Channel mute state changed
          updateMuteButton(channelType, channelNum, data.value);
        }
      }

      // Check if this is a mute group state change
      // The path might be something like "mutegroup/mutegroup1"
      if (data.path && data.path.includes('mutegroup/mutegroup')) {
        const match = data.path.match(/mutegroup\/mutegroup(\d+)$/);
        if (match) {
          const groupNum = parseInt(match[1], 10);
          const muteGroupActive = data.value > 0;
          console.log(`[Renderer] Mute group ${groupNum} state changed to: ${muteGroupActive ? 'ACTIVE' : 'INACTIVE'}`);

          // Update the mute group button state
          const button = document.getElementById(`mute-group-${groupNum}`);
          if (button) {
            if (muteGroupActive) {
              button.classList.add('active');
            } else {
              button.classList.remove('active');
            }
          }

          // Update the mute button states for all channels in this mute group
          // NOTE: The mixer doesn't change individual channel mute states when a mute group is activated.
          // The mute group acts as a "master mute" that overrides individual states.
          // So we set the visual state based on the mute group state, not the individual channel states.
          const assignments = await ipcRenderer.invoke('get-mute-group-assignments', groupNum);
          console.log(`[Renderer] Mute group ${groupNum} has ${assignments.length} assigned channels`);

          for (const assignment of assignments) {
            // If mute group is active, show channels as muted
            // If mute group is inactive, query the actual channel mute state
            if (muteGroupActive) {
              console.log(`[Renderer] Setting ${assignment.type}${assignment.channel} to MUTED (mute group active)`);
              updateMuteButton(assignment.type, assignment.channel, true);
            } else {
              // Query the actual channel mute state
              const muted = await ipcRenderer.invoke('get-channel-mute', assignment.type, assignment.channel);
              console.log(`[Renderer] Setting ${assignment.type}${assignment.channel} to ${muted} (mute group inactive, actual state)`);
              if (muted !== null) {
                updateMuteButton(assignment.type, assignment.channel, muted);
              }
            }
          }
        }
      }
    });

    // Update fader visual (value is 0-1)
    function updateFader(channel, value) {
      const faderFill = document.getElementById(`fader-fill-${channel}`);
      const faderValue = document.getElementById(`fader-value-${channel}`);
      if (faderFill && faderValue) {
        const percentage = Math.round(value * 100);
        faderFill.style.height = `${percentage}%`;
        faderValue.textContent = `${percentage}%`;
      }
    }

    // Update fader visual by percentage value (value is 0-100)
    // channelType and channelNum are used to create unique fader ID
    function updateFaderByValue(channelType, channelNum, percentage) {
      const faderId = `${channelType}-${channelNum}`;
      const faderFill = document.getElementById(`fader-fill-${faderId}`);
      const faderValue = document.getElementById(`fader-value-${faderId}`);

      if (faderFill) {
        const roundedPercentage = Math.round(percentage);

        // Calculate delta for smoothing
        const currentHeight = parseFloat(faderFill.style.height) || 0;
        const delta = Math.abs(roundedPercentage - currentHeight);

        // Only update if there's a meaningful change (reduces jitter)
        if (delta < 0.5) return;

        // Use consistent transition speed for smoother motion
        // Longer transitions for larger movements
        const transitionSpeed = delta > 10 ? faderSmoothingSpeed : Math.min(delta * 30, faderSmoothingSpeed);

        // Apply smooth transition with ease-out for more natural motion
        faderFill.style.transition = `height ${transitionSpeed}ms ease-out`;
        faderFill.style.height = `${roundedPercentage}%`;
        // faderValue may not exist for the right side of stereo pairs
        if (faderValue) {
          faderValue.textContent = `${roundedPercentage}%`;
        }
      }
    }

    // Store timeout IDs for hiding MIDI indicators
    const midiIndicatorTimeouts = new Map();

    // Update MIDI indicator position based on MIDI value (0-127)
    function updateMidiIndicator(channelType, channelNum, midiValue) {
      const faderId = `${channelType}-${channelNum}`;
      const midiIndicator = document.getElementById(`fader-midi-${faderId}`);
      if (midiIndicator) {
        // Convert MIDI value (0-127) to percentage (0-100)
        // This matches the mapping engine's conversion: value / 127 * 100
        const percentage = (midiValue / 127) * 100;
        midiIndicator.style.bottom = `${percentage}%`;
        midiIndicator.style.display = 'block';

        // Clear existing timeout
        if (midiIndicatorTimeouts.has(faderId)) {
          clearTimeout(midiIndicatorTimeouts.get(faderId));
        }

        // Hide indicator after 2 seconds of no MIDI activity
        const timeout = setTimeout(() => {
          midiIndicator.style.display = 'none';
          midiIndicatorTimeouts.delete(faderId);
        }, 2000);
        midiIndicatorTimeouts.set(faderId, timeout);
      }
    }

    // Update MIDI indicator to match fader position (when quiescent)
    function updateMidiIndicatorToFader(channelType, channelNum, percentage) {
      const faderId = `${channelType}-${channelNum}`;
      const midiIndicator = document.getElementById(`fader-midi-${faderId}`);

      // Only update if there's no active MIDI timeout (not currently showing MIDI activity)
      if (midiIndicator && !midiIndicatorTimeouts.has(faderId)) {
        midiIndicator.style.bottom = `${percentage}%`;
        // Keep it hidden - it will show when MIDI activity occurs
        midiIndicator.style.display = 'none';
      }
    }

    // Tab switching
    function showTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');

      // Update tab content
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById(`${tabName}-view`).classList.add('active');
    }

    // Modal functions
    async function showDiscovery() {
      document.getElementById('discovery-modal').classList.add('show');

      // Pre-fill manual IP field with current mixer IP if connected
      try {
        const mixerStatus = await ipcRenderer.invoke('get-mixer-status');
        const manualIpInput = document.getElementById('manual-ip');
        if (manualIpInput && mixerStatus.ip) {
          manualIpInput.value = mixerStatus.ip;
        }
      } catch (error) {
        console.error('Error getting mixer status:', error);
      }
    }

    function hideDiscovery() {
      document.getElementById('discovery-modal').classList.remove('show');
    }

    function updateMidiTypeFields() {
      const midiType = document.getElementById('midi-type').value;
      const mixerAction = document.getElementById('mixer-action').value;
      const ccGroup = document.getElementById('cc-group');
      const ccThresholdGroup = document.getElementById('cc-threshold-group');
      const noteGroup = document.getElementById('note-group');
      const noteInvertGroup = document.getElementById('note-invert-group');
      const noteValueGroup = document.getElementById('note-value-group');

      // Determine if this is a boolean control (mute/solo/mutegroup)
      const isBooleanControl = mixerAction === 'mute' || mixerAction === 'solo' || mixerAction === 'mutegroup';

      if (midiType === 'none') {
        ccGroup.style.display = 'none';
        ccThresholdGroup.style.display = 'none';
        noteGroup.style.display = 'none';
        noteInvertGroup.style.display = 'none';
        noteValueGroup.style.display = 'none';
      } else if (midiType === 'cc') {
        ccGroup.style.display = 'block';
        ccThresholdGroup.style.display = isBooleanControl ? 'block' : 'none';
        noteGroup.style.display = 'none';
        noteInvertGroup.style.display = 'none';
        noteValueGroup.style.display = 'none';
      } else if (midiType === 'note') {
        ccGroup.style.display = 'none';
        ccThresholdGroup.style.display = 'none';
        noteGroup.style.display = 'block';
        noteInvertGroup.style.display = isBooleanControl ? 'block' : 'none';
        noteValueGroup.style.display = 'none';
        updateNoteDisplay();
      } else if (midiType === 'note-value') {
        ccGroup.style.display = 'none';
        ccThresholdGroup.style.display = 'none';
        noteGroup.style.display = 'none';
        noteInvertGroup.style.display = 'none';
        noteValueGroup.style.display = 'block';
        updateNoteMinDisplay();
        updateNoteMaxDisplay();
      }
    }

    function updateNoteDisplay() {
      const noteNum = parseInt(document.getElementById('midi-note').value) || 60;
      const noteName = getNoteNameFromNumber(noteNum);
      document.getElementById('note-display').textContent = `${noteName} (${noteNum})`;
    }

    function updateNoteMinDisplay() {
      const noteNum = parseInt(document.getElementById('midi-note-min').value) || 24;
      const noteName = getNoteNameFromNumber(noteNum);
      document.getElementById('note-min-display').textContent = `${noteName} (${noteNum})`;
    }

    function updateNoteMaxDisplay() {
      const noteNum = parseInt(document.getElementById('midi-note-max').value) || 60;
      const noteName = getNoteNameFromNumber(noteNum);
      document.getElementById('note-max-display').textContent = `${noteName} (${noteNum})`;
    }

    function showAddMapping() {
      const modal = document.getElementById('add-mapping-modal');
      const modalTitle = modal.querySelector('h2');

      // Reset modal to "add" mode
      modalTitle.textContent = '‚ûï Create Mapping';
      delete modal.dataset.editingIndex;

      // Reset form to defaults
      document.getElementById('midi-type').value = 'cc';
      // Don't set midi-channel here - let updateMidiSettingsForChannel() set it based on mixer channel
      document.getElementById('midi-cc').value = '7'; // Default to CC7 (Volume)
      document.getElementById('midi-cc-threshold').value = '64'; // Default threshold
      document.getElementById('midi-note').value = '60';
      document.getElementById('midi-note-invert').checked = false; // Default not inverted
      document.getElementById('midi-note-min').value = '24';
      document.getElementById('midi-note-max').value = '60';
      document.getElementById('mixer-action').value = 'volume';
      document.getElementById('mixer-channel-type').value = 'LINE';
      updateMidiTypeFields();

      // Reset device filter and populate with connected devices
      document.getElementById('midi-device-filter').value = '';
      populateMidiDeviceFilter();

      modal.classList.add('show');
      updateChannelNumberOptions(); // Populate channel numbers and auto-set MIDI settings (including MIDI channel)
    }

    async function populateMidiDeviceFilter(selectedDevice) {
      const select = document.getElementById('midi-device-filter');
      const devices = await ipcRenderer.invoke('get-connected-midi-devices');
      // Rebuild options, keep "Any" as first
      select.innerHTML = '<option value="">Any connected device</option>';
      for (const dev of devices) {
        const opt = document.createElement('option');
        opt.value = dev;
        opt.textContent = dev;
        if (dev === selectedDevice) opt.selected = true;
        select.appendChild(opt);
      }
    }

    function hideAddMapping() {
      const modal = document.getElementById('add-mapping-modal');
      modal.classList.remove('show');

      // Cancel MIDI learn if active
      if (midiLearnActive) {
        midiLearnActive = false;
        ipcRenderer.invoke('stop-midi-scan');
        const btn = document.getElementById('midi-listen-btn');
        const status = document.getElementById('midi-listen-status');
        if (btn) { btn.textContent = 'Learn'; btn.classList.remove('listening'); }
        if (status) { status.textContent = ''; }
      }

      // Reset modal title and editing flag
      const modalTitle = modal.querySelector('h2');
      modalTitle.textContent = '‚ûï Create Mapping';
      delete modal.dataset.editingIndex;

      // If we came from the mappings list and user cancelled, return to it
      if (returnToMappingsList) {
        returnToMappingsList = false;
        setTimeout(() => showMappingsList(), 100);
      }
    }

    function toggleMidiListen() {
      const btn = document.getElementById('midi-listen-btn');
      const status = document.getElementById('midi-listen-status');
      if (midiLearnActive) {
        midiLearnActive = false;
        btn.textContent = 'Learn';
        btn.classList.remove('listening');
        status.textContent = '';
        ipcRenderer.invoke('stop-midi-scan');
      } else {
        midiLearnActive = true;
        btn.textContent = 'Cancel';
        btn.classList.add('listening');
        status.textContent = 'Listening on all MIDI ports... move a fader or press a pad';
        status.style.color = '#ff9800';
        ipcRenderer.invoke('start-midi-scan');
      }
    }

    // Handle MIDI scan result (fires from any port, not just the connected one)
    ipcRenderer.on('midi-scan-captured', (event, { deviceName, message }) => {
      if (!midiLearnActive) return;
      applyMidiLearnResult(message, deviceName);
    });

    async function applyMidiLearnResult(msg, deviceName) {
      const btn = document.getElementById('midi-listen-btn');
      const status = document.getElementById('midi-listen-status');

      midiLearnActive = false;
      btn.textContent = 'Learn';
      btn.classList.remove('listening');
      ipcRenderer.invoke('stop-midi-scan');

      // Auto-connect to the detected device if it isn't already connected
      if (deviceName) {
        const connectedDevices = await ipcRenderer.invoke('get-connected-midi-devices');
        if (!connectedDevices.includes(deviceName)) {
          await ipcRenderer.invoke('connect-midi-device', deviceName);
          updateStatus();
        }
      }

      const devLabel = deviceName ? ` [${deviceName}]` : '';

      if (msg.type === 'cc') {
        document.getElementById('midi-type').value = 'cc';
        document.getElementById('midi-channel').value = msg.channel;
        document.getElementById('midi-cc').value = msg.controller;
        updateMidiTypeFields();
        status.textContent = `Detected: CC${msg.controller} Ch${msg.channel}${devLabel}`;
        status.style.color = '#4a9b7f';
        if (deviceName) populateMidiDeviceFilter(deviceName);
      } else if (msg.type === 'note_on') {
        document.getElementById('midi-type').value = 'note';
        document.getElementById('midi-channel').value = msg.channel;
        document.getElementById('midi-note').value = msg.note;
        updateMidiTypeFields();
        updateNoteDisplay();
        status.textContent = `Detected: Note ${msg.note} (${getNoteNameFromNumber(msg.note)}) Ch${msg.channel}${devLabel}`;
        status.style.color = '#4a9b7f';
        if (deviceName) populateMidiDeviceFilter(deviceName);
      } else if (msg.type === 'pitch_bend') {
        // Pitch bend not mappable ‚Äî re-enable learn so user can try a CC control
        status.textContent = `Detected: Pitch Bend Ch${msg.channel}${devLabel} ‚Äî use a CC fader instead`;
        status.style.color = '#ff9800';
        midiLearnActive = true;
        btn.textContent = 'Cancel';
        btn.classList.add('listening');
        ipcRenderer.invoke('start-midi-scan');
      }
    }

    // Update channel number dropdown based on selected channel type
    // Helper function to get default CC based on channel number
    function getDefaultCC(channelNum) {
      // Channels 1-16: CC7 (Volume)
      // Channels 17-32: CC102 (Volume Alt)
      // Channels 33-48: CC103 (Pan Alt)
      // Channels 49+: CC104 (Expression Alt)
      if (channelNum <= 16) return 7;
      if (channelNum <= 32) return 102;
      if (channelNum <= 48) return 103;
      return 104;
    }

    async function updateChannelNumberOptions() {
      const channelType = document.getElementById('mixer-channel-type').value;
      const channelNumSelect = document.getElementById('mixer-channel-num');

      // Define max channels for each type (these are typical values)
      const maxChannels = {
        'LINE': 32, // Support up to 32 channels
        'RETURN': 4,
        'FXRETURN': 4,
        'TALKBACK': 1,
        'AUX': 16,
        'FX': 4,
        'SUB': 8,
        'MAIN': 1,
        'DCA': 8
      };

      const max = maxChannels[channelType] || 16;

      // Get channel names from mixer if connected
      try {
        const channelNames = await ipcRenderer.invoke('get-channel-names', channelType.toLowerCase(), max);

        channelNumSelect.innerHTML = '';
        for (let i = 1; i <= max; i++) {
          const option = document.createElement('option');
          option.value = i;
          const channelInfo = channelNames.find(c => c.channel === i);
          const channelName = channelInfo ? channelInfo.name : `Ch ${i}`;
          option.textContent = `${i}: ${channelName}`;
          channelNumSelect.appendChild(option);
        }

        // Auto-update MIDI settings when channel is selected
        updateMidiSettingsForChannel();
      } catch (error) {
        // Fallback if mixer not connected
        channelNumSelect.innerHTML = '';
        for (let i = 1; i <= max; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = `Channel ${i}`;
          channelNumSelect.appendChild(option);
        }

        // Auto-update MIDI settings when channel is selected
        updateMidiSettingsForChannel();
      }
    }

    // Update MIDI settings based on selected mixer channel
    function updateMidiSettingsForChannel() {
      // Don't auto-update when editing an existing mapping
      if (isEditingMapping) return;

      const channelNum = parseInt(document.getElementById('mixer-channel-num').value);
      const midiChannelInput = document.getElementById('midi-channel');
      const midiCCSelect = document.getElementById('midi-cc');

      // Set MIDI channel to match mixer channel (wrapping at 16)
      const midiChannel = ((channelNum - 1) % 16) + 1;
      midiChannelInput.value = midiChannel;

      // Set default CC based on channel number
      const defaultCC = getDefaultCC(channelNum);
      midiCCSelect.value = defaultCC;
    }

    async function showSavePreset() {
      try {
        // Get current preset path if any
        const currentPath = await ipcRenderer.invoke('get-current-preset-path');

        const result = await ipcRenderer.invoke('save-preset-dialog', currentPath);
        if (result.success) {
          // Update status bar
          const statusProfile = document.getElementById('status-profile');
          const statusLastSaved = document.getElementById('status-last-saved');
          if (statusProfile) statusProfile.textContent = result.name || 'Saved';
          if (statusLastSaved) statusLastSaved.textContent = new Date().toLocaleTimeString();

          markConfigSaved();
        }
      } catch (error) {
        alert(`‚úó Error saving preset: ${error.message}`);
      }
    }

    function hideSavePreset() {
      document.getElementById('save-preset-modal').classList.remove('show');
    }

    async function showLoadPreset() {
      try {
        const result = await ipcRenderer.invoke('load-preset-dialog');
        if (result.success) {
          // Load fader filter state from preset
          const filter = await ipcRenderer.invoke('get-fader-filter');
          if (filter) {
            faderFilter = filter;
            const filterSelect = document.getElementById('filter-select');
            if (filterSelect) {
              filterSelect.value = faderFilter;
            }
          }

          // Reload mappings and faders
          await loadMappings();
          await loadFaders();

          // Update status bar
          const statusProfile = document.getElementById('status-profile');
          const statusLastSaved = document.getElementById('status-last-saved');
          if (statusProfile) statusProfile.textContent = result.name || 'Loaded';
          if (statusLastSaved) statusLastSaved.textContent = new Date().toLocaleTimeString();

          markConfigSaved();
        }
      } catch (error) {
        alert(`‚úó Error loading preset: ${error.message}`);
      }
    }

    function showMidiSelect() {
      document.getElementById('midi-select-modal').classList.add('show');
      loadMidiDevices();
    }

    function hideMidiSelect() {
      document.getElementById('midi-select-modal').classList.remove('show');
    }

    // Preferences functions
    let faderSmoothingSpeed = 300; // Default smoothing speed in ms
    let midiFeedbackEnabled = true; // Default: enabled

    function showPreferences() {
      const modal = document.getElementById('preferences-modal');
      const smoothingInput = document.getElementById('fader-smoothing');
      const midiFeedbackCheckbox = document.getElementById('midi-feedback-enabled');

      // Load current preferences
      const savedSmoothing = localStorage.getItem('faderSmoothingSpeed');
      if (savedSmoothing) {
        faderSmoothingSpeed = parseInt(savedSmoothing);
        smoothingInput.value = faderSmoothingSpeed;
        updateSmoothingDisplay();
      }

      const savedMidiFeedback = localStorage.getItem('midiFeedbackEnabled');
      if (savedMidiFeedback !== null) {
        midiFeedbackEnabled = savedMidiFeedback === 'true';
      }
      midiFeedbackCheckbox.checked = midiFeedbackEnabled;

      modal.classList.add('show');
    }

    function hidePreferences() {
      document.getElementById('preferences-modal').classList.remove('show');
    }

    async function showMappingsList() {
      const modal = document.getElementById('mappings-list-modal');
      const listView = document.getElementById('mappings-list-view');

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        if (mappings.length === 0) {
          listView.innerHTML = '<div class="empty-state">No mappings configured yet.</div>';
          currentMappingsList = [];
        } else {
          // Group mappings by trigger type first, then MIDI channel
          const sortedMappings = [...mappings].sort((a, b) => {
            // Sort by type first (cc before note types)
            const aIsCC = a.midi.type === 'cc';
            const bIsCC = b.midi.type === 'cc';
            if (aIsCC !== bIsCC) {
              return aIsCC ? -1 : 1;
            }
            // Then by MIDI channel
            if (a.midi.channel !== b.midi.channel) {
              return a.midi.channel - b.midi.channel;
            }
            // Then by controller/note number
            const aNum = a.midi.controller || a.midi.note || a.midi.noteMin || 0;
            const bNum = b.midi.controller || b.midi.note || b.midi.noteMin || 0;
            return aNum - bNum;
          });

          listView.innerHTML = `
            <table style="width: 100%; border-collapse: collapse;">
              <thead>
                <tr style="border-bottom: 2px solid rgba(255,255,255,0.2); text-align: left;">
                  <th style="padding: 8px;">MIDI Input</th>
                  <th style="padding: 8px;">MIDI Trigger</th>
                  <th style="padding: 8px;">Mixer Function</th>
                  <th style="padding: 8px;">Mixer Channel</th>
                  <th style="padding: 8px; text-align: center;">Actions</th>
                </tr>
              </thead>
              <tbody>
                ${sortedMappings.map((m, index) => {
                  // MIDI Input - Channel and device (show device when mapping has a filter)
                  const midiInput = m.midi.device
                    ? `Ch ${m.midi.channel} [${shortenMidiDeviceName(m.midi.device)}]`
                    : `Ch ${m.midi.channel}`;

                  // MIDI Trigger - What triggers it and value ranges
                  let midiTrigger = '';
                  const isBooleanControl = m.mixer.action === 'mute' || m.mixer.action === 'solo' || m.mixer.action === 'mutegroup';

                  if (m.midi.type === 'cc') {
                    if (isBooleanControl && m.midi.threshold !== undefined) {
                      midiTrigger = `CC${m.midi.controller} (‚â•${m.midi.threshold} = ON)`;
                    } else {
                      midiTrigger = `CC${m.midi.controller} (0-127)`;
                    }
                  } else if (m.midi.type === 'note-value') {
                    midiTrigger = `Note ${m.midi.noteMin}-${m.midi.noteMax}`;
                  } else if (m.midi.type === 'note-on') {
                    const invertText = m.midi.invert ? ' (inverted)' : '';
                    midiTrigger = `Note ${m.midi.note} ON ‚Üí Activate${invertText}`;
                  } else if (m.midi.type === 'note-off') {
                    const invertText = m.midi.invert ? ' (inverted)' : '';
                    midiTrigger = `Note ${m.midi.note} OFF ‚Üí Deactivate${invertText}`;
                  } else if (m.midi.type === 'note-toggle') {
                    const invertText = m.midi.invert ? ' (inverted)' : '';
                    midiTrigger = `Note ${m.midi.note} ‚Üí Toggle${invertText}`;
                  } else if (m.midi.type === 'note') {
                    const invertText = m.midi.invert ? ' (inverted)' : '';
                    midiTrigger = `Note ${m.midi.note}${invertText}`;
                  }

                  // Mixer Function - More descriptive
                  let mixerFunction = '';
                  if (m.mixer.action === 'volume') {
                    mixerFunction = 'üéöÔ∏è Volume Control';
                  } else if (m.mixer.action === 'mute') {
                    mixerFunction = 'üîá Mute Control';
                  } else if (m.mixer.action === 'solo') {
                    mixerFunction = 'üîä Solo Control';
                  } else if (m.mixer.action === 'pan') {
                    mixerFunction = '‚ÜîÔ∏è Pan Control';
                  } else if (m.mixer.action === 'mutegroup') {
                    mixerFunction = 'üéöÔ∏è Mute Group';
                  } else {
                    mixerFunction = m.mixer.action.charAt(0).toUpperCase() + m.mixer.action.slice(1);
                  }

                  // Mixer Channel - More descriptive
                  let mixerChannel = '';
                  if (m.mixer.action === 'mutegroup') {
                    mixerChannel = `Mute Group ${m.mixer.channel.channel}`;
                  } else {
                    const channelType = m.mixer.channel.type || 'LINE';
                    const channelNum = m.mixer.channel.channel || m.mixer.channel;
                    const typeLabel = {
                      'LINE': 'Input',
                      'AUX': 'Aux',
                      'FX': 'FX',
                      'FXRETURN': 'FX Return',
                      'SUB': 'Sub',
                      'MAIN': 'Main',
                      'DCA': 'DCA'
                    }[channelType] || channelType;
                    mixerChannel = `${typeLabel} ${channelNum}`;
                  }

                  return `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                      <td style="padding: 8px; font-family: monospace;">${midiInput}</td>
                      <td style="padding: 8px; font-family: monospace;">${midiTrigger}</td>
                      <td style="padding: 8px;">${mixerFunction}</td>
                      <td style="padding: 8px;">${mixerChannel}</td>
                      <td style="padding: 8px; text-align: center;">
                        <button class="icon-btn" onclick="editMappingFromList(${index})" title="Edit Mapping" style="margin-right: 4px;">‚úèÔ∏è</button>
                        <button class="icon-btn" onclick="deleteMappingFromList(${index})" title="Delete Mapping">üóëÔ∏è</button>
                      </td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          `;

          // Store the sorted mappings for edit/delete operations
          currentMappingsList = sortedMappings;
        }

        modal.classList.add('show');
      } catch (error) {
        listView.innerHTML = `<div class="empty-state">Error loading mappings: ${error.message}</div>`;
        modal.classList.add('show');
      }
    }

    function hideMappingsList() {
      document.getElementById('mappings-list-modal').classList.remove('show');
    }

    // Store mappings for edit/delete operations
    let currentMappingsList = [];
    let returnToMappingsList = false;
    let midiLearnActive = false;

    async function editMappingFromList(index) {
      const mapping = currentMappingsList[index];
      if (!mapping) return;

      // Set flag to return to mappings list after saving
      returnToMappingsList = true;

      // Close the mappings list modal
      hideMappingsList();

      // Set flag to prevent auto-updating MIDI settings
      isEditingMapping = true;

      // Get all mappings to find the actual index
      const allMappings = await ipcRenderer.invoke('get-mappings');
      const actualIndex = allMappings.findIndex(m => {
        if (m.mixer.action === 'mutegroup' && mapping.mixer.action === 'mutegroup') {
          return m.mixer.channel.channel === mapping.mixer.channel.channel;
        } else if (m.mixer.action !== 'mutegroup' && mapping.mixer.action !== 'mutegroup') {
          return m.mixer.action === mapping.mixer.action &&
                 (m.mixer.channel.type || 'LINE') === (mapping.mixer.channel.type || 'LINE') &&
                 (m.mixer.channel.channel || m.mixer.channel) == (mapping.mixer.channel.channel || mapping.mixer.channel);
        }
        return false;
      });

      if (actualIndex === -1) {
        alert('Mapping not found');
        return;
      }

      // Populate the add-mapping modal with existing data
      const modal = document.getElementById('add-mapping-modal');

      // Set MIDI type
      document.getElementById('midi-type').value = mapping.midi.type === 'cc' ? 'cc' : 'note';
      updateMidiTypeFields();

      // Set MIDI channel
      document.getElementById('midi-channel').value = mapping.midi.channel;

      // Set MIDI controller/note values
      if (mapping.midi.type === 'cc') {
        document.getElementById('midi-cc').value = mapping.midi.controller;
        // Set threshold for boolean controls
        if (mapping.midi.threshold !== undefined) {
          document.getElementById('midi-cc-threshold').value = mapping.midi.threshold;
        } else {
          document.getElementById('midi-cc-threshold').value = 64; // Default
        }
      } else if (mapping.midi.type === 'note-value') {
        const noteTypeSelect = document.getElementById('note-type');
        if (noteTypeSelect) {
          noteTypeSelect.value = 'note-value';
          // Trigger change event to update fields
          noteTypeSelect.dispatchEvent(new Event('change'));
        }
        setTimeout(() => {
          document.getElementById('midi-note-min').value = mapping.midi.noteMin || 24;
          document.getElementById('midi-note-max').value = mapping.midi.noteMax || 60;
        }, 50);
      } else {
        // note, note-on, note-off, note-toggle
        const noteTypeSelect = document.getElementById('note-type');
        if (noteTypeSelect) {
          noteTypeSelect.value = mapping.midi.type;
          // Trigger change event to update fields
          noteTypeSelect.dispatchEvent(new Event('change'));
        }
        setTimeout(() => {
          const noteInput = document.getElementById('midi-note');
          if (noteInput) {
            noteInput.value = mapping.midi.note;
          }
          // Set invert for boolean controls
          const noteInvertCheckbox = document.getElementById('midi-note-invert');
          if (noteInvertCheckbox) {
            noteInvertCheckbox.checked = mapping.midi.invert || false;
          }
        }, 50);
      }

      // Set mixer action and channel
      document.getElementById('mixer-action').value = mapping.mixer.action;
      document.getElementById('mixer-channel-type').value = mapping.mixer.channel.type || 'LINE';

      // Update channel number options and then set the value
      await updateChannelNumberOptions();
      document.getElementById('mixer-channel-num').value = mapping.mixer.channel.channel || mapping.mixer.channel;

      // Clear the flag
      isEditingMapping = false;

      // Change modal title to indicate editing
      const modalTitle = modal.querySelector('h2');
      modalTitle.textContent = '‚úèÔ∏è Edit Mapping';

      // Store the editing index
      modal.dataset.editingIndex = actualIndex;

      // Show the modal
      modal.classList.add('show');
    }

    async function deleteMappingFromList(index) {
      const mapping = currentMappingsList[index];
      if (!mapping) return;

      // Determine the description for confirmation
      let desc = '';
      if (mapping.mixer.action === 'mutegroup') {
        desc = `Mute Group ${mapping.mixer.channel.channel}`;
      } else {
        const channelType = mapping.mixer.channel.type || 'LINE';
        const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
        const actionName = {
          'volume': 'Volume',
          'mute': 'Mute',
          'solo': 'Solo',
          'pan': 'Pan'
        }[mapping.mixer.action] || mapping.mixer.action;
        desc = `${channelType} ${channelNum} - ${actionName}`;
      }

      if (!confirm(`Delete mapping for ${desc}?`)) {
        return;
      }

      try {
        // Get all mappings to find the actual index
        const allMappings = await ipcRenderer.invoke('get-mappings');
        const actualIndex = allMappings.findIndex(m => {
          if (m.mixer.action === 'mutegroup' && mapping.mixer.action === 'mutegroup') {
            return m.mixer.channel.channel === mapping.mixer.channel.channel;
          } else if (m.mixer.action !== 'mutegroup' && mapping.mixer.action !== 'mutegroup') {
            return m.mixer.action === mapping.mixer.action &&
                   (m.mixer.channel.type || 'LINE') === (mapping.mixer.channel.type || 'LINE') &&
                   (m.mixer.channel.channel || m.mixer.channel) == (mapping.mixer.channel.channel || mapping.mixer.channel);
          }
          return false;
        });

        if (actualIndex === -1) {
          alert('Mapping not found');
          return;
        }

        // Actually remove the mapping entry
        await ipcRenderer.invoke('remove-mapping', actualIndex);

        // Reload the mappings list
        await showMappingsList();

        // Reload the UI to update visual indicators
        await loadFaders();
        await loadMappings();
        markConfigChanged();
      } catch (error) {
        alert(`Error deleting mapping: ${error.message}`);
      }
    }

    async function clearAllMappingsFromList() {
      // Get all mappings
      const allMappings = await ipcRenderer.invoke('get-mappings');
      const mappingCount = allMappings.filter(m => m.midi.type !== 'none').length;

      if (mappingCount === 0) {
        alert('No mappings to clear.');
        return;
      }

      // Double confirmation
      if (!confirm(`‚ö†Ô∏è Clear ALL ${mappingCount} MIDI mappings?\n\nThis will remove all MIDI mappings from all channels and mute groups.\n\nThis action cannot be undone!`)) {
        return;
      }

      // Second confirmation
      if (!confirm(`Are you absolutely sure?\n\nThis will clear ${mappingCount} mappings.`)) {
        return;
      }

      try {
        // Clear all mappings by setting them to 'none'
        for (let i = 0; i < allMappings.length; i++) {
          const clearedMapping = { ...allMappings[i] };
          clearedMapping.midi = { type: 'none', channel: 1 };
          await ipcRenderer.invoke('update-mapping', i, clearedMapping);
        }

        // Close the mappings list
        hideMappingsList();

        // Reload the UI to update visual indicators
        await loadFaders();
        await loadMappings();
        markConfigChanged();

        alert(`‚úì Successfully cleared all ${mappingCount} mappings.`);
      } catch (error) {
        alert(`Error clearing mappings: ${error.message}`);
      }
    }

    function updateSmoothingDisplay() {
      const smoothingInput = document.getElementById('fader-smoothing');
      const display = document.getElementById('smoothing-display');
      display.textContent = smoothingInput.value;
    }

    function savePreferences() {
      const smoothingInput = document.getElementById('fader-smoothing');
      const midiFeedbackCheckbox = document.getElementById('midi-feedback-enabled');

      faderSmoothingSpeed = parseInt(smoothingInput.value);
      midiFeedbackEnabled = midiFeedbackCheckbox.checked;

      localStorage.setItem('faderSmoothingSpeed', faderSmoothingSpeed);
      localStorage.setItem('midiFeedbackEnabled', midiFeedbackEnabled.toString());

      // Send preference to main process
      ipcRenderer.invoke('set-midi-feedback-enabled', midiFeedbackEnabled);

      hidePreferences();
    }

    // Helper function to shorten MIDI device names
    function shortenMidiDeviceName(deviceName) {
      if (!deviceName) return deviceName;
      // Shorten "Logic Pro Virtual Out" to "Logic Pro"
      return deviceName.replace(/Logic Pro Virtual Out/gi, 'Logic Pro');
    }

    // Load preferences on startup
    document.addEventListener('DOMContentLoaded', () => {
      const savedSmoothing = localStorage.getItem('faderSmoothingSpeed');
      if (savedSmoothing) {
        faderSmoothingSpeed = parseInt(savedSmoothing);
      }

      const savedMidiFeedback = localStorage.getItem('midiFeedbackEnabled');
      if (savedMidiFeedback !== null) {
        midiFeedbackEnabled = savedMidiFeedback === 'true';
      }

      // Send preference to main process
      ipcRenderer.invoke('set-midi-feedback-enabled', midiFeedbackEnabled);
    });

    // MIDI type change handler
    document.addEventListener('DOMContentLoaded', () => {
      const midiTypeSelect = document.getElementById('midi-type');
      if (midiTypeSelect) {
        midiTypeSelect.addEventListener('change', (e) => {
          const ccGroup = document.getElementById('cc-group');
          const noteGroup = document.getElementById('note-group');
          if (e.target.value === 'cc') {
            ccGroup.style.display = 'block';
            noteGroup.style.display = 'none';
          } else {
            ccGroup.style.display = 'none';
            noteGroup.style.display = 'block';
          }
        });
      }
    });

    // Scan for mixers
    async function scanForMixers() {
      const btn = document.getElementById('scan-btn');
      const listEl = document.getElementById('mixer-list');

      btn.disabled = true;
      btn.textContent = 'Scanning...';
      listEl.innerHTML = '<div class="empty-state">Scanning network...</div>';

      try {
        const mixers = await ipcRenderer.invoke('discover-mixers');

        if (mixers.length === 0) {
          listEl.innerHTML = '<div class="empty-state">No mixers found. Try manual connection below.</div>';
        } else {
          listEl.innerHTML = mixers.map(mixer => {
            // Format display: IP {model} {deviceName}
            const displayName = `${mixer.ip} ${mixer.model || mixer.name}${mixer.deviceName ? ' ' + mixer.deviceName : ''}`;
            // Tooltip: Show all three fields
            const tooltip = `IP: ${mixer.ip}\\nModel: ${mixer.model || mixer.name}${mixer.deviceName ? '\\nDevice Name: ' + mixer.deviceName : ''}\\nSerial: ${mixer.serial}`;

            return `
            <div class="mixer-item" title="${tooltip}">
              <div class="mixer-info">
                <div class="mixer-name">${displayName}</div>
                <div class="mixer-details">Serial: ${mixer.serial}</div>
              </div>
              <button class="btn" onclick="connectToMixer('${mixer.ip}', '${mixer.model || mixer.name}', '${mixer.deviceName || ''}')">Connect</button>
            </div>
          `}).join('');
        }
      } catch (error) {
        listEl.innerHTML = `<div class="empty-state">Error: ${error.message}</div>`;
      } finally {
        btn.disabled = false;
        btn.textContent = 'Scan Network';
      }
    }

    // Connect to mixer
    async function connectToMixer(ip, model, deviceName) {
      try {
        await updateStatusInitWithDelay(`Connecting to ${model || 'mixer'} at ${ip}...`);
        const result = await ipcRenderer.invoke('connect-mixer', ip, model, deviceName);
        if (result.success) {
          await updateStatusInitWithDelay('Connected - waiting for mixer state...');
          hideDiscovery();
          updateStatus();
        } else {
          const errorMsg = `Connection failed: ${result.error}`;
          updateStatusInit(errorMsg);
          addStatusLog(errorMsg, 'error');
          alert(`‚úó Failed to connect: ${result.error}`);
        }
      } catch (error) {
        const errorMsg = `Error: ${error.message}`;
        updateStatusInit(errorMsg);
        addStatusLog(errorMsg, 'error');
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Connect manually
    async function connectManual() {
      const ip = document.getElementById('manual-ip').value.trim();
      if (!ip) {
        alert('Please enter an IP address');
        return;
      }
      await connectToMixer(ip);
    }

    // Load MIDI devices
    async function loadMidiDevices() {
      try {
        const { inputs, connected } = await ipcRenderer.invoke('get-midi-devices');
        // connected is now an array of device names
        const connectedSet = new Set(Array.isArray(connected) ? connected : (connected ? [connected] : []));
        const listEl = document.getElementById('midi-devices-list');

        if (inputs.length === 0) {
          listEl.innerHTML = '<div class="empty-state">No MIDI input devices found. Make sure Logic Pro is running or your MIDI controller is connected.</div>';
        } else {
          let html = `<div class="midi-section-header">MIDI Inputs (${inputs.length})</div>`;
          html += inputs.map(device => {
            const isConnected = connectedSet.has(device);
            const escapedDevice = device.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            return `
              <div class="mixer-item${isConnected ? ' connected-device' : ''}">
                <div class="mixer-info">
                  <div class="mixer-name">üéπ ${device}</div>
                  ${isConnected ? '<div class="mixer-details" style="color: #4a9b7f; font-size: 0.8rem;">‚óè Connected</div>' : ''}
                </div>
                ${isConnected
                  ? `<button class="btn" style="background:rgba(200,50,50,0.3); border-color:#c74a3a;" onclick="disconnectMidiDevice('${escapedDevice}')">Disconnect</button>`
                  : `<button class="btn" onclick="connectToMidiDevice('${escapedDevice}')">Connect</button>`
                }
              </div>
            `;
          }).join('');
          listEl.innerHTML = html;
        }
      } catch (error) {
        const listEl = document.getElementById('midi-devices-list');
        listEl.innerHTML = `<div class="empty-state">Error: ${error.message}</div>`;
      }
    }

    // Disconnect a MIDI device
    async function disconnectMidiDevice(deviceName) {
      try {
        await ipcRenderer.invoke('disconnect-midi-device', deviceName);
        await loadMidiDevices();
        updateStatus();
      } catch (error) {
        alert(`‚úó Error disconnecting: ${error.message}`);
      }
    }

    // Refresh MIDI devices
    async function refreshMidiDevices() {
      await loadMidiDevices();
    }

    // Channel management functions
    async function removeSelectedChannels() {
      const selectedFaders = document.querySelectorAll('.fader-channel.selected');
      if (selectedFaders.length === 0) {
        alert('No channels selected. Click on a fader to select it, then try again.');
        return;
      }

      if (!confirm(`Remove ${selectedFaders.length} selected channel(s)?`)) {
        return;
      }

      try {
        for (const fader of selectedFaders) {
          const faderId = fader.getAttribute('data-fader-id');
          const [channelType, channelNum] = faderId.split('-');

          // Find and remove the mapping
          const mappings = await ipcRenderer.invoke('get-mappings');
          const mappingIndex = mappings.findIndex(m =>
            m.mixer.action === 'volume' &&
            (m.mixer.channel.type || 'LINE') === channelType &&
            (m.mixer.channel.channel || m.mixer.channel) == channelNum
          );

          if (mappingIndex !== -1) {
            await ipcRenderer.invoke('remove-mapping', mappingIndex);
          }
        }

        await loadFaders();
        await loadMappings();
        markConfigChanged();
        // Removed alert - silent removal
      } catch (error) {
        alert(`‚úó Error removing channels: ${error.message}`);
      }
    }

    async function clearAllChannels() {
      if (!confirm('Clear ALL channel mappings (except MAIN)? This will only clear the MIDI mappings, not the faders.')) {
        return;
      }

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        // Remove all mappings except MAIN in reverse order to maintain indices
        let removedCount = 0;
        for (let i = mappings.length - 1; i >= 0; i--) {
          const mapping = mappings[i];
          const channelType = mapping.mixer.channel.type || 'LINE';

          // Skip MAIN channels
          if (channelType === 'MAIN') {
            continue;
          }

          await ipcRenderer.invoke('remove-mapping', i);
          removedCount++;
        }

        await loadFaders();
        await loadMappings();
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error clearing channels: ${error.message}`);
      }
    }

    // Handle filter dropdown change
    async function onFilterChange() {
      const filterSelect = document.getElementById('filter-select');
      faderFilter = filterSelect.value;

      // Save filter state to mapping engine
      await ipcRenderer.invoke('set-fader-filter', faderFilter);
      markConfigChanged();

      loadFaders();
    }

    // Update filter dropdown with DCA groups and auto-filter groups
    async function updateFilterDropdown() {
      const filterSelect = document.getElementById('filter-select');
      if (!filterSelect) {
        console.log('[updateFilterDropdown] Filter select not found');
        return;
      }

      // Save current selection
      const currentValue = filterSelect.value;

      // Remove old group options
      const options = Array.from(filterSelect.options);
      options.forEach(opt => {
        if (opt.value.startsWith('dca-') || opt.value.startsWith('auto-')) {
          filterSelect.removeChild(opt);
        }
      });

      let addedCount = 0;

      // Add DCA group options (only for named DCA groups, not default names)
      const dcaData = channelDataCache['dca'];
      if (dcaData && dcaData.names) {
        dcaData.names.forEach(dca => {
          // Skip default names like "Ch 1", "DCA 1", etc.
          const isDefaultName = !dca.name ||
                               dca.name === `Ch ${dca.channel}` ||
                               dca.name === `DCA ${dca.channel}`;

          if (!isDefaultName) {
            const option = document.createElement('option');
            option.value = `dca-${dca.channel}`;
            option.textContent = `üîç DCA: ${dca.name}`;
            filterSelect.appendChild(option);
            addedCount++;
          }
        });
      }

      // Fetch and add auto-filter group options
      try {
        const autoFilterGroups = await ipcRenderer.invoke('get-autofilter-group-names', 8);
        console.log('[updateFilterDropdown] Auto-filter groups:', autoFilterGroups);

        autoFilterGroups.forEach(group => {
          // Skip default names like "Auto 1", empty names, or names without the ~ prefix
          const isDefaultName = !group.name ||
                               group.name === `Auto ${group.channel}` ||
                               group.name === `Ch ${group.channel}`;

          if (!isDefaultName) {
            const option = document.createElement('option');
            option.value = `auto-${group.channel}`;
            option.textContent = `üîç ${group.name}`;
            filterSelect.appendChild(option);
            addedCount++;
          }
        });
      } catch (error) {
        console.log('[updateFilterDropdown] Error fetching auto-filter groups:', error);
      }

      // Restore previous selection (or use faderFilter global)
      const valueToRestore = currentValue || faderFilter;
      if (valueToRestore && filterSelect.querySelector(`option[value="${valueToRestore}"]`)) {
        filterSelect.value = valueToRestore;
      }

      console.log(`[updateFilterDropdown] Added ${addedCount} group options to dropdown`);
    }

    // Mute group functions
    let muteGroupsData = [];

    async function loadMuteGroups() {
      try {
        console.log('[loadMuteGroups] Loading mute groups...');
        const groups = await ipcRenderer.invoke('get-mute-group-names');
        console.log('[loadMuteGroups] Received groups:', groups);
        muteGroupsData = groups;
        renderMuteGroups();
      } catch (error) {
        console.error('[loadMuteGroups] Error loading mute groups:', error);
      }
    }

    function renderMuteGroups() {
      const container = document.getElementById('mute-groups-container');
      console.log('[renderMuteGroups] Container:', container);
      console.log('[renderMuteGroups] Mute groups data:', muteGroupsData);
      if (!container) {
        console.error('[renderMuteGroups] Container not found!');
        return;
      }

      container.innerHTML = '';

      if (!muteGroupsData || muteGroupsData.length === 0) {
        console.warn('[renderMuteGroups] No mute groups data to render');
        return;
      }

      console.log('[renderMuteGroups] Rendering', muteGroupsData.length, 'mute groups');
      muteGroupsData.forEach(group => {
        const button = document.createElement('button');

        // Check if this mute group has a MIDI mapping
        const isMapped = currentMappings.some(m =>
          m.mixer.action === 'mutegroup' && m.mixer.channel.channel === group.group
        );

        button.className = `btn mute-group-btn${group.active ? ' active' : ''}${isMapped ? ' mapped' : ''}`;
        button.id = `mute-group-${group.group}`;
        button.setAttribute('data-group-num', group.group);
        button.textContent = group.name;

        // Update tooltip to show MIDI mapping info if mapped
        if (isMapped) {
          const mapping = currentMappings.find(m =>
            m.mixer.action === 'mutegroup' && m.mixer.channel.channel === group.group
          );
          const midiInfo = mapping.midi.type === 'cc'
            ? `CC${mapping.midi.controller} Ch${mapping.midi.channel}`
            : `Note ${mapping.midi.note} Ch${mapping.midi.channel}`;
          button.title = `Mute Group ${group.group}: ${group.name}\n${midiInfo}`;
        } else {
          button.title = `Mute Group ${group.group}: ${group.name}`;
        }

        button.onclick = () => toggleMuteGroup(group.group);

        // Add right-click context menu for editing
        button.oncontextmenu = (e) => {
          e.preventDefault();
          showMuteGroupContextMenu(group.group, e.clientX, e.clientY);
        };

        // Add MIDI indicator dot if mapped
        if (isMapped) {
          const indicator = document.createElement('div');
          indicator.className = 'midi-indicator';
          button.appendChild(indicator);
        }

        container.appendChild(button);
      });
    }

    // Helper function to position context menu within viewport bounds
    function positionContextMenu(contextMenu, x, y) {
      // First, show the menu to get its dimensions
      contextMenu.classList.add('show');

      const menuRect = contextMenu.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Adjust x position if menu would overflow right edge
      if (x + menuRect.width > viewportWidth) {
        x = viewportWidth - menuRect.width - 10; // 10px padding from edge
      }

      // Adjust y position if menu would overflow bottom edge
      if (y + menuRect.height > viewportHeight) {
        y = viewportHeight - menuRect.height - 10; // 10px padding from edge
      }

      // Ensure menu doesn't go off left or top edge
      x = Math.max(10, x);
      y = Math.max(10, y);

      contextMenu.style.left = `${x}px`;
      contextMenu.style.top = `${y}px`;
    }

    // Mute group context menu
    let currentContextMenuMuteGroup = null;

    function showMuteGroupContextMenu(groupNum, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('mutegroup-context-menu');
      currentContextMenuMuteGroup = groupNum;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuEditMuteGroup() {
      if (currentContextMenuMuteGroup === null) {
        hideAllContextMenus();
        return;
      }

      const groupNum = currentContextMenuMuteGroup;

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'mutegroup' &&
          m.mixer.channel.channel === groupNum
        );

        // Set flag to prevent auto-update during editing
        isEditingMapping = true;

        // Populate the modal
        const modal = document.getElementById('add-mapping-modal');

        if (mappingIndex !== -1) {
          // Editing existing mute group mapping
          const mapping = mappings[mappingIndex];

          document.getElementById('midi-type').value = mapping.midi.type;
          if (mapping.midi.type === 'cc') {
            document.getElementById('midi-cc').value = mapping.midi.controller;
          } else if (mapping.midi.type === 'note') {
            document.getElementById('midi-note').value = mapping.midi.note;
          }
          document.getElementById('midi-channel').value = mapping.midi.channel;

          modal.dataset.editingIndex = mappingIndex;
          modal.querySelector('h2').textContent = '‚úèÔ∏è Edit Mute Group Mapping';
        } else {
          // Creating new mute group mapping
          document.getElementById('midi-type').value = 'note';
          document.getElementById('midi-note').value = String(70 + groupNum); // Default to note 71-78
          document.getElementById('midi-channel').value = '1';

          delete modal.dataset.editingIndex;
          modal.querySelector('h2').textContent = '‚ûï Create Mute Group Mapping';
        }

        // Set channel info - mute groups don't have a channel type, just use the group number
        // We'll need to handle this specially in the addMapping function
        document.getElementById('mixer-channel-type').value = 'LINE'; // Placeholder
        await updateChannelNumberOptions();
        document.getElementById('mixer-channel-num').value = groupNum;

        // Set action to mutegroup (note: this may not be in the dropdown yet)
        const actionSelect = document.getElementById('mixer-action');
        // Check if mutegroup option exists, if not add it temporarily
        if (![...actionSelect.options].some(opt => opt.value === 'mutegroup')) {
          const option = document.createElement('option');
          option.value = 'mutegroup';
          option.textContent = 'Mute Group';
          actionSelect.appendChild(option);
        }
        actionSelect.value = 'mutegroup';

        // Store the group number for later use
        modal.dataset.muteGroupNum = groupNum;

        // Update MIDI type fields
        updateMidiTypeFields();

        isEditingMapping = false;

        // Populate device filter, pre-selecting existing mapping's device if any
        const existingMuteGroupMapping = mappingIndex !== -1 ? mappings[mappingIndex] : null;
        await populateMidiDeviceFilter(existingMuteGroupMapping && existingMuteGroupMapping.midi.device);

        // Show modal
        modal.classList.add('show');
      } catch (error) {
        isEditingMapping = false;
        alert(`‚úó Error: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuClearMuteGroup() {
      if (currentContextMenuMuteGroup === null) {
        hideAllContextMenus();
        return;
      }

      const groupNum = currentContextMenuMuteGroup;

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'mutegroup' &&
          m.mixer.channel.channel === groupNum
        );

        if (mappingIndex !== -1) {
          await ipcRenderer.invoke('remove-mapping', mappingIndex);
          await loadMappings();
          renderMuteGroups(); // Re-render mute groups to update mapped state
          markConfigChanged();
        }
      } catch (error) {
        alert(`‚úó Error clearing mute group mapping: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function toggleMuteGroup(groupNum) {
      try {
        const result = await ipcRenderer.invoke('toggle-mute-group', groupNum);
        if (result.success) {
          // Update the mute group button state
          const button = document.getElementById(`mute-group-${groupNum}`);
          const newState = await ipcRenderer.invoke('get-mute-group-state', groupNum);

          if (button) {
            if (newState) {
              button.classList.add('active');
            } else {
              button.classList.remove('active');
            }
          }

          // Update the mute button states for all channels in this mute group
          const assignments = await ipcRenderer.invoke('get-mute-group-assignments', groupNum);
          console.log(`[toggleMuteGroup] Group ${groupNum} assignments:`, assignments);

          for (const assignment of assignments) {
            // Get the current mute state for this channel
            const muted = await ipcRenderer.invoke('get-channel-mute', assignment.type, assignment.channel);
            console.log(`[toggleMuteGroup] Channel ${assignment.type}${assignment.channel} muted:`, muted);
            if (muted !== null) {
              console.log(`[toggleMuteGroup] Updating mute button for ${assignment.type}${assignment.channel} to ${muted}`);
              updateMuteButton(assignment.type, assignment.channel, muted);
            }
          }
        } else {
          console.error(`[toggleMuteGroup] Failed to toggle mute group ${groupNum}:`, result.error);
        }
      } catch (error) {
        console.error(`[toggleMuteGroup] Error toggling mute group ${groupNum}:`, error);
      }
    }

    // Edit fader mapping (double-click handler)
    async function editFaderMapping(faderId) {
      try {
        const [channelType, channelNum] = faderId.split('-');
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'volume' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        if (mappingIndex === -1) {
          // No mapping exists - open add mapping dialog with pre-filled channel info
          showAddMapping();
          document.getElementById('mixer-channel-type').value = channelType;
          await updateChannelNumberOptions();
          document.getElementById('mixer-channel-num').value = channelNum;
          // Update MIDI settings to match the mixer channel
          updateMidiSettingsForChannel();
          return;
        }

        const mapping = mappings[mappingIndex];

        // Set flag to prevent auto-updating MIDI settings
        isEditingMapping = true;

        // Populate the add-mapping modal with existing data
        document.getElementById('midi-type').value = mapping.midi.type;

        if (mapping.midi.type === 'cc') {
          document.getElementById('midi-cc').value = mapping.midi.controller;
        } else if (mapping.midi.type === 'note') {
          document.getElementById('midi-note').value = mapping.midi.note;
        } else if (mapping.midi.type === 'note-value') {
          document.getElementById('midi-note-min').value = mapping.midi.noteMin || 24;
          document.getElementById('midi-note-max').value = mapping.midi.noteMax || 60;
        }

        // Update field visibility
        updateMidiTypeFields();

        document.getElementById('mixer-action').value = mapping.mixer.action;
        document.getElementById('mixer-channel-type').value = mapping.mixer.channel.type || 'LINE';

        // Update channel number options and then set the value
        await updateChannelNumberOptions();
        document.getElementById('mixer-channel-num').value = mapping.mixer.channel.channel || mapping.mixer.channel;

        // Set MIDI settings (won't be overwritten now because of isEditingMapping flag)
        document.getElementById('midi-channel').value = mapping.midi.channel;
        if (mapping.midi.type === 'cc') {
          document.getElementById('midi-cc').value = mapping.midi.controller;
        }

        // Clear the flag
        isEditingMapping = false;

        // Change modal title to indicate editing
        const modal = document.getElementById('add-mapping-modal');
        const modalTitle = modal.querySelector('h2');
        modalTitle.textContent = '‚úèÔ∏è Edit Mapping';

        // Store the mapping index so we know we're editing
        modal.dataset.editingIndex = mappingIndex;

        // Populate device filter dropdown and pre-select the mapping's device if set
        const editedMapping = mappings[mappingIndex];
        await populateMidiDeviceFilter(editedMapping && editedMapping.midi && editedMapping.midi.device);

        // Show the modal
        modal.classList.add('show');
      } catch (error) {
        // Silent error handling
        isEditingMapping = false; // Make sure to clear flag on error
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Context menu management
    let currentContextMenuFaderId = null;

    function hideAllContextMenus() {
      document.getElementById('fader-context-menu')?.classList.remove('show');
      document.getElementById('mute-context-menu')?.classList.remove('show');
      document.getElementById('solo-context-menu')?.classList.remove('show');
      document.getElementById('channel-context-menu')?.classList.remove('show');
      document.getElementById('mutegroup-context-menu')?.classList.remove('show');
      currentContextMenuFaderId = null;
    }

    // Fader volume context menu
    function showFaderVolumeContextMenu(faderId, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('fader-context-menu');
      currentContextMenuFaderId = faderId;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuEditFader() {
      if (currentContextMenuFaderId) {
        await editFaderMapping(currentContextMenuFaderId);
      }
      hideAllContextMenus();
    }

    async function contextMenuClearFader() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'volume' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        if (mappingIndex !== -1) {
          await ipcRenderer.invoke('remove-mapping', mappingIndex);
          await loadFaders();
          await loadMappings();
          markConfigChanged();
        }
      } catch (error) {
        alert(`‚úó Error clearing volume mapping: ${error.message}`);
      }

      hideAllContextMenus();
    }

    // Mute button context menu
    function showMuteContextMenu(faderId, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('mute-context-menu');
      currentContextMenuFaderId = faderId;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuEditMute() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      try {
        const [channelType, channelNum] = currentContextMenuFaderId.split('-');
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'mute' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        // Set flag to prevent auto-update during editing
        isEditingMapping = true;

        // Populate the modal
        const modal = document.getElementById('add-mapping-modal');

        if (mappingIndex !== -1) {
          // Editing existing mute mapping
          const mapping = mappings[mappingIndex];

          document.getElementById('midi-type').value = mapping.midi.type;
          if (mapping.midi.type === 'cc') {
            document.getElementById('midi-cc').value = mapping.midi.controller;
          } else if (mapping.midi.type === 'note') {
            document.getElementById('midi-note').value = mapping.midi.note;
          }
          document.getElementById('midi-channel').value = mapping.midi.channel;

          modal.dataset.editingIndex = mappingIndex;
          modal.querySelector('h2').textContent = '‚úèÔ∏è Edit Mute Mapping';
        } else {
          // Creating new mute mapping
          document.getElementById('midi-type').value = 'note';
          document.getElementById('midi-note').value = '60';
          document.getElementById('midi-channel').value = channelNum;

          delete modal.dataset.editingIndex;
          modal.querySelector('h2').textContent = '‚ûï Create Mute Mapping';
        }

        // Set channel info
        document.getElementById('mixer-channel-type').value = channelType;
        await updateChannelNumberOptions();
        document.getElementById('mixer-channel-num').value = channelNum;

        // Set action to mute
        document.getElementById('mixer-action').value = 'mute';

        // Update MIDI type fields
        updateMidiTypeFields();

        isEditingMapping = false;

        // Populate device filter, pre-selecting existing mapping's device if any
        const existingMuteMapping = mappingIndex !== -1 ? mappings[mappingIndex] : null;
        await populateMidiDeviceFilter(existingMuteMapping && existingMuteMapping.midi.device);

        // Show modal
        modal.classList.add('show');
      } catch (error) {
        isEditingMapping = false;
        alert(`‚úó Error: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuClearMute() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'mute' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        if (mappingIndex !== -1) {
          await ipcRenderer.invoke('remove-mapping', mappingIndex);
          await loadFaders();
          await loadMappings();
          markConfigChanged();
        }
      } catch (error) {
        alert(`‚úó Error clearing mute mapping: ${error.message}`);
      }

      hideAllContextMenus();
    }

    // Solo button context menu
    function showSoloContextMenu(faderId, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('solo-context-menu');
      currentContextMenuFaderId = faderId;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuEditSolo() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      try {
        const [channelType, channelNum] = currentContextMenuFaderId.split('-');
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'solo' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        // Set flag to prevent auto-update during editing
        isEditingMapping = true;

        // Populate the modal
        const modal = document.getElementById('add-mapping-modal');

        if (mappingIndex !== -1) {
          // Editing existing solo mapping
          const mapping = mappings[mappingIndex];

          document.getElementById('midi-type').value = mapping.midi.type;
          if (mapping.midi.type === 'cc') {
            document.getElementById('midi-cc').value = mapping.midi.controller;
          } else if (mapping.midi.type === 'note') {
            document.getElementById('midi-note').value = mapping.midi.note;
          }
          document.getElementById('midi-channel').value = mapping.midi.channel;

          modal.dataset.editingIndex = mappingIndex;
          modal.querySelector('h2').textContent = '‚úèÔ∏è Edit Solo Mapping';
        } else {
          // Creating new solo mapping
          document.getElementById('midi-type').value = 'note';
          document.getElementById('midi-note').value = '61';
          document.getElementById('midi-channel').value = channelNum;

          delete modal.dataset.editingIndex;
          modal.querySelector('h2').textContent = '‚ûï Create Solo Mapping';
        }

        // Set channel info
        document.getElementById('mixer-channel-type').value = channelType;
        await updateChannelNumberOptions();
        document.getElementById('mixer-channel-num').value = channelNum;

        // Set action to solo
        document.getElementById('mixer-action').value = 'solo';

        // Update MIDI type fields
        updateMidiTypeFields();

        isEditingMapping = false;

        // Populate device filter, pre-selecting existing mapping's device if any
        const existingSoloMapping = mappingIndex !== -1 ? mappings[mappingIndex] : null;
        await populateMidiDeviceFilter(existingSoloMapping && existingSoloMapping.midi.device);

        // Show modal
        modal.classList.add('show');
      } catch (error) {
        isEditingMapping = false;
        alert(`‚úó Error: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuClearSolo() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'solo' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        if (mappingIndex !== -1) {
          await ipcRenderer.invoke('remove-mapping', mappingIndex);
          await loadFaders();
          await loadMappings();
          markConfigChanged();
        }
      } catch (error) {
        alert(`‚úó Error clearing solo mapping: ${error.message}`);
      }

      hideAllContextMenus();
    }

    // Channel context menu
    function showChannelContextMenu(faderId, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('channel-context-menu');
      currentContextMenuFaderId = faderId;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuToggleMain() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      try {
        const currentState = await ipcRenderer.invoke('get-channel-main-assign', channelType, channelNum);
        await ipcRenderer.invoke('set-channel-main-assign', channelType, channelNum, !currentState);
        await loadFaders(); // Reload to update visual state
      } catch (error) {
        alert(`‚úó Error toggling main assign: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuRemoveChannel() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      if (!confirm(`Remove ${channelType} ${channelNum} from the fader view?\n\nThis will also clear all MIDI mappings for this channel.`)) {
        hideAllContextMenus();
        return;
      }

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        // Find all mappings for this channel (volume, mute, solo, etc.)
        const indicesToRemove = [];
        mappings.forEach((m, index) => {
          if ((m.mixer.channel.type || 'LINE') === channelType &&
              (m.mixer.channel.channel || m.mixer.channel) == channelNum) {
            indicesToRemove.push(index);
          }
        });

        // Remove in reverse order to maintain indices
        for (let i = indicesToRemove.length - 1; i >= 0; i--) {
          await ipcRenderer.invoke('remove-mapping', indicesToRemove[i]);
        }

        await loadFaders();
        await loadMappings();
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error removing channel: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuClearAllMappings() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      if (!confirm(`Clear ALL MIDI mappings (volume, mute, solo) for ${channelType} ${channelNum}?`)) {
        hideAllContextMenus();
        return;
      }

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        // Find all mappings for this channel (volume, mute, solo, etc.)
        const indicesToRemove = [];
        mappings.forEach((m, index) => {
          if ((m.mixer.channel.type || 'LINE') === channelType &&
              (m.mixer.channel.channel || m.mixer.channel) == channelNum) {
            indicesToRemove.push(index);
          }
        });

        // Remove in reverse order to maintain indices
        for (let i = indicesToRemove.length - 1; i >= 0; i--) {
          await ipcRenderer.invoke('remove-mapping', indicesToRemove[i]);
        }

        await loadFaders();
        await loadMappings();
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error clearing all mappings: ${error.message}`);
      }

      hideAllContextMenus();
    }

    // Connect to MIDI device (additive ‚Äî keeps existing connections)
    async function connectToMidiDevice(deviceName) {
      try {
        const result = await ipcRenderer.invoke('connect-midi-device', deviceName);
        if (result.success) {
          // Reload the device list in-place (don't close modal ‚Äî user may want to add more)
          await loadMidiDevices();
          updateStatus();
        } else {
          alert(`‚úó Failed to connect: ${result.error}`);
        }
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Add or update mapping
    async function addMapping() {
      const modal = document.getElementById('add-mapping-modal');
      const isEditing = modal.dataset.editingIndex !== undefined;
      const editingIndex = isEditing ? parseInt(modal.dataset.editingIndex) : -1;

      const midiType = document.getElementById('midi-type').value;
      const midiChannel = parseInt(document.getElementById('midi-channel').value);
      const midiDeviceFilter = document.getElementById('midi-device-filter').value || undefined;
      const mixerAction = document.getElementById('mixer-action').value;
      const channelType = document.getElementById('mixer-channel-type').value;
      const channelNum = parseInt(document.getElementById('mixer-channel-num').value);

      const mapping = {
        midi: {
          type: midiType,
          channel: midiChannel,
          ...(midiDeviceFilter ? { device: midiDeviceFilter } : {})
        },
        mixer: {
          action: mixerAction,
          channel: {
            type: channelType,
            channel: channelNum
          }
        }
      };

      if (midiType === 'cc') {
        mapping.midi.controller = parseInt(document.getElementById('midi-cc').value);
        // Add threshold for boolean controls (mute/solo/mutegroup)
        if (mixerAction === 'mute' || mixerAction === 'solo' || mixerAction === 'mutegroup') {
          mapping.midi.threshold = parseInt(document.getElementById('midi-cc-threshold').value) || 64;
        }
      } else if (midiType === 'note') {
        mapping.midi.note = parseInt(document.getElementById('midi-note').value);
        // Add invert for boolean controls (mute/solo/mutegroup)
        if (mixerAction === 'mute' || mixerAction === 'solo' || mixerAction === 'mutegroup') {
          mapping.midi.invert = document.getElementById('midi-note-invert').checked;
        }
      } else if (midiType === 'note-value') {
        mapping.midi.noteMin = parseInt(document.getElementById('midi-note-min').value);
        mapping.midi.noteMax = parseInt(document.getElementById('midi-note-max').value);
      }

      try {
        // Check if this is a volume mapping on the second channel of a stereo pair
        if (mixerAction === 'volume' && channelNum % 2 === 0) {
          // Check if the previous channel (odd channel) is linked
          const prevChannelLink = await ipcRenderer.invoke('get-channel-link', channelType, channelNum - 1);
          if (prevChannelLink) {
            alert(`‚úó Cannot map volume on channel ${channelNum}!\n\nThis channel is the second channel of a stereo pair (linked with channel ${channelNum - 1}).\n\nVolume control is handled by the first channel of the stereo pair.`);
            return;
          }
        }

        // Get existing mappings for validation
        const existingMappings = await ipcRenderer.invoke('get-mappings');

        // Check for MIDI conflicts (same MIDI channel + CC/note) - skip if type is "none"
        if (midiType !== 'none') {
          const midiConflictIndex = existingMappings.findIndex((m, idx) => {
            // Skip if we're editing this mapping
            if (isEditing && idx === editingIndex) return false;

            // Skip if the existing mapping has no MIDI type
            if (m.midi.type === 'none') return false;

            // Check if MIDI settings conflict
            if (m.midi.channel !== midiChannel) return false;

            if (midiType === 'cc' && m.midi.type === 'cc') {
              return m.midi.controller === mapping.midi.controller;
            } else if (midiType === 'note' && m.midi.type === 'note') {
              return m.midi.note === mapping.midi.note;
            } else if (midiType === 'note-value' && m.midi.type === 'note-value') {
              // Check for overlapping note ranges
              const existingMin = m.midi.noteMin || 24;
              const existingMax = m.midi.noteMax || 60;
              const newMin = mapping.midi.noteMin || 24;
              const newMax = mapping.midi.noteMax || 60;
              return !(newMax < existingMin || newMin > existingMax);
            }
            return false;
          });

          if (midiConflictIndex !== -1) {
            const conflictMapping = existingMappings[midiConflictIndex];
            const conflictChannel = `${conflictMapping.mixer.channel.type || 'LINE'} ${conflictMapping.mixer.channel.channel || conflictMapping.mixer.channel}`;
            const midiInfo = mapping.midi.type === 'cc'
              ? `CC${mapping.midi.controller} Ch${mapping.midi.channel}`
              : mapping.midi.type === 'note-value'
              ? `Note ${mapping.midi.noteMin}-${mapping.midi.noteMax} Ch${mapping.midi.channel}`
              : `Note ${mapping.midi.note} Ch${mapping.midi.channel}`;

            alert(`‚úó MIDI Conflict!\n\nThis MIDI configuration (${midiInfo}) is already used by ${conflictChannel}.\n\nPlease choose different MIDI settings.`);
            return;
          }
        }

        if (isEditing) {
          // We're editing an existing mapping - remove the old one first
          await ipcRenderer.invoke('remove-mapping', editingIndex);
          await ipcRenderer.invoke('add-mapping', mapping);
          markConfigChanged();
        } else {
          // Check if a mapping already exists for this mixer channel + action
          const existingIndex = existingMappings.findIndex(m =>
            m.mixer.action === mixerAction &&
            (m.mixer.channel.type || 'LINE') === channelType &&
            (m.mixer.channel.channel || m.mixer.channel) == channelNum
          );

          if (existingIndex !== -1) {
            // Ask user if they want to update the existing mapping
            const existingMapping = existingMappings[existingIndex];
            const existingMidiInfo = existingMapping.midi.type === 'cc'
              ? `${getCCShorthand(existingMapping.midi.controller)} Ch${existingMapping.midi.channel}`
              : existingMapping.midi.type === 'note-value'
              ? `Note ${existingMapping.midi.noteMin}-${existingMapping.midi.noteMax} Ch${existingMapping.midi.channel}`
              : `Note ${existingMapping.midi.note} Ch${existingMapping.midi.channel}`;
            const newMidiInfo = mapping.midi.type === 'cc'
              ? `${getCCShorthand(mapping.midi.controller)} Ch${mapping.midi.channel}`
              : mapping.midi.type === 'note-value'
              ? `Note ${mapping.midi.noteMin}-${mapping.midi.noteMax} Ch${mapping.midi.channel}`
              : `Note ${mapping.midi.note} Ch${mapping.midi.channel}`;

            if (!confirm(`A mapping already exists for ${channelType} ${channelNum} (${mixerAction}):\n\nExisting: ${existingMidiInfo}\nNew: ${newMidiInfo}\n\nUpdate the existing mapping?`)) {
              return;
            }

            // Remove the old mapping and add the new one
            await ipcRenderer.invoke('remove-mapping', existingIndex);
          }

          await ipcRenderer.invoke('add-mapping', mapping);
          markConfigChanged();
        }

        hideAddMapping();
        loadMappings();
        loadFaders(); // Reload faders to show new mapping

        // If we came from the mappings list, return to it
        if (returnToMappingsList) {
          returnToMappingsList = false;
          setTimeout(() => showMappingsList(), 100);
        }
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Remove mapping
    async function removeMapping(index) {
      if (!confirm('Remove this mapping?')) return;

      try {
        await ipcRenderer.invoke('remove-mapping', index);
        loadMappings();
        loadFaders(); // Update faders UI
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Save preset
    async function savePreset() {
      const name = document.getElementById('preset-name').value.trim();
      const description = document.getElementById('preset-description').value.trim();

      if (!name) {
        alert('Please enter a preset name');
        return;
      }

      try {
        const result = await ipcRenderer.invoke('save-preset', name, description);
        if (result.success) {
          alert(`‚úì Preset saved to ${result.path}`);
          hideSavePreset();
          updateStatus();
          updateStatusLastSaved(Date.now());
        } else {
          alert(`‚úó Failed to save: ${result.error}`);
        }
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Load mappings
    async function loadMappings() {
      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        // Store in global variable for use by other components (e.g., mute groups)
        currentMappings = mappings;

        const channelNames = await ipcRenderer.invoke('get-channel-names', 'line', 16);
        const listEl = document.getElementById('mappings-list');

        if (mappings.length === 0) {
          listEl.innerHTML = '<div class="empty-state">No mappings yet. Click "Create New" to add one.</div>';
        } else {
          listEl.innerHTML = mappings.map((mapping, index) => {
            const midiDesc = mapping.midi.type === 'cc'
              ? `CC ${mapping.midi.controller} (Ch ${mapping.midi.channel})`
              : `Note ${mapping.midi.note} (Ch ${mapping.midi.channel})`;

            // Extract channel number and get name
            const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
            const channelInfo = channelNames.find(c => c.channel === channelNum);
            const channelName = channelInfo ? channelInfo.name : `Ch ${channelNum}`;
            const mixerDesc = `${mapping.mixer.action} - ${channelNum}: ${channelName}`;

            return `
              <div class="mapping-card">
                <div class="mapping-activity" id="mapping-activity-${index}"></div>
                <div class="mapping-info">
                  <div class="mapping-source">üéπ ${midiDesc}</div>
                  <div class="mapping-arrow">‚Üí</div>
                  <div class="mapping-target">üéõÔ∏è ${mixerDesc}</div>
                </div>
                <button class="btn-small danger" onclick="removeMapping(${index})">Delete</button>
              </div>
            `;
          }).join('');
        }
      } catch (error) {
        // Silent error handling
      }
    }

    // Load faders
    async function loadFaders() {
      // Prevent multiple simultaneous calls
      if (isLoadingFaders) {
        console.log('[Renderer] loadFaders already in progress, skipping duplicate call');
        addStatusLog('Skipped duplicate loadFaders call', 'warning');
        return;
      }

      isLoadingFaders = true;

      try {
        await updateStatusInitWithDelay('Loading channel mappings...');
        const mappings = await ipcRenderer.invoke('get-mappings');

        const volumeMappings = mappings.filter(m => m.mixer.action === 'volume');

        // Reset channel data cache
        channelDataCache = {};

        // Always fetch LINE channel data
        await updateStatusInitWithDelay('Fetching LINE channel data...');
        try {
          const names = await ipcRenderer.invoke('get-channel-names', 'line', 16);
          const colors = await ipcRenderer.invoke('get-channel-colors', 'line', 16);
          const icons = await ipcRenderer.invoke('get-channel-icons', 'line', 16);
          const inputSources = await ipcRenderer.invoke('get-channel-input-sources', 'line', 16);

          // Debug logging for input sources
          console.log('Fetched input sources for LINE channels:', inputSources);

          // Fetch stereo link status for each channel
          const links = [];
          for (let i = 1; i <= 16; i++) {
            const link = await ipcRenderer.invoke('get-channel-link', 'line', i);
            links.push({ channel: i, link });
          }

          console.log('Fetched links for LINE channels:', links);

          channelDataCache['line'] = { names, colors, icons, links, inputSources };
        } catch (error) {
          console.error('[Renderer] Error fetching LINE channel data:', error);
          const errorMsg = `Error fetching LINE channels: ${error.message || error}`;
          updateStatusInit(errorMsg);
          addStatusLog(errorMsg, 'error');
          channelDataCache['line'] = { names: [], colors: [], icons: [], links: [], inputSources: [] };
        }

        // Always fetch SUB channel data (for subgroups)
        await updateStatusInitWithDelay('Fetching SUB channel data...');
        try {
          const names = await ipcRenderer.invoke('get-channel-names', 'sub', 8);
          const colors = await ipcRenderer.invoke('get-channel-colors', 'sub', 8);
          const icons = await ipcRenderer.invoke('get-channel-icons', 'sub', 8);
          const inputSources = await ipcRenderer.invoke('get-channel-input-sources', 'sub', 8);

          console.log('Fetched SUB channel names:', names);

          // Fetch stereo link status for each channel
          const links = [];
          for (let i = 1; i <= 8; i++) {
            const link = await ipcRenderer.invoke('get-channel-link', 'sub', i);
            links.push({ channel: i, link });
          }

          channelDataCache['sub'] = { names, colors, icons, links, inputSources };
        } catch (error) {
          console.error('[Renderer] Error fetching SUB channel data:', error);
          const errorMsg = `Error fetching SUB channels: ${error.message || error}`;
          updateStatusInit(errorMsg);
          addStatusLog(errorMsg, 'error');
          channelDataCache['sub'] = { names: [], colors: [], icons: [], links: [], inputSources: [] };
        }

        // Always fetch DCA channel data (for DCA groups)
        await updateStatusInitWithDelay('Fetching DCA group data...');
        try {
          const names = await ipcRenderer.invoke('get-channel-names', 'dca', 8);
          const colors = await ipcRenderer.invoke('get-channel-colors', 'dca', 8);
          const icons = await ipcRenderer.invoke('get-channel-icons', 'dca', 8);
          const inputSources = await ipcRenderer.invoke('get-channel-input-sources', 'dca', 8);

          console.log('Fetched DCA channel names:', names);

          // Fetch stereo link status for each channel
          const links = [];
          for (let i = 1; i <= 8; i++) {
            const link = await ipcRenderer.invoke('get-channel-link', 'dca', i);
            links.push({ channel: i, link });
          }

          channelDataCache['dca'] = { names, colors, icons, links, inputSources };

          // Update filter dropdown with DCA groups
          updateFilterDropdown();
        } catch (error) {
          console.error('[Renderer] Error fetching DCA channel data:', error);
          const errorMsg = `Error fetching DCA groups: ${error.message || error}`;
          updateStatusInit(errorMsg);
          addStatusLog(errorMsg, 'error');
          channelDataCache['dca'] = { names: [], colors: [], icons: [], links: [], inputSources: [] };
        }

        // Fetch channel data for other channel types that have mappings
        for (const mapping of volumeMappings) {
          const channelType = (mapping.mixer.channel.type || 'LINE').toLowerCase();
          if (channelType !== 'line' && !channelDataCache[channelType]) {
            try {
              const names = await ipcRenderer.invoke('get-channel-names', channelType, 16);
              const colors = await ipcRenderer.invoke('get-channel-colors', channelType, 16);
              const icons = await ipcRenderer.invoke('get-channel-icons', channelType, 16);
              const inputSources = await ipcRenderer.invoke('get-channel-input-sources', channelType, 16);

              // Fetch stereo link status for each channel
              const links = [];
              for (let i = 1; i <= 16; i++) {
                const link = await ipcRenderer.invoke('get-channel-link', channelType, i);
                links.push({ channel: i, link });
              }

              channelDataCache[channelType] = { names, colors, icons, links, inputSources };
            } catch (error) {
              // Silent error handling
              channelDataCache[channelType] = { names: [], colors: [], icons: [], links: [], inputSources: [] };
            }
          }
        }

        // Build fader list based on filter mode
        let fadersToRender = [];

        if (faderFilter === 'all') {
          // Show all LINE channels 1-16, but skip second channel of stereo pairs
          const lineData = channelDataCache['line'] || { names: [], colors: [], icons: [], links: [], inputSources: [] };

          for (let i = 1; i <= 16; i++) {
            // Check if this channel is the RIGHT side of a stereo pair
            // A channel is the right side if it's even AND the previous (odd) channel is linked
            if (i % 2 === 0) {
              const prevChannelLink = lineData.links.find(c => c.channel === (i - 1));
              if (prevChannelLink?.link) {
                // Skip this channel - it's the R channel of a stereo pair
                continue;
              }
            }

            const existingMapping = volumeMappings.find(m =>
              (m.mixer.channel.type || 'LINE') === 'LINE' &&
              (m.mixer.channel.channel || m.mixer.channel) === i
            );

            if (existingMapping) {
              fadersToRender.push(existingMapping);
            } else {
              // Create a virtual mapping with no MIDI type
              fadersToRender.push({
                midi: { type: 'none', channel: 1 },
                mixer: { action: 'volume', channel: { type: 'LINE', channel: i } }
              });
            }
          }

          // Add all non-LINE mapped channels (AUX, FX, SUB, MAIN, etc.)
          const nonLineChannels = volumeMappings.filter(m => (m.mixer.channel.type || 'LINE') !== 'LINE');
          console.log('[Renderer] Filter mode: all');
          console.log('[Renderer] Non-LINE channels found:', nonLineChannels.length, nonLineChannels.map(m => `${m.mixer.channel.type}-${m.mixer.channel.channel}`));
          fadersToRender.push(...nonLineChannels);

          // Add DCA faders for DCA groups that are "in use"
          // A DCA is "in use" if it has EITHER:
          // 1. A custom name (not default like "Ch 1" or "DCA 1"), OR
          // 2. Channels assigned to it
          const dcaData = channelDataCache['dca'] || { names: [] };
          for (let i = 1; i <= 8; i++) {
            const dcaName = dcaData.names.find(n => n.channel === i);

            // Check if this DCA has a custom name (not default)
            const hasCustomName = dcaName &&
                                  dcaName.name &&
                                  dcaName.name.trim() !== '' &&
                                  dcaName.name !== `Ch ${i}` &&
                                  dcaName.name !== `DCA ${i}`;

            // Check if this DCA has any channels assigned to it
            const assignedChannels = await ipcRenderer.invoke('get-dca-group-assignments', i);
            const hasChannelsAssigned = assignedChannels && assignedChannels.length > 0;

            // Only add if it has a custom name OR channels assigned
            if (hasCustomName || hasChannelsAssigned) {
              // Check if we already have this DCA in the list
              const existingDca = fadersToRender.find(m =>
                (m.mixer.channel.type || 'LINE') === 'DCA' &&
                m.mixer.channel.channel === i
              );

              if (!existingDca) {
                // Add virtual DCA fader
                fadersToRender.push({
                  midi: { type: 'none', channel: 1 },
                  mixer: { action: 'volume', channel: { type: 'DCA', channel: i } }
                });
                const reason = hasCustomName && hasChannelsAssigned ? 'custom name + channels' :
                               hasCustomName ? 'custom name' : 'channels assigned';
                console.log(`[Renderer] Added virtual DCA ${i} fader (${dcaName?.name || 'DCA ' + i}) - ${reason} (${assignedChannels?.length || 0} channels)`);
              }
            }
          }
        } else if (faderFilter === 'mapped') {
          // Show only mapped channels (exclude channels with type 'none')
          console.log('[Renderer] Filter mode: mapped');
          fadersToRender = volumeMappings.filter(m => m.midi.type !== 'none');
        } else if (faderFilter.startsWith('dca-')) {
          // Show only channels assigned to this DCA group
          const dcaChannel = parseInt(faderFilter.replace('dca-', ''));
          console.log(`[Renderer] Filter mode: DCA group ${dcaChannel}`);

          // Get LINE channels assigned to this DCA group
          const assignedChannels = await ipcRenderer.invoke('get-dca-group-assignments', dcaChannel);
          console.log(`[Renderer] DCA ${dcaChannel} assigned channels:`, assignedChannels);

          // Add assigned LINE channels
          const lineData = channelDataCache['line'] || { names: [], colors: [], icons: [], links: [], inputSources: [] };

          for (const lineChannel of assignedChannels) {
            // Skip if this is the RIGHT side of a stereo pair
            if (lineChannel % 2 === 0) {
              const prevChannelLink = lineData.links.find(c => c.channel === (lineChannel - 1));
              if (prevChannelLink?.link) {
                continue;
              }
            }

            const existingMapping = volumeMappings.find(m =>
              (m.mixer.channel.type || 'LINE') === 'LINE' &&
              (m.mixer.channel.channel || m.mixer.channel) === lineChannel
            );

            if (existingMapping) {
              fadersToRender.push(existingMapping);
            } else {
              // Create a virtual mapping with no MIDI type
              fadersToRender.push({
                midi: { type: 'none', channel: 1 },
                mixer: { action: 'volume', channel: { type: 'LINE', channel: lineChannel } }
              });
            }
          }

          // Add the DCA fader itself
          const dcaMapping = volumeMappings.find(m =>
            (m.mixer.channel.type || 'LINE') === 'DCA' &&
            m.mixer.channel.channel === dcaChannel
          );

          if (dcaMapping) {
            fadersToRender.push(dcaMapping);
          } else {
            // Create virtual DCA fader
            fadersToRender.push({
              midi: { type: 'none', channel: 1 },
              mixer: { action: 'volume', channel: { type: 'DCA', channel: dcaChannel } }
            });
          }
        } else if (faderFilter.startsWith('auto-')) {
          // Show only channels assigned to this auto-filter group
          const autoGroupChannel = parseInt(faderFilter.replace('auto-', ''));
          console.log(`[Renderer] Filter mode: Auto-filter group ${autoGroupChannel}`);

          // Get LINE channels assigned to this auto-filter group
          const assignedChannels = await ipcRenderer.invoke('get-autofilter-group-assignments', autoGroupChannel);
          console.log(`[Renderer] Auto-filter ${autoGroupChannel} assigned channels:`, assignedChannels);

          // Add assigned LINE channels
          const lineData = channelDataCache['line'] || { names: [], colors: [], icons: [], links: [], inputSources: [] };

          for (const lineChannel of assignedChannels) {
            // Skip if this is the RIGHT side of a stereo pair
            if (lineChannel % 2 === 0) {
              const prevChannelLink = lineData.links.find(c => c.channel === (lineChannel - 1));
              if (prevChannelLink?.link) {
                continue;
              }
            }

            const existingMapping = volumeMappings.find(m =>
              (m.mixer.channel.type || 'LINE') === 'LINE' &&
              (m.mixer.channel.channel || m.mixer.channel) === lineChannel
            );

            if (existingMapping) {
              fadersToRender.push(existingMapping);
            } else {
              // Create a virtual mapping with no MIDI type
              fadersToRender.push({
                midi: { type: 'none', channel: 1 },
                mixer: { action: 'volume', channel: { type: 'LINE', channel: lineChannel } }
              });
            }
          }
        } else {
          // Unknown filter mode, show mapped
          fadersToRender = volumeMappings;
        }

        console.log('[Renderer] Total fadersToRender:', fadersToRender.length);
        console.log('[Renderer] All volume mappings:', volumeMappings.length, volumeMappings.map(m => `${m.mixer.channel.type || 'LINE'}-${m.mixer.channel.channel || m.mixer.channel}`));

        // Separate channels by type for proper layout
        // Layout: LINE inputs in regular container (left side)
        // Right side (main container): DCA, SUB, AUX, FX, FXRETURN, then MAIN (from left to right)
        const lineInputs = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'LINE');
        const dcaChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'DCA');
        const subChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'SUB');
        const fxChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'FX');
        const fxReturnChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'FXRETURN');
        const auxChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'AUX');
        const mainMappings = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'MAIN');

        // Sort each group by channel number (numerically left to right)
        const sortByChannelNum = (a, b) => {
          const aNum = a.mixer.channel.channel || 0;
          const bNum = b.mixer.channel.channel || 0;
          return aNum - bNum;
        };

        lineInputs.sort(sortByChannelNum);
        dcaChannels.sort(sortByChannelNum);
        subChannels.sort(sortByChannelNum);
        fxChannels.sort(sortByChannelNum);
        fxReturnChannels.sort(sortByChannelNum);
        auxChannels.sort(sortByChannelNum);
        mainMappings.sort(sortByChannelNum);

        // Regular container: LINE only (left to right)
        const sortedRegularMappings = [...lineInputs];

        // Main container: DCA, SUB, AUX, FX, FXRETURN, then MAIN (left to right)
        const sortedMainMappings = [...dcaChannels, ...subChannels, ...auxChannels, ...fxChannels, ...fxReturnChannels, ...mainMappings];

        const container = document.getElementById('faders-container');
        const mainContainer = document.getElementById('faders-main-container');

        // Helper function to convert inputsrc number to label
        const getInputSourceLabel = (inputsrc) => {
          if (inputsrc === null || inputsrc === undefined) return 'Analog';
          switch (inputsrc) {
            case 0: return 'Analog';
            case 1: return 'Network';
            case 2: return 'USB';
            case 3: return 'SD Card';
            default: return 'Analog';
          }
        };

        // Helper function to get CSS class for input source
        const getInputSourceClass = (inputsrc) => {
          if (inputsrc === null || inputsrc === undefined) return 'source-analog';
          switch (inputsrc) {
            case 0: return 'source-analog';
            case 1: return 'source-network';
            case 2: return 'source-usb';
            case 3: return 'source-sdcard';
            default: return 'source-analog';
          }
        };

        // Render function for creating fader HTML
        const renderFader = (mapping) => {
            // Extract channel number from ChannelSelector object
            const channelType = mapping.mixer.channel.type || 'LINE';
            const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;


            // Get channel data for this type
            const channelData = channelDataCache[channelType.toLowerCase()] || { names: [], colors: [], icons: [], links: [], inputSources: [] };

            const channelInfo = channelData.names.find(c => c.channel === channelNum);
            const channelName = channelInfo ? channelInfo.name : `Ch ${channelNum}`;

            // Debug logging for SUB and DCA channels
            if (channelType === 'SUB' || channelType === 'DCA') {
              console.log(`[${channelType} Debug] Channel ${channelNum}:`, {
                channelInfo,
                channelName,
                allNames: channelData.names,
                channelDataKeys: Object.keys(channelData)
              });
            }

            const channelColorInfo = channelData.colors.find(c => c.channel === channelNum);
            // Use default grey color if mixer doesn't provide color
            let channelColor = channelColorInfo?.color || DEFAULT_COLOR;

            // Ensure channelColor is a valid string (not an object or null)
            if (typeof channelColor !== 'string' || !channelColor) {
              channelColor = DEFAULT_COLOR;
            }

            const channelIconInfo = channelData.icons.find(c => c.channel === channelNum);

            // Temporary debugging for channels 3, 9, and 10-14 to see what icon IDs the mixer reports
            if (channelType === 'LINE' && (channelNum === 3 || channelNum === 9 || (channelNum >= 10 && channelNum <= 14))) {
              console.log(`[Icon Debug] Channel ${channelNum} (${channelName}): iconId="${channelIconInfo?.icon}"`);
            }

            const channelIcon = channelIconInfo?.icon ? getIconForId(channelIconInfo.icon, channelType, channelNum) : getIconForId('', channelType, channelNum);

            // Check if channel is part of stereo pair
            const channelLinkInfo = channelData.links.find(c => c.channel === channelNum);
            const isLinked = channelLinkInfo?.link || false;

            // Get input source for this channel
            // For stereo pairs, check the RIGHT channel (channelNum + 1) to determine USB vs LINE
            const inputSourceChannel = isLinked ? channelNum + 1 : channelNum;
            const channelInputSourceInfo = channelData.inputSources?.find(c => c.channel === inputSourceChannel);

            // Debug logging for input source
            if (channelNum >= 11 && channelNum <= 14) {
              console.log(`Channel ${channelNum} (${isLinked ? 'stereo' : 'mono'}): checking inputsrc for channel ${inputSourceChannel}`, channelInputSourceInfo);
            }

            // Debug logging for FX channels
            if (channelType === 'FX') {
              console.log(`FX Channel ${channelNum}: channelData=`, channelData);
              console.log(`FX Channel ${channelNum}: inputSources=`, channelData.inputSources);
              console.log(`FX Channel ${channelNum}: channelInputSourceInfo=`, channelInputSourceInfo);
            }

            const inputSourceLabel = getInputSourceLabel(channelInputSourceInfo?.inputsrc);
            const inputSourceClass = getInputSourceClass(channelInputSourceInfo?.inputsrc);

            // Convert hex format if needed (e.g., "b2fdfcff" -> "#b2fdfc")
            if (channelColor && !channelColor.startsWith('#') && channelColor.length >= 6) {
              channelColor = '#' + channelColor.substring(0, 6);
            }

            // Override color for FX channels to match Universal Control (light purple/pink)
            if (channelType === 'FX' || channelType === 'FXRETURN') {
              channelColor = '#d4a5d4'; // Light purple/pink color
            }

            // Create unique ID that includes type and channel
            const faderId = `${channelType}-${channelNum}`;

            // Store color for this fader to preserve it across updates
            faderColors.set(faderId, channelColor);

            // Separate channel number and name for better layout
            // For stereo channels, show "11/12" format
            // Add channel type prefix for non-LINE channels
            let channelNumber;
            if (channelType === 'MAIN') {
              channelNumber = 'MAIN';
            } else if (channelType === 'LINE') {
              channelNumber = isLinked ? `${channelNum}/${channelNum + 1}` : `${channelNum}`;
            } else if (channelType === 'AUX') {
              channelNumber = `AUX ${channelNum}`;
            } else if (channelType === 'FX') {
              channelNumber = `FXB ${channelNum}`;
            } else if (channelType === 'FXRETURN') {
              // Convert channel number to letter (1=A, 2=B, 3=C, 4=D)
              const letter = String.fromCharCode(64 + channelNum); // 65 is 'A'
              channelNumber = `FXR ${letter}`;
            } else if (channelType === 'TALKBACK') {
              channelNumber = 'TALK';
            } else if (channelType === 'RETURN') {
              channelNumber = 'DigRet';
            } else if (channelType === 'SUB') {
              channelNumber = `SUB ${channelNum}`;
            } else if (channelType === 'DCA') {
              channelNumber = `DCA ${channelNum}`;
            } else {
              // Fallback for any other channel types
              channelNumber = isLinked ? `${channelNum}/${channelNum + 1}` : `${channelNum}`;
            }
            // Show name for SUB channels and other non-MAIN channels
            const channelLabel = channelType === 'MAIN' ? '' : channelName;

            // Calculate appropriate text color based on background brightness
            const textColor = getTextColorForBackground(channelColor);

            // Apply color as background of label with appropriate text color
            const labelStyle = `background: ${channelColor}; color: ${textColor};`;

            // Get MIDI mapping info ‚Äî type and channel only
            const midiInfo = mapping.midi.type === 'none'
              ? ''
              : mapping.midi.type === 'cc'
              ? `${getCCShorthand(mapping.midi.controller)} Ch${mapping.midi.channel}`
              : mapping.midi.type === 'note-value'
              ? `Note ${mapping.midi.noteMin}-${mapping.midi.noteMax} Ch${mapping.midi.channel}`
              : mapping.midi.type === 'note'
              ? `Note ${mapping.midi.note} Ch${mapping.midi.channel}`
              : '';

            // Check if this channel has MIDI mapping
            const isMapped = mapping.midi.type !== 'none';

            // Determine if this channel type can be assigned to main
            // AUX, TALKBACK, and MAIN channels cannot be assigned to main
            const canAssignToMain = !['AUX', 'TALKBACK', 'MAIN'].includes(channelType);

            // Determine if this channel type has input sources
            // LINE, FX (FX Bus), and FXRETURN (FX Return) channels have selectable input sources (LINE/USB/SD/AVB)
            const hasInputSource = ['LINE', 'FX', 'FXRETURN'].includes(channelType);

            // Debug logging for MAIN channel
            if (channelType === 'MAIN') {
              console.log(`MAIN Channel: canAssignToMain=${canAssignToMain}, hasInputSource=${hasInputSource}`);
              console.log(`MAIN Channel: Will render main spacer: ${!canAssignToMain}, Will render input spacer: ${!hasInputSource}`);
            }

            // Render stereo channels as dual L/R faders
            if (isLinked) {
              const faderIdR = `${channelType}-${channelNum + 1}`;
              return `
                <div class="fader-channel" data-fader-id="${faderId}">
                  <div class="fader-indicators" style="display: flex; flex-direction: column; gap: 2px; margin-bottom: 4px;">
                    ${canAssignToMain ? `<span class="fader-indicator main-assign unassigned" id="main-indicator-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleMainAssign('${channelType}', ${channelNum})" style="cursor: pointer;">Main</span>` : '<span class="fader-indicator main-assign" style="visibility: hidden;">Main</span>'}
                    ${hasInputSource ? `<span class="fader-indicator input-source ${inputSourceClass}" id="input-indicator-${faderId}">${inputSourceLabel}</span>` : '<span class="fader-indicator input-source" style="visibility: hidden;">LINE</span>'}
                  </div>
                  <div class="fader-controls">
                    <button class="mute-btn" id="mute-btn-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleMute('${channelType}', ${channelNum})" title="">M</button>
                    <button class="solo-btn" id="solo-btn-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleSolo('${channelType}', ${channelNum})" title="">S</button>
                  </div>
                  <div class="fader-value" id="fader-value-${faderId}">0%</div>
                  <div class="fader-wrapper">
                    <div class="fader-levels">
                      <div>10</div>
                      <div>5</div>
                      <div>0</div>
                      <div>-5</div>
                      <div>-10</div>
                      <div>-20</div>
                      <div>-30</div>
                      <div>‚àû</div>
                    </div>
                    <div class="fader-container-wrapper">
                      <div style="display: flex; gap: 2px;">
                        <div class="fader-container stereo${isMapped ? ' mapped' : ''}" data-channel="${channelNum}" data-type="${channelType}" data-fader-id="${faderId}" title="${isMapped ? 'Volume: ' + midiInfo : ''}">
                          <div class="fader-fill" id="fader-fill-${faderId}" style="height: 0%"></div>
                          <div class="fader-midi-indicator" id="fader-midi-${faderId}" style="bottom: 0%; display: none;"></div>
                        </div>
                        <div class="fader-container stereo${isMapped ? ' mapped' : ''}" data-channel="${channelNum + 1}" data-type="${channelType}" data-fader-id="${faderIdR}" title="${isMapped ? 'Volume: ' + midiInfo : ''}">
                          <div class="fader-fill" id="fader-fill-${faderIdR}" style="height: 0%"></div>
                          <div class="fader-midi-indicator" id="fader-midi-${faderIdR}" style="bottom: 0%; display: none;"></div>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="fader-icon" style="${channelIcon ? '' : 'visibility: hidden;'}">${channelIcon || 'üéµ'}</div>
                  <div class="fader-channel-number">${channelNumber}</div>
                  <div class="fader-label" style="${labelStyle}">${channelLabel}</div>
                  <div class="fader-mapping-info${isMapped ? ' mapped' : ''}" title="${isMapped ? 'Volume: ' + midiInfo : ''}">${midiInfo}</div>
                </div>
              `;
            } else {
              // Mono channel - single fader
              return `
                <div class="fader-channel" data-fader-id="${faderId}">
                  <div class="fader-indicators" style="display: flex; flex-direction: column; gap: 2px; margin-bottom: 4px;">
                    ${canAssignToMain ? `<span class="fader-indicator main-assign unassigned" id="main-indicator-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleMainAssign('${channelType}', ${channelNum})" style="cursor: pointer;">Main</span>` : '<span class="fader-indicator main-assign" style="visibility: hidden;">Main</span>'}
                    ${hasInputSource ? `<span class="fader-indicator input-source ${inputSourceClass}" id="input-indicator-${faderId}">${inputSourceLabel}</span>` : '<span class="fader-indicator input-source" style="visibility: hidden;">LINE</span>'}
                  </div>
                  <div class="fader-controls">
                    <button class="mute-btn" id="mute-btn-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleMute('${channelType}', ${channelNum})" title="">M</button>
                    <button class="solo-btn" id="solo-btn-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleSolo('${channelType}', ${channelNum})" title="">S</button>
                  </div>
                  <div class="fader-value" id="fader-value-${faderId}">0%</div>
                  <div class="fader-wrapper">
                    <div class="fader-levels">
                      <div>10</div>
                      <div>5</div>
                      <div>0</div>
                      <div>-5</div>
                      <div>-10</div>
                      <div>-20</div>
                      <div>-30</div>
                      <div>‚àû</div>
                    </div>
                    <div class="fader-container-wrapper">
                      <div class="fader-container${isMapped ? ' mapped' : ''}" data-channel="${channelNum}" data-type="${channelType}" data-fader-id="${faderId}" title="${isMapped ? 'Volume: ' + midiInfo : ''}">
                        <div class="fader-fill" id="fader-fill-${faderId}" style="height: 0%"></div>
                        <div class="fader-midi-indicator" id="fader-midi-${faderId}" style="bottom: 0%; display: none;"></div>
                      </div>
                    </div>
                  </div>
                  <div class="fader-icon" style="${channelIcon ? '' : 'visibility: hidden;'}">${channelIcon || 'üéµ'}</div>
                  <div class="fader-channel-number">${channelNumber}</div>
                  <div class="fader-label" style="${labelStyle}">${channelLabel}</div>
                  <div class="fader-mapping-info${isMapped ? ' mapped' : ''}" title="${isMapped ? 'Volume: ' + midiInfo : ''}">${midiInfo}</div>
                </div>
              `;
            }
        };

        // Debug logging
        console.log('[Renderer] Rendering faders:');
        console.log('  - lineInputs:', lineInputs.length);
        console.log('  - dcaChannels:', dcaChannels.length);
        console.log('  - subChannels:', subChannels.length);
        console.log('  - fxChannels:', fxChannels.length);
        console.log('  - fxReturnChannels:', fxReturnChannels.length);
        console.log('  - auxChannels:', auxChannels.length);
        console.log('  - mainMappings:', mainMappings.length);
        console.log('  - Regular (LINE only):', sortedRegularMappings.length, sortedRegularMappings.map(m => `${m.mixer.channel.type || 'LINE'}-${m.mixer.channel.channel || m.mixer.channel}`));
        console.log('  - Main (DCA, SUB, AUX, FX, FXRETURN, MAIN):', sortedMainMappings.length, sortedMainMappings.map(m => `${m.mixer.channel.type || 'LINE'}-${m.mixer.channel.channel || m.mixer.channel}`));

        // Render regular faders
        if (sortedRegularMappings.length === 0 && sortedMainMappings.length === 0) {
          container.innerHTML = '<div class="empty-state">No volume mappings yet. Add some mappings to see faders here.</div>';
          mainContainer.innerHTML = '';
        } else {
          container.innerHTML = sortedRegularMappings.map(renderFader).join('');
          mainContainer.innerHTML = sortedMainMappings.map(renderFader).join('');

          // Add mouse interaction to faders
          setupFaderInteraction();

          // Load initial fader positions, mute states, solo states, and main assign states from mixer
          const allMappings = [...sortedRegularMappings, ...sortedMainMappings];
          loadInitialFaderPositions(allMappings);
          loadInitialMuteStates(allMappings);
          loadInitialSoloStates(allMappings);
          loadInitialMainAssignStates(allMappings);

          // Update mute/solo button tooltips and mapped indicators
          updateMuteSoloMappingIndicators(allMappings);
        }

        // Load mute groups (after mappings are loaded)
        loadMuteGroups();

        updateStatusInit('Ready');
      } catch (error) {
        console.error('[Renderer] Error in loadFaders:', error);
        const errorMsg = `Error: ${error.message || 'Failed to load faders'}`;
        updateStatusInit(errorMsg);
        addStatusLog(errorMsg, 'error');
      } finally {
        isLoadingFaders = false;
      }
    }

    // Load initial fader positions from the mixer
    async function loadInitialFaderPositions(volumeMappings) {
      for (const mapping of volumeMappings) {
        try {
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          const channelType = mapping.mixer.channel.type || 'LINE';
          const level = await ipcRenderer.invoke('get-mixer-level', channelType, channelNum);
          if (level !== null) {
            updateFaderByValue(channelType, channelNum, level);
          }

          // For stereo channels, set the right channel to match the left channel initially
          const isLinked = await ipcRenderer.invoke('get-channel-link', channelType, channelNum);
          if (isLinked) {
            if (channelNum >= 11 && channelNum <= 14) {
              console.log(`[Renderer] Loading initial position for stereo pair ${channelNum}/${channelNum + 1}: L=${level}%`);
            }
            // Force update the right channel fader to match left channel
            if (level !== null) {
              const faderIdR = `${channelType}-${channelNum + 1}`;
              const faderFillR = document.getElementById(`fader-fill-${faderIdR}`);

              if (faderFillR) {
                const roundedPercentage = Math.round(level);
                faderFillR.style.transition = 'none'; // No transition for initial load
                faderFillR.style.height = `${roundedPercentage}%`;

                if (channelNum >= 11 && channelNum <= 14) {
                  console.log(`[Renderer] Set R channel ${channelNum + 1} to ${roundedPercentage}%`);
                }
              } else {
                if (channelNum >= 11 && channelNum <= 14) {
                  console.log(`[Renderer] ERROR: Could not find fader-fill-${faderIdR}`);
                }
              }
            }
          }
        } catch (error) {
          console.error('[Renderer] Error loading initial fader position:', error);
        }
      }
    }

    // Load initial mute states from the mixer
    async function loadInitialMuteStates(volumeMappings) {
      for (const mapping of volumeMappings) {
        try {
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          const channelType = mapping.mixer.channel.type || 'LINE';
          const muted = await ipcRenderer.invoke('get-channel-mute', channelType, channelNum);
          if (muted !== null) {
            updateMuteButton(channelType, channelNum, muted);
          }
        } catch (error) {
          // Silent error handling
        }
      }
    }

    // Load initial solo states from the mixer
    async function loadInitialSoloStates(volumeMappings) {
      for (const mapping of volumeMappings) {
        try {
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          const channelType = mapping.mixer.channel.type || 'LINE';
          const soloed = await ipcRenderer.invoke('get-channel-solo', channelType, channelNum);
          if (soloed !== null) {
            updateSoloButton(channelType, channelNum, soloed);
          }
        } catch (error) {
          // Silent error handling
        }
      }
    }

    // Update mute and solo button tooltips and mapped classes based on MIDI mappings
    function updateMuteSoloMappingIndicators(volumeMappings) {
      for (const mapping of volumeMappings) {
        const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
        const channelType = mapping.mixer.channel.type || 'LINE';
        const faderId = `${channelType}-${channelNum}`;

        // Check for mute mapping
        const muteMapping = currentMappings.find(m =>
          m.mixer.action === 'mute' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        // Check for solo mapping
        const soloMapping = currentMappings.find(m =>
          m.mixer.action === 'solo' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        // Update mute button
        const muteBtn = document.getElementById(`mute-btn-${faderId}`);
        if (muteBtn) {
          if (muteMapping) {
            muteBtn.classList.add('mapped');
            const midiInfo = muteMapping.midi.type === 'cc'
              ? `CC${muteMapping.midi.controller} Ch${muteMapping.midi.channel}`
              : `Note ${muteMapping.midi.note} Ch${muteMapping.midi.channel}`;
            muteBtn.title = `Mute: ${midiInfo}`;
          } else {
            muteBtn.classList.remove('mapped');
            muteBtn.title = '';
          }
        }

        // Update solo button
        const soloBtn = document.getElementById(`solo-btn-${faderId}`);
        if (soloBtn) {
          if (soloMapping) {
            soloBtn.classList.add('mapped');
            const midiInfo = soloMapping.midi.type === 'cc'
              ? `CC${soloMapping.midi.controller} Ch${soloMapping.midi.channel}`
              : `Note ${soloMapping.midi.note} Ch${soloMapping.midi.channel}`;
            soloBtn.title = `Solo: ${midiInfo}`;
          } else {
            soloBtn.classList.remove('mapped');
            soloBtn.title = '';
          }
        }
      }
    }

    // Load initial main assign states from the mixer
    async function loadInitialMainAssignStates(volumeMappings) {
      console.log('[Renderer] Loading initial main assign states...');
      for (const mapping of volumeMappings) {
        try {
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          const channelType = mapping.mixer.channel.type || 'LINE';
          const mainAssigned = await ipcRenderer.invoke('get-channel-main-assign', channelType, channelNum);
          console.log(`[Renderer] Channel ${channelType}-${channelNum}: mainAssigned=${mainAssigned}`);
          if (mainAssigned !== null) {
            updateMainAssignIndicator(channelType, channelNum, mainAssigned);
          }
        } catch (error) {
          console.error(`[Renderer] Error loading main assign for ${channelType}-${channelNum}:`, error);
        }
      }
    }

    // Toggle main assign for a channel
    async function toggleMainAssign(type, channel) {
      try {
        // For now, just log - we'll need to add the IPC handler
        console.log(`[Renderer] Toggle main assign requested for ${type}-${channel}`);
        const currentState = await ipcRenderer.invoke('get-channel-main-assign', type, channel);
        console.log(`[Renderer] Current main assign state: ${currentState}`);
        // TODO: Add toggle-main-assign IPC handler
      } catch (error) {
        console.error(`[Renderer] Error toggling main assign:`, error);
      }
    }

    // Update main assign indicator visibility
    function updateMainAssignIndicator(channelType, channelNum, isAssigned) {
      const faderId = `${channelType}-${channelNum}`;
      const indicator = document.getElementById(`main-indicator-${faderId}`);
      if (indicator) {
        if (isAssigned) {
          indicator.classList.remove('unassigned');
          indicator.classList.add('assigned');
        } else {
          indicator.classList.remove('assigned');
          indicator.classList.add('unassigned');
        }
      }
    }

    // Update input source indicator
    function updateInputSourceIndicator(channelType, channelNum, inputSrc) {
      console.log('[UI] updateInputSourceIndicator called:', channelType, channelNum, inputSrc);
      const faderId = `${channelType}-${channelNum}`;
      console.log('[UI] Looking for element:', `input-indicator-${faderId}`);
      const indicator = document.getElementById(`input-indicator-${faderId}`);
      console.log('[UI] Found indicator:', indicator);
      if (indicator) {
        // Remove all source classes
        indicator.classList.remove('source-analog', 'source-network', 'source-usb', 'source-sdcard');

        // Determine label and class based on inputSrc value
        let label = 'Analog';
        let cssClass = 'source-analog';

        if (inputSrc !== null && inputSrc !== undefined) {
          switch (inputSrc) {
            case 0:
              label = 'Analog';
              cssClass = 'source-analog';
              break;
            case 1:
              label = 'Network';
              cssClass = 'source-network';
              break;
            case 2:
              label = 'USB';
              cssClass = 'source-usb';
              break;
            case 3:
              label = 'SD Card';
              cssClass = 'source-sdcard';
              break;
          }
        }

        // Update the indicator
        indicator.textContent = label;
        indicator.classList.add(cssClass);
      }
    }

    // Update channel icon
    function updateChannelIcon(channelType, channelNum, iconId) {
      const faderId = `${channelType}-${channelNum}`;
      const iconElement = document.querySelector(`[data-fader-id="${faderId}"] .fader-icon`);
      if (iconElement) {
        // Map icon ID to emoji (same mapping as in loadFaders)
        const iconMap = {
          0: 'üé§', 1: 'üé∏', 2: 'üéπ', 3: 'ü•Å', 4: 'üé∫', 5: 'üéª',
          6: 'üéµ', 7: 'üé∂', 8: 'üîä', 9: 'üéß', 10: 'üìª', 11: 'üéôÔ∏è'
        };
        const icon = iconMap[iconId] || 'üéµ';
        iconElement.textContent = icon;
        iconElement.style.visibility = 'visible';
      }
    }

    // Update channel name
    function updateChannelName(channelType, channelNum, name) {
      const faderId = `${channelType}-${channelNum}`;
      const labelElement = document.querySelector(`[data-fader-id="${faderId}"] .fader-label`);
      if (labelElement) {
        labelElement.textContent = name || '';
      }
    }

    // Toggle mute for a channel
    async function toggleMute(type, channel) {
      try {
        const result = await ipcRenderer.invoke('toggle-mute', type, channel);
        if (result.success) {
          // Get the new state and update the button
          const muted = await ipcRenderer.invoke('get-channel-mute', type, channel);
          if (muted !== null) {
            updateMuteButton(type, channel, muted);
          }
        }
      } catch (error) {
        // Silent error handling
      }
    }

    // Update mute button visual state
    function updateMuteButton(channelType, channelNum, muted) {
      const faderId = `${channelType}-${channelNum}`;
      const muteBtn = document.getElementById(`mute-btn-${faderId}`);
      console.log(`[updateMuteButton] ${channelType}${channelNum}: faderId=${faderId}, button=${!!muteBtn}, muted=${muted}`);
      if (muteBtn) {
        if (muted) {
          muteBtn.classList.add('active');
        } else {
          muteBtn.classList.remove('active');
        }
        console.log(`[updateMuteButton] Updated button classes:`, muteBtn.classList.toString());
      }
    }

    // Toggle solo for a channel
    async function toggleSolo(type, channel) {
      try {
        const result = await ipcRenderer.invoke('toggle-solo', type, channel);
        if (result.success) {
          // Get the new state and update the button
          const soloed = await ipcRenderer.invoke('get-channel-solo', type, channel);
          if (soloed !== null) {
            updateSoloButton(type, channel, soloed);
          }
        }
      } catch (error) {
        // Silent error handling
      }
    }

    // Update solo button visual state
    function updateSoloButton(channelType, channelNum, soloed) {
      const faderId = `${channelType}-${channelNum}`;
      const soloBtn = document.getElementById(`solo-btn-${faderId}`);
      if (soloBtn) {
        if (soloed) {
          soloBtn.classList.add('active');
        } else {
          soloBtn.classList.remove('active');
        }
      }
    }

    // Setup fader mouse interaction
    function setupFaderInteraction() {
      const faderContainers = document.querySelectorAll('.fader-container');

      faderContainers.forEach(container => {
        let isDragging = false;
        let channel = parseInt(container.getAttribute('data-channel'));
        const channelType = container.getAttribute('data-type') || 'LINE';
        const faderId = container.getAttribute('data-fader-id');

        const updateFaderFromMouse = async (e) => {
          const rect = container.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const height = rect.height;

          // Calculate percentage (inverted because 0 is at top, 100 at bottom)
          let percentage = Math.max(0, Math.min(100, ((height - y) / height) * 100));

          // Check if this channel is the RIGHT side of a stereo pair
          // If so, we need to use the LEFT channel as the primary channel
          let primaryChannel = channel;
          let isRightChannel = false;

          if (channel % 2 === 0) {
            // Even channel - might be the right side of a stereo pair
            const leftChannelLink = await ipcRenderer.invoke('get-channel-link', channelType, channel - 1);
            if (leftChannelLink) {
              // This is the right channel of a stereo pair, use the left channel as primary
              primaryChannel = channel - 1;
              isRightChannel = true;
            }
          }

          // Update both faders in the stereo pair
          const faderIdL = `${channelType}-${primaryChannel}`;
          const faderIdR = `${channelType}-${primaryChannel + 1}`;

          // Update left fader UI
          const fillL = document.getElementById(`fader-fill-${faderIdL}`);
          const valueDisplayL = document.getElementById(`fader-value-${faderIdL}`);
          if (fillL && valueDisplayL) {
            fillL.style.height = `${percentage}%`;
            valueDisplayL.textContent = `${Math.round(percentage)}%`;
          }

          // Send to mixer for left channel
          ipcRenderer.invoke('set-mixer-volume', channelType, primaryChannel, percentage).catch(err => {
            // Silent error handling
          });

          // Check if this is a stereo pair and update the right channel too
          const isLinked = await ipcRenderer.invoke('get-channel-link', channelType, primaryChannel);
          if (isLinked) {
            const fillR = document.getElementById(`fader-fill-${faderIdR}`);
            if (fillR) {
              fillR.style.height = `${percentage}%`;
            }
            // Send to mixer for right channel
            ipcRenderer.invoke('set-mixer-volume', channelType, primaryChannel + 1, percentage).catch(err => {
              // Silent error handling
            });
          }

          // Indicate UI change
          indicateFaderChange(channelType, primaryChannel, 'ui');
        };

        container.addEventListener('mousedown', (e) => {
          isDragging = true;
          container.classList.add('dragging');
          updateFaderFromMouse(e);
          e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
          if (isDragging) {
            updateFaderFromMouse(e);
          }
        });

        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            container.classList.remove('dragging');
          }
        });
      });

      // Add click handler for selection and editing
      const faderChannels = document.querySelectorAll('.fader-channel');
      faderChannels.forEach(channel => {
        // Single click to select (only on background, not on interactive elements)
        channel.addEventListener('click', (e) => {
          // Don't select if clicking on interactive elements
          if (e.target.closest('.fader-container') ||
              e.target.closest('.mute-btn') ||
              e.target.closest('.solo-btn') ||
              e.target.closest('.fader-label') ||
              e.target.closest('.fader-icon') ||
              e.target.closest('.fader-value') ||
              e.target.closest('.fader-mapping-info')) {
            return;
          }
          channel.classList.toggle('selected');
          e.stopPropagation();
        });

        // Double click to edit
        channel.addEventListener('dblclick', (e) => {
          const faderId = channel.getAttribute('data-fader-id');
          editFaderMapping(faderId);
          e.stopPropagation();
        });

        // Right click for context menu on channel background
        channel.addEventListener('contextmenu', (e) => {
          // Check if clicking on specific elements
          if (e.target.closest('.fader-container')) {
            // Right-click on fader slider - show fader volume menu
            e.preventDefault();
            const faderId = channel.getAttribute('data-fader-id');
            showFaderVolumeContextMenu(faderId, e.clientX, e.clientY);
            return;
          }

          if (e.target.closest('.mute-btn')) {
            // Right-click on mute button - show mute menu
            e.preventDefault();
            const faderId = channel.getAttribute('data-fader-id');
            showMuteContextMenu(faderId, e.clientX, e.clientY);
            return;
          }

          if (e.target.closest('.solo-btn')) {
            // Right-click on solo button - show solo menu
            e.preventDefault();
            const faderId = channel.getAttribute('data-fader-id');
            showSoloContextMenu(faderId, e.clientX, e.clientY);
            return;
          }

          // Right-click on channel background - show channel menu
          e.preventDefault();
          const faderId = channel.getAttribute('data-fader-id');
          showChannelContextMenu(faderId, e.clientX, e.clientY);
        });
      });
    }

    // Update status
    async function updateStatus() {
      try {
        const mixerStatus = await ipcRenderer.invoke('get-mixer-status');
        const midiStatus = await ipcRenderer.invoke('get-midi-status');
        const currentPreset = await ipcRenderer.invoke('get-current-preset');

        // Update mixer status (sidebar) - only if elements exist
        const mixerIndicator = document.getElementById('mixer-status');
        const mixerStatusText = document.getElementById('mixer-status-text');
        const mixerIp = document.getElementById('mixer-ip');

        // Track previous connection state to detect changes
        const wasConnected = window.previousMixerConnected || false;
        const isNowConnected = mixerStatus.connected;

        if (mixerIndicator && mixerStatusText && mixerIp) {
          if (mixerStatus.connected) {
            mixerIndicator.classList.add('connected');
            mixerStatusText.textContent = 'Connected';
            mixerIp.textContent = mixerStatus.ip || '‚Äî';
          } else {
            mixerIndicator.classList.remove('connected');
            mixerStatusText.textContent = 'Disconnected';
            mixerIp.textContent = '‚Äî';
          }
        }

        // Update mixer status (header and status bar)
        const mixerStatusDot = document.getElementById('mixer-status-dot');
        const mixerStatusShort = document.getElementById('mixer-status-short');
        const statusMixer = document.getElementById('status-mixer');

        if (mixerStatusDot) {
          if (mixerStatus.connected) {
            mixerStatusDot.classList.add('connected');
            // Show {deviceName} if defined, else {model}
            const displayName = mixerStatus.deviceName || mixerStatus.model || mixerStatus.name || mixerStatus.ip || 'Mixer';
            if (mixerStatusShort) mixerStatusShort.textContent = displayName;

            // Update tooltip with all three fields
            const mixerConnectionEl = document.getElementById('mixer-connection-status');
            if (mixerConnectionEl) {
              const tooltipParts = [`IP: ${mixerStatus.ip || 'Unknown'}`];
              if (mixerStatus.model) tooltipParts.push(`Model: ${mixerStatus.model}`);
              if (mixerStatus.deviceName) tooltipParts.push(`Device Name: ${mixerStatus.deviceName}`);
              tooltipParts.push('Click to open connection panel');
              mixerConnectionEl.title = tooltipParts.join('\n');
            }

            if (statusMixer) {
              statusMixer.textContent = displayName;
              statusMixer.classList.add('connected');
              statusMixer.classList.remove('disconnected');
            }
          } else {
            mixerStatusDot.classList.remove('connected');
            if (mixerStatusShort) mixerStatusShort.textContent = 'Mixer';

            // Update tooltip
            const mixerConnectionEl = document.getElementById('mixer-connection-status');
            if (mixerConnectionEl) {
              mixerConnectionEl.title = 'Mixer: Disconnected\nClick to open connection panel';
            }

            if (statusMixer) {
              statusMixer.textContent = 'Disconnected';
              statusMixer.classList.remove('connected');
              statusMixer.classList.add('disconnected');
            }
          }
        }

        // If mixer just connected, reload faders and mappings to get channel names
        // Note: mixer-state-ready event will also trigger loadFaders, but our duplicate
        // prevention flag will ensure it only runs once
        if (!wasConnected && isNowConnected) {
          console.log('[Renderer] Mixer just connected, loadFaders will be called by mixer-state-ready event');
          // Don't call loadFaders here - let mixer-state-ready handle it
          loadMappings();
        }

        // Update previous state
        window.previousMixerConnected = isNowConnected;

        // Update MIDI status (sidebar) - only if elements exist
        const midiIndicator = document.getElementById('midi-status');
        const midiStatusText = document.getElementById('midi-status-text');
        const midiDevice = document.getElementById('midi-device');

        if (midiIndicator && midiStatusText && midiDevice) {
          if (midiStatus.connected) {
            midiIndicator.classList.add('connected');
            midiStatusText.textContent = 'Connected';
            midiDevice.textContent = midiStatus.device || '‚Äî';
          } else {
            midiIndicator.classList.remove('connected');
            midiStatusText.textContent = 'Disconnected';
            midiDevice.textContent = '‚Äî';
          }
        }

        // Update MIDI status (header and status bar)
        const midiStatusDot = document.getElementById('midi-status-dot');
        const midiStatusShort = document.getElementById('midi-status-short');
        const statusMidi = document.getElementById('status-midi');

        if (midiStatusDot) {
          const connectedDevices = midiStatus.devices || (midiStatus.device ? [midiStatus.device] : []);
          if (midiStatus.connected && connectedDevices.length > 0) {
            midiStatusDot.classList.add('connected');

            let shortLabel;
            if (connectedDevices.length === 1) {
              shortLabel = shortenMidiDeviceName(connectedDevices[0]);
            } else {
              shortLabel = `${connectedDevices.length} MIDI`;
            }
            if (midiStatusShort) midiStatusShort.textContent = shortLabel || 'MIDI';

            // Update tooltip listing all connected devices
            const midiConnectionEl = document.getElementById('midi-connection-status');
            if (midiConnectionEl) {
              const deviceList = connectedDevices.map(d => `  ‚Ä¢ ${shortenMidiDeviceName(d)}`).join('\n');
              midiConnectionEl.title = `MIDI Devices:\n${deviceList}\nClick to manage connections`;
            }

            if (statusMidi) {
              statusMidi.textContent = shortLabel || 'Connected';
              statusMidi.classList.add('connected');
              statusMidi.classList.remove('disconnected');
            }
          } else {
            midiStatusDot.classList.remove('connected');
            if (midiStatusShort) midiStatusShort.textContent = 'MIDI';

            const midiConnectionEl = document.getElementById('midi-connection-status');
            if (midiConnectionEl) {
              midiConnectionEl.title = 'MIDI: Disconnected\nClick to open connection panel';
            }

            if (statusMidi) {
              statusMidi.textContent = 'Disconnected';
              statusMidi.classList.remove('connected');
              statusMidi.classList.add('disconnected');
            }
          }
        }

        // Update preset in sidebar and status bar
        document.getElementById('current-preset').textContent = currentPreset || 'None';
        updateStatusProfile(currentPreset);
      } catch (error) {
        // Silent error handling
      }
    }

    // Load initial state
    async function loadInitialState() {
      console.log('[Renderer] loadInitialState() called');
      try {
        // Check if there's a preferred mixer IP
        const preferredIp = await ipcRenderer.invoke('get-preferred-mixer-ip');

        if (preferredIp) {
          // Try to connect to preferred mixer first
          console.log(`[Renderer] Found preferred mixer IP: ${preferredIp}`);
          await updateStatusInitWithDelay(`Connecting to preferred mixer ${preferredIp}...`);

          const result = await ipcRenderer.invoke('connect-mixer', preferredIp);
          if (result.success) {
            console.log(`[Renderer] Successfully connected to preferred mixer`);

            // Connection successful, skip discovery
            // Don't show mixer name here - it's not ready yet
            // The mixer-state-ready event will show the proper name
            await updateStatusInitWithDelay('Loading preset...');
            updateStatus();

            // Don't call loadMappings or loadFaders here - the mixer-state-ready event will handle both
            // This prevents duplicate loading
            console.log('[Renderer] Waiting for mixer-state-ready event to trigger loadMappings and loadFaders...');
            return;
          } else {
            console.log(`[Renderer] Failed to connect to preferred mixer: ${result.error}`);
            addStatusLog(`Failed to connect to preferred mixer ${preferredIp}: ${result.error}`, 'warning');
          }
        }

        // No preferred mixer or connection failed, do discovery
        console.log('[Renderer] About to call updateStatusInitWithDelay...');
        await updateStatusInitWithDelay('Discovering mixers...');
        console.log('[Renderer] updateStatusInitWithDelay completed');

        const mixers = await ipcRenderer.invoke('get-discovered-mixers');
        const listEl = document.getElementById('mixer-list');

        if (mixers.length > 0) {
          listEl.innerHTML = mixers.map(mixer => {
            // Format display: IP {model} {deviceName}
            const displayName = `${mixer.ip} ${mixer.model || mixer.name}${mixer.deviceName ? ' ' + mixer.deviceName : ''}`;
            // Tooltip: Show all three fields
            const tooltip = `IP: ${mixer.ip}\\nModel: ${mixer.model || mixer.name}${mixer.deviceName ? '\\nDevice Name: ' + mixer.deviceName : ''}\\nSerial: ${mixer.serial}`;

            return `
            <div class="mixer-item" title="${tooltip}">
              <div class="mixer-info">
                <div class="mixer-name">${displayName}</div>
                <div class="mixer-details">Serial: ${mixer.serial}</div>
              </div>
              <button class="btn" onclick="connectToMixer('${mixer.ip}', '${mixer.model || mixer.name}', '${mixer.deviceName || ''}')">Connect</button>
            </div>
          `}).join('');
        }

        await updateStatusInitWithDelay('Loading preset...');
      } catch (error) {
        console.error('[Renderer] Error in loadInitialState:', error);
        const errorMsg = `Initialization failed: ${error.message || error}`;
        updateStatusInit(errorMsg);
        addStatusLog(errorMsg, 'error');
      }

      updateStatus();

      // Note: Don't call loadMappings() or loadFaders() here
      // If we connected to a preferred mixer, we already returned early (line 4555)
      // If we're here, it means no preferred mixer or discovery mode
      // The mixer-state-ready event will handle loading when a mixer connects

      updateStatusInit('Ready');

      // Check for updates (non-blocking)
      checkForUpdates().catch(err => {
        console.error('[Renderer] Update check failed:', err);
      });
    }

    // Update status every 2 seconds
    setInterval(updateStatus, 2000);

    // Hide context menus when clicking elsewhere
    document.addEventListener('click', (e) => {
      const faderMenu = document.getElementById('fader-context-menu');
      const muteMenu = document.getElementById('mute-context-menu');
      const soloMenu = document.getElementById('solo-context-menu');
      const channelMenu = document.getElementById('channel-context-menu');
      const muteGroupMenu = document.getElementById('mutegroup-context-menu');

      if (faderMenu && !faderMenu.contains(e.target) &&
          muteMenu && !muteMenu.contains(e.target) &&
          soloMenu && !soloMenu.contains(e.target) &&
          channelMenu && !channelMenu.contains(e.target) &&
          muteGroupMenu && !muteGroupMenu.contains(e.target)) {
        hideAllContextMenus();
      }
    });

    // Load initial state when page loads
    console.log('[Renderer] About to call loadInitialState()...');
    loadInitialState();
    console.log('[Renderer] Script loaded successfully');
  </script>
</body>
</html>

