<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StudioLive MIDI Controller</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden; /* status-bar is position:fixed; no document scroll needed */
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif;
      background: #0d0d0d;
      color: #e0e0e0;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: 100%;
      margin: 0;
      padding: 15px;
    }

    /* Header with activity indicators */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 10px 15px;
      background: rgba(20, 20, 20, 0.8);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    h1 {
      font-size: 1.5rem;
      color: #e0e0e0;
      font-weight: 600;
    }

    .mix-page-badge {
      background: rgba(74, 155, 127, 0.2);
      border: 1px solid #4a9b7f;
      color: #4a9b7f;
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    /* Top right status indicators */
    .header-right {
      display: flex;
      align-items: center;
      gap: 15px;
      font-size: 0.85rem;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(30, 30, 30, 0.6);
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .connection-status:hover {
      background: rgba(40, 40, 40, 0.8);
    }

    .connection-status.device-warning {
      background: repeating-linear-gradient(
        45deg,
        rgba(160, 0, 0, 0.55),
        rgba(160, 0, 0, 0.55) 5px,
        rgba(10, 10, 10, 0.55) 5px,
        rgba(10, 10, 10, 0.55) 10px
      );
    }

    .connection-status.device-warning:hover {
      background: repeating-linear-gradient(
        45deg,
        rgba(180, 0, 0, 0.7),
        rgba(180, 0, 0, 0.7) 5px,
        rgba(20, 20, 20, 0.7) 5px,
        rgba(20, 20, 20, 0.7) 10px
      );
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
    }

    .status-dot.connected {
      background: #4a9b7f;
      box-shadow: 0 0 8px rgba(74, 155, 127, 0.6);
    }

    .status-dot.configured {
      background: #c0392b;
      box-shadow: 0 0 8px rgba(192, 57, 43, 0.6);
    }

    .activity-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .activity-indicator.active {
      box-shadow: 0 0 8px currentColor;
    }

    .activity-indicator.active.midi { background: #5b9bd5; }
    .activity-indicator.active.mixer { background: #d97c4e; }

    /* Main layout */
    .main-layout {
      display: block;
      position: relative;
    }

    /* Collapsible Sidebar */
    .sidebar {
      position: fixed;
      left: -320px;
      top: 0;
      bottom: 50px; /* Above status bar */
      width: 320px;
      background: rgba(15, 15, 15, 0.98);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      transition: left 0.3s ease;
      z-index: 1000;
      overflow-y: auto;
      padding: 80px 15px 15px 15px; /* Top padding for header */
    }

    .sidebar.open {
      left: 0;
    }

    .sidebar-toggle {
      position: fixed;
      left: 10px;
      top: 80px;
      width: 40px;
      height: 40px;
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
      transition: all 0.2s;
      color: #e0e0e0;
    }

    .sidebar-toggle:hover {
      background: rgba(40, 40, 40, 0.9);
      border-color: #4a9b7f;
    }

    .sidebar.open + .sidebar-toggle {
      left: 330px;
    }

    .status-card {
      background: rgba(30, 30, 30, 0.6);
      border-radius: 8px;
      padding: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 15px;
    }

    .status-card h2 {
      font-size: 1rem;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      color: #b0b0b0;
      font-weight: 600;
    }

    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff4444;
      box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
    }

    .status-indicator.connected {
      background: #4a9b7f;
      box-shadow: 0 0 10px rgba(74, 155, 127, 0.5);
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 0.85rem;
    }

    .info-row:last-child {
      border-bottom: none;
    }

    .info-label {
      color: #888;
    }

    .info-value {
      font-weight: 500;
      color: #e0e0e0;
    }

    .btn {
      background: rgba(74, 155, 127, 0.2);
      border: 1px solid rgba(74, 155, 127, 0.4);
      color: #4a9b7f;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      width: 100%;
      margin-top: 10px;
      font-weight: 500;
    }

    .btn:hover {
      background: rgba(74, 155, 127, 0.3);
      border-color: #4a9b7f;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 0;
    }

    .tab {
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: #888;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      font-weight: 500;
    }

    .tab:hover {
      color: #b0b0b0;
      border-bottom-color: rgba(74, 155, 127, 0.3);
    }

    .tab.active {
      color: #4a9b7f;
      border-bottom-color: #4a9b7f;
    }

    .tab-content {
      display: none;
      flex: 1;
      overflow: hidden;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    /* Content area */
    .content-area {
      background: rgba(20, 20, 20, 0.4);
      border-radius: 8px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      flex-direction: column;
      height: calc(100vh - 130px); /* Full height minus header and status bar */
    }

    /* Faders view */
    #faders-view {
      display: flex;
      flex-direction: column;
    }

    .faders-toolbar {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
      padding: 6px 8px;
      background: rgba(30, 30, 30, 0.5);
      border-radius: 6px;
      flex-wrap: nowrap;
      align-items: center;
      overflow-x: auto;
    }

    .faders-toolbar .btn {
      margin: 0;
      padding: 5px 10px;
      font-size: 0.75rem;
      width: auto;
      white-space: nowrap;
    }

    .toolbar-spacer {
      flex: 1;
      min-width: 10px;
    }

    .mute-groups {
      display: flex;
      gap: 4px;
      align-items: center;
      margin-left: auto;
    }

    .mute-group-btn {
      min-width: 38px;
      padding: 5px 8px;
      font-size: 0.7rem;
      font-weight: bold;
      background: rgba(60, 60, 60, 0.8);
      border: 2px solid #555;
      transition: all 0.2s ease;
      position: relative;
    }

    .mute-group-btn:hover {
      background: rgba(80, 80, 80, 0.9);
      border-color: #777;
    }

    .mute-group-btn.active {
      background: #d32f2f;
      border-color: #f44336;
      color: #fff;
      box-shadow: 0 0 8px rgba(211, 47, 47, 0.6);
    }

    .mute-group-btn.active:hover {
      background: #f44336;
      border-color: #ff5252;
    }

    .mute-group-btn.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .mute-group-btn.active.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 8px rgba(211, 47, 47, 0.6), 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .mute-group-btn .midi-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 6px;
      height: 6px;
      background: #4CAF50;
      border-radius: 50%;
    }

    .faders-grid {
      display: flex;
      gap: 6px;
      flex: 1;
      align-items: stretch;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 10px;
      position: relative;
    }

    .faders-scrollable {
      display: flex;
      gap: 6px;
      align-items: stretch;
      flex: 1 1 0;
      overflow-x: auto;
      overflow-y: hidden;
      min-width: 0;
      flex-wrap: nowrap;
      justify-content: flex-end;
    }

    /* Spacer before channels so they right-justify; shrinks away when channels overflow */
    .faders-scrollable::before {
      content: '';
      display: block;
      flex: 1 1 0;
      min-width: 0;
    }

    .faders-main {
      display: flex;
      gap: 6px;
      align-items: stretch;
      padding-left: 12px;
      border-left: 2px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
      width: auto;
    }

    .fader-channel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      background: rgba(80, 80, 80, 0.8);
      padding: 6px 4px;
      border-radius: 4px;
      min-width: 65px;
      max-width: 75px;
      flex-shrink: 0;
      height: 100%;
      transition: box-shadow 0.3s ease;
    }

    /* Change source indicators */
    .fader-channel.change-midi {
      box-shadow: 0 0 12px rgba(91, 155, 213, 0.6);
    }

    .fader-channel.change-api {
      box-shadow: 0 0 12px rgba(217, 124, 78, 0.6);
    }

    .fader-channel.change-ui {
      box-shadow: 0 0 12px rgba(74, 155, 127, 0.6);
    }

    .fader-channel.selected {
      box-shadow: 0 0 16px rgba(91, 155, 213, 0.8);
      outline: 2px solid rgba(91, 155, 213, 0.6);
      outline-offset: 2px;
    }

    .fader-value {
      font-size: 0.65rem;
      font-weight: 600;
      color: #b0b0b0;
      min-height: 14px;
    }

    .fader-indicators {
      display: flex;
      gap: 3px;
      justify-content: center;
      margin-bottom: 2px;
      min-height: 24px;
    }

    .fader-indicator {
      font-size: 0.5rem;
      font-weight: bold;
      padding: 1px 3px;
      border-radius: 2px;
      line-height: 1;
    }

    .fader-indicator.main-assign {
      font-size: 0.65rem;
      font-weight: 600;
      padding: 3px 6px;
      border-radius: 3px;
      min-height: 18px;
      min-width: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 45px;
    }

    .fader-indicator.main-assign.assigned {
      background: rgba(210, 180, 140, 0.9); /* Tan */
      color: #333;
    }

    .fader-indicator.main-assign.unassigned {
      background: rgba(100, 100, 100, 0.6); /* Grey */
      color: #e0e0e0;
    }

    .fader-indicator.input-source {
      background: rgba(100, 100, 100, 0.6);
      color: #e0e0e0;
      padding: 2px 4px;
      border-radius: 3px;
      min-height: 28px;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fader-indicator.input-source svg {
      display: block;
      flex-shrink: 0;
      width: 24px;
      height: 24px;
    }

    .fader-indicator.input-source.source-analog {
      background: rgba(76, 175, 80, 0.35);
      color: #fff;
    }

    .fader-indicator.input-source.source-network {
      background: rgba(156, 39, 176, 0.35);
      color: #fff;
    }

    .fader-indicator.input-source.source-usb {
      background: rgba(33, 150, 243, 0.35);
      color: #fff;
    }

    .fader-indicator.input-source.source-sdcard {
      background: rgba(255, 152, 0, 0.35);
      color: #fff;
    }

    .fader-icon {
      font-size: 1.6rem;
      text-align: center;
      padding: 2px 0;
      width: 100%;
      min-height: 30px; /* Fixed height to ensure consistent alignment */
    }

    .fader-channel-number {
      font-size: 1rem;
      font-weight: bold;
      text-align: center;
      color: #e0e0e0;
      padding: 2px 0;
      width: 100%;
      min-height: 20px;
    }

    .fader-label {
      font-size: 0.65rem;
      font-weight: 600;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.1;
      padding: 3px 4px;
      border-radius: 3px;
      width: 100%;
      min-height: 18px; /* Fixed height to ensure consistent alignment */
      /* Color will be set inline based on background brightness */
    }

    .fader-mapping-info {
      font-size: 0.65rem;
      font-weight: 600;
      color: #ffffff;
      text-align: center;
      padding: 3px 5px;
      line-height: 1.2;
      width: 100%;
      min-height: 18px; /* Fixed height ensures all faders stay same height */
      background: rgba(0, 0, 0, 0.3);
      border-radius: 3px;
      opacity: 0.95;
      border: 1px solid transparent;
      transition: all 0.2s;
      margin-top: 6px; /* Gap makes clear this is a mapping, not channel info */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      box-sizing: border-box;
    }

    .fader-mapping-info.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    @keyframes missing-device-pulse {
      0%, 100% { border-color: #ff4444; }
      50%       { border-color: #ffffff; }
    }

    .fader-mapping-info.device-missing,
    .fader-container.device-missing {
      border-style: dashed !important;
      border-color: #ff4444 !important;
      box-shadow: none !important;
      animation: missing-device-pulse 1.2s ease-in-out infinite;
    }

    .mute-btn {
      width: 28px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background: rgba(30, 30, 30, 0.6);
      color: rgba(255, 255, 255, 0.5);
      border-radius: 3px;
      font-size: 0.65rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      padding: 0;
    }

    .mute-btn:hover {
      background: rgba(50, 50, 50, 0.8);
      border-color: rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 0.8);
    }

    .mute-btn.active {
      background: #c74a3a;
      border-color: #c74a3a;
      color: #fff;
      box-shadow: 0 0 8px rgba(199, 74, 58, 0.5);
    }

    .mute-btn.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .mute-btn.active.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 8px rgba(199, 74, 58, 0.5), 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .solo-btn {
      width: 28px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background: rgba(30, 30, 30, 0.6);
      color: rgba(255, 255, 255, 0.5);
      border-radius: 3px;
      font-size: 0.65rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      padding: 0;
    }

    .solo-btn:hover {
      background: rgba(50, 50, 50, 0.8);
      border-color: rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 0.8);
    }

    .solo-btn.active {
      background: #f4c430;
      border-color: #f4c430;
      color: #000;
      box-shadow: 0 0 8px rgba(244, 196, 48, 0.5);
    }

    .solo-btn.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .solo-btn.active.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 8px rgba(244, 196, 48, 0.5), 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .fader-controls {
      display: flex;
      gap: 4px;
      justify-content: center;
      margin-bottom: 4px;
    }

    .fader-container {
      width: 24px;
      height: 100%; /* Fill available height */
      min-height: 200px;
      background: rgba(50, 50, 50, 0.95);
      border-radius: 12px;
      position: relative;
      border: 2px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.08);
      overflow: hidden;
      cursor: pointer;
      user-select: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    /* Stereo fader - half width for dual L/R display */
    .fader-container.stereo {
      width: 11px;
    }

    .fader-container:hover {
      border-color: rgba(74, 155, 127, 0.5);
    }

    .fader-container.dragging {
      border-color: #4a9b7f;
    }

    .fader-container.mapped {
      border-color: #4CAF50;
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
    }

    .fader-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to bottom, #4a9b7f, #3d7a63);
      border-radius: 0 0 13px 13px;
      transition: height 0.1s;
      min-height: 2px;
    }

    .fader-midi-indicator {
      position: absolute;
      left: -8px;
      right: -8px;
      height: 4px;
      background: #ff9800;
      box-shadow: 0 0 8px rgba(255, 152, 0, 0.9);
      pointer-events: none;
      z-index: 10;
      transition: bottom 0.1s ease-out;
      border-radius: 2px;
    }

    /* Zero line indicator at 0dB (75% height) */
    .fader-container::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: 75%; /* 0dB is at 75% */
      height: 2px;
      background: rgba(255, 255, 255, 0.4);
      z-index: 10;
      pointer-events: none;
    }

    .fader-wrapper {
      display: flex;
      align-items: stretch; /* Stretch to fill height */
      justify-content: flex-start; /* Align to start */
      gap: 3px;
      flex: 1;
    }

    .fader-levels {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      min-height: 200px;
      font-size: 0.55rem;
      color: rgba(255, 255, 255, 0.3);
      line-height: 1;
      min-width: 18px;
      text-align: right;
      flex-shrink: 0; /* Don't shrink the levels */
    }

    /* Wrapper for fader-container to center it */
    .fader-container-wrapper {
      display: flex;
      justify-content: center;
      align-items: stretch;
      flex: 1;
    }

    /* Mappings view */
    .mappings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .mappings-list {
      display: grid;
      gap: 15px;
    }

    .mapping-card {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .mapping-activity {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .mapping-activity.active {
      background: #00ff88;
      box-shadow: 0 0 12px #00ff88;
    }

    .mapping-info {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 15px;
      align-items: center;
    }

    .mapping-source, .mapping-target {
      font-size: 0.9rem;
    }

    .mapping-arrow {
      font-size: 1.5rem;
      opacity: 0.6;
    }

    .btn-small {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .btn-small:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-small.danger:hover {
      background: rgba(255, 68, 68, 0.3);
      border-color: rgba(255, 68, 68, 0.5);
    }

    .icon-btn {
      background: transparent;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 1.1rem;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .icon-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: rgba(30, 30, 30, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 4px 0;
      min-width: 150px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.8);
      z-index: 2000;
      display: none;
    }

    .context-menu.show {
      display: block;
    }

    .context-menu-header {
      padding: 6px 16px;
      color: #4CAF50;
      font-weight: bold;
      font-size: 0.85rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 4px;
    }

    .context-menu-item {
      padding: 8px 16px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }

    .context-menu-item:hover {
      background: rgba(74, 155, 127, 0.3);
    }

    .context-menu-item.danger:hover {
      background: rgba(255, 68, 68, 0.3);
    }

    .context-menu-separator {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 4px 0;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: rgba(20, 20, 20, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 20px;
      max-width: 500px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
    }

    .modal-content h2 {
      margin-bottom: 15px;
      margin-top: 0;
      color: #e0e0e0;
      font-size: 1.3rem;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9rem;
      color: #b0b0b0;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 10px 15px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(30, 30, 30, 0.8);
      color: #e0e0e0;
      font-size: 1rem;
    }

    .form-group input::placeholder {
      color: rgba(255, 255, 255, 0.3);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .mixer-list {
      display: grid;
      gap: 10px;
      margin: 15px 0;
    }

    .mixer-item {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .mixer-info {
      flex: 1;
    }

    .mixer-item .btn {
      min-width: 80px;
      width: auto;
      padding: 8px 16px;
    }

    .mixer-name {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 5px;
    }

    .midi-section-header {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #888;
      padding: 8px 2px 4px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      margin-bottom: 8px;
    }

    .mixer-item.connected-device {
      border-color: #4a9b7f;
      background: rgba(74, 155, 127, 0.1);
    }

    .btn.listening {
      background: #ff9800;
      color: #000;
      animation: pulse-orange 1s ease-in-out infinite;
    }

    @keyframes pulse-orange {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .mixer-details {
      opacity: 0.8;
      font-size: 0.9rem;
    }

    .empty-state {
      text-align: center;
      padding: 40px;
      opacity: 0.5;
      color: #666;
    }

    /* Bottom Status Bar */
    .status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40px;
      background: rgba(15, 15, 15, 0.95);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      font-size: 0.85rem;
      z-index: 900;
    }

    .status-bar-left, .status-bar-center, .status-bar-right {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .status-bar-center {
      flex: 1;
      justify-content: center;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-item-label {
      color: #666;
      font-size: 0.8rem;
    }

    .status-item-value {
      color: #b0b0b0;
      font-weight: 500;
    }

    .status-item-value.connected {
      color: #4a9b7f;
    }

    .status-item-value.disconnected {
      color: #c74a3a;
    }

    /* MIDI Log Window */
    .midi-log-window {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 400px;
      height: 300px;
      background: rgba(20, 20, 20, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      display: none;
      flex-direction: column;
      z-index: 999;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
    }

    .midi-log-window.show {
      display: flex;
    }

    .midi-log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(30, 30, 30, 0.8);
      border-radius: 8px 8px 0 0;
    }

    .midi-log-header h3 {
      margin: 0;
      font-size: 0.9rem;
      color: #e0e0e0;
    }

    .midi-log-controls {
      display: flex;
      gap: 8px;
    }

    .midi-log-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #e0e0e0;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .midi-log-btn:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .midi-log-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      line-height: 1.4;
    }

    .midi-log-entry {
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.03);
    }

    .midi-log-entry.cc {
      border-left: 3px solid #4a9b7f;
    }

    .midi-log-entry.note {
      border-left: 3px solid #9b7f4a;
    }

    .midi-log-timestamp {
      color: #666;
      margin-right: 8px;
    }

    .midi-log-type {
      color: #4a9b7f;
      font-weight: bold;
      margin-right: 8px;
    }

    .midi-log-entry.note .midi-log-type {
      color: #9b7f4a;
    }

    .midi-log-details {
      color: #b0b0b0;
    }

    /* MIDI device color badge */
    /* Meter bar ‚Äî lives inside .fader-levels alongside number labels */
    .fader-levels { flex-direction: row; gap: 2px; }
    .level-labels {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-size: 0.55rem;
      color: rgba(255, 255, 255, 0.3);
      line-height: 1;
      text-align: right;
      flex-shrink: 0;
    }
    .fader-meter {
      width: 6px;
      position: relative;
      flex-shrink: 0;
      background: rgba(20, 20, 20, 0.9);
      border-radius: 2px;
    }
    .fader-meter-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      border-radius: 2px;
      transition: height 50ms linear;
      background: #4CAF50;
    }
    .fader-meter-peak {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: #ffffff;
      display: none;
    }
    .fader-meter-tick {
      position: absolute;
      left: -4px;
      right: 0;
      height: 1px;
      background: rgba(255, 255, 255, 0.2);
      pointer-events: none;
    }

    /* Indicator dot (pip) ‚Äî always visible; grey=silent, color=active */
    .fader-indicator-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #555;
      display: inline-block;
      transition: background-color 0.15s;
      vertical-align: middle;
      margin-right: 2px;
    }

    /* Changelog rendered markdown */
    .changelog-rendered {
      flex: 1; overflow-y: auto; background: #1a1a1a; padding: 14px 18px;
      border-radius: 4px; margin: 10px 0; font-size: 0.82rem; line-height: 1.6; color: #c8c8c8;
    }
    .changelog-rendered h1 { font-size: 1.1rem; color: #e0e0e0; margin: 10px 0 4px; }
    .changelog-rendered h2 { font-size: 0.98rem; color: #ccc; margin: 14px 0 4px; padding-bottom: 4px; border-bottom: 1px solid #2e2e2e; }
    .changelog-rendered h3 { font-size: 0.82rem; color: #999; margin: 10px 0 2px; }
    .changelog-rendered ul { margin: 2px 0 6px 18px; padding: 0; }
    .changelog-rendered li { margin: 1px 0; }
    .changelog-rendered p  { margin: 2px 0; color: #888; }
    .changelog-rendered hr { border: none; border-top: 1px solid #2e2e2e; margin: 10px 0; }
    .changelog-rendered code { background: #2a2a2a; border-radius: 3px; padding: 0 3px; font-family: monospace; }
    .changelog-rendered a { color: #58a6ff; text-decoration: none; }
    .changelog-rendered a:hover { text-decoration: underline; }
    .changelog-rendered strong { color: #ddd; }

    /* Compact form layout for add-mapping modal to prevent scrolling */
    #add-mapping-modal .modal-content {
      padding: 15px;
    }
    #add-mapping-modal .form-group {
      margin-bottom: 7px;
    }
    #add-mapping-modal .form-group input,
    #add-mapping-modal .form-group select {
      padding: 6px 10px;
      font-size: 0.9rem;
    }
    #add-mapping-modal .form-group label {
      margin-bottom: 3px;
      font-size: 0.82rem;
    }
    #add-mapping-modal .form-group small {
      margin-top: 2px;
    }
    #add-mapping-modal h2 {
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    #add-mapping-modal .modal-buttons {
      margin-top: 12px;
    }

    /* Device color badge in MIDI device list */
    .midi-device-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1><img src="../assets/icon.png" style="width:32px;height:32px;vertical-align:middle;margin-right:8px;" /> StudioLive MIDI Controller</h1>
      </div>
      <div class="header-right">
        <button class="btn-small" onclick="showPreferences()" title="Preferences">‚öôÔ∏è</button>
        <button class="btn-small" onclick="showSavePreset()" title="Save Profile">üíæ Save</button>
        <button class="btn-small" onclick="showLoadPreset()" title="Load Profile">üìÇ Load</button>
        <button class="btn-small" onclick="showMappingsList()" title="View All Mappings">üìã Mappings</button>
        <button class="btn-small" onclick="toggleMidiLog()" title="Show MIDI Log">üìä MIDI Log</button>
        <div class="connection-status" onclick="openConnectionPanel('midi')" id="midi-connection-status" title="">
          <div class="status-dot" id="midi-status-dot"></div>
          <span id="midi-status-short">MIDI</span>
          <div class="activity-indicator midi" id="midi-activity"></div>
        </div>
        <div class="connection-status" onclick="openConnectionPanel('mixer')" id="mixer-connection-status" title="">
          <div class="status-dot" id="mixer-status-dot"></div>
          <span id="mixer-status-short">Mixer</span>
          <div class="activity-indicator mixer" id="mixer-activity"></div>
        </div>
      </div>
    </div>

    <div class="main-layout">
      <!-- Main content -->
      <div class="content-area">
        <div id="faders-view" class="tab-content active">
          <div class="faders-toolbar">
            <button class="btn" onclick="showAddMapping()" title="Add Channel">‚ûï</button>
            <select class="btn" id="filter-select" onchange="onFilterChange()" style="min-width: 150px;">
              <option value="all">üîç View: All</option>
              <option value="added">üîç View: Added</option>
              <option value="mapped">üîç View: Mapped</option>
            </select>
            <!-- Spacer to push mute groups to the right -->
            <div class="toolbar-spacer"></div>
            <!-- Mute groups (right-aligned) -->
            <div class="mute-groups" id="mute-groups-container">
              <!-- Mute group buttons will be dynamically added here -->
            </div>
          </div>
          <div class="faders-grid">
            <div id="faders-container" class="faders-scrollable"></div>
            <div id="faders-main-container" class="faders-main"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bottom Status Bar -->
  <div class="status-bar">
    <div class="status-bar-left">
      <div class="status-item">
        <span id="status-init" style="cursor: pointer; text-decoration: underline dotted;" onclick="showStatusLog()" title="Click to view initialization log">Initializing...</span>
      </div>
    </div>
    <div class="status-bar-center">
      <div class="status-item">
        <span class="status-item-label">Profile:</span>
        <span class="status-item-value" id="status-profile">None</span>
        <span id="status-unsaved" style="color: #ff9800; margin-left: 8px; display: none;">‚óè</span>
      </div>
      <div class="status-item">
        <span class="status-item-label">Last Saved:</span>
        <span class="status-item-value" id="status-last-saved">Never</span>
      </div>
    </div>
    <div class="status-bar-right">
      <div class="status-item">
        <span class="status-item-label">Version:</span>
        <span class="status-item-value" id="status-version">1.2.2</span>
      </div>
    </div>
  </div>

  <!-- Modals -->
  <div id="discovery-modal" class="modal">
    <div class="modal-content">
      <h2>üîç Find Mixer</h2>
      <button class="btn" id="scan-btn" onclick="scanForMixers()">Scan Network</button>
      <div id="mixer-list" class="mixer-list">
        <div class="empty-state">Click "Scan Network" to discover mixers</div>
      </div>
      <h3 style="margin-top: 20px; margin-bottom: 10px;">Manual Connection</h3>
      <div class="form-group">
        <input type="text" id="manual-ip" placeholder="Enter mixer IP (e.g., 192.168.1.100)" />
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="connectManual()">Connect</button>
        <button class="btn" onclick="hideDiscovery()">Close</button>
      </div>
    </div>
  </div>

  <div id="add-mapping-modal" class="modal">
    <div class="modal-content">
      <h2>‚ûï Create Mapping</h2>
      <!-- Mixer Settings (Top) -->
      <div class="form-group">
        <label>Mixer Channel Type</label>
        <select id="mixer-channel-type" onchange="updateChannelNumberOptions()">
          <option value="LINE">Line Input</option>
          <option value="RETURN">Digital Return (Dig Ret)</option>
          <option value="FXRETURN">FX Return</option>
          <option value="TALKBACK">Talkback</option>
          <option value="AUX">Aux Output</option>
          <option value="FX">FX Bus</option>
          <option value="SUB">Subgroup</option>
          <option value="MAIN">Main Mix</option>
          <option value="DCA">DCA Group</option>
        </select>
      </div>
      <div class="form-group">
        <label>Mixer Channel Number</label>
        <select id="mixer-channel-num" onchange="updateMidiSettingsForChannel()">
          <!-- Will be populated dynamically -->
        </select>
      </div>
      <div class="form-group">
        <label>Mixer Action</label>
        <select id="mixer-action" onchange="updateMidiTypeFields()">
          <option value="volume">Volume</option>
          <option value="mute">Mute</option>
          <option value="solo">Solo</option>
          <option value="pan">Pan</option>
        </select>
      </div>
      <!-- MIDI Settings (Bottom) -->
      <div class="form-group">
        <label>MIDI Type</label>
        <select id="midi-type" onchange="updateMidiTypeFields()">
          <option value="none">None ‚Äî view only</option>
          <option value="cc">Control Change (CC)</option>
          <option value="note">Note (Trigger)</option>
          <option value="note-value">Note (Value Mode)</option>
        </select>
      </div>
      <div class="form-group" id="cc-threshold-group" style="display:none;">
        <label>CC Threshold (for Mute/Solo)</label>
        <input type="number" id="midi-cc-threshold" value="64" min="0" max="127" />
        <small style="color: #888; display: block; margin-top: 5px;">Values >= threshold activate, values < threshold deactivate (default: 64 = middle)</small>
      </div>
      <div class="form-group" id="cc-group">
        <label>CC Type</label>
        <select id="midi-cc">
          <option value="0">CC0 - Bank MSB</option>
          <option value="1">CC1 - Modulation</option>
          <option value="2">CC2 - Breath</option>
          <option value="3">CC3 - Ctrl 3</option>
          <option value="4">CC4 - Foot Control</option>
          <option value="5">CC5 - Portamento Time</option>
          <option value="6">CC6 - Data MSB</option>
          <option value="7" selected>CC7 - MIDI Volume</option>
          <option value="8">CC8 - Balance</option>
          <option value="9">CC9 - Ctrl 9</option>
          <option value="10">CC10 - MIDI Pan</option>
          <option value="11">CC11 - Expression</option>
          <option value="12">CC12 - Effect #1 MSB</option>
          <option value="13">CC13 - Effect #2 MSB</option>
          <option value="14">CC14 - Ctrl 14</option>
          <option value="15">CC15 - Ctrl 15</option>
          <option value="16">CC16 - General #1</option>
          <option value="17">CC17 - General #2</option>
          <option value="18">CC18 - General #3</option>
          <option value="19">CC19 - General #4</option>
          <option value="20">CC20 - Ctrl 20</option>
          <option value="21">CC21 - Ctrl 21</option>
          <option value="22">CC22 - Ctrl 22</option>
          <option value="23">CC23 - Ctrl 23</option>
          <option value="24">CC24 - Ctrl 24</option>
          <option value="25">CC25 - Ctrl 25</option>
          <option value="26">CC26 - Ctrl 26</option>
          <option value="27">CC27 - Ctrl 27</option>
          <option value="28">CC28 - Ctrl 28</option>
          <option value="29">CC29 - Ctrl 29</option>
          <option value="30">CC30 - Ctrl 30</option>
          <option value="31">CC31 - Ctrl 31</option>
          <option value="32">CC32 - Bank LSB</option>
          <option value="33">CC33 - (#01 LSB)</option>
          <option value="34">CC34 - (#02 LSB)</option>
          <option value="35">CC35 - (#03 LSB)</option>
          <option value="36">CC36 - (#04 LSB)</option>
          <option value="37">CC37 - (#05 LSB)</option>
          <option value="38">CC38 - (#06 LSB)</option>
          <option value="39">CC39 - (#07 LSB)</option>
          <option value="40">CC40 - (#08 LSB)</option>
          <option value="41">CC41 - (#09 LSB)</option>
          <option value="42">CC42 - (#10 LSB)</option>
          <option value="43">CC43 - (#11 LSB)</option>
          <option value="44">CC44 - Effect #1 LSB</option>
          <option value="45">CC45 - Effect #2 LSB</option>
          <option value="46">CC46 - (#14 LSB)</option>
          <option value="47">CC47 - (#15 LSB)</option>
          <option value="48">CC48 - (#16 LSB)</option>
          <option value="49">CC49 - (#17 LSB)</option>
          <option value="50">CC50 - (#18 LSB)</option>
          <option value="51">CC51 - (#19 LSB)</option>
          <option value="52">CC52 - (#20 LSB)</option>
          <option value="53">CC53 - (#21 LSB)</option>
          <option value="54">CC54 - (#22 LSB)</option>
          <option value="55">CC55 - (#23 LSB)</option>
          <option value="56">CC56 - (#24 LSB)</option>
          <option value="57">CC57 - (#25 LSB)</option>
          <option value="58">CC58 - (#26 LSB)</option>
          <option value="59">CC59 - (#27 LSB)</option>
          <option value="60">CC60 - (#28 LSB)</option>
          <option value="61">CC61 - (#29 LSB)</option>
          <option value="62">CC62 - (#30 LSB)</option>
          <option value="63">CC63 - (#31 LSB)</option>
          <option value="64">CC64 - Sustain</option>
          <option value="65">CC65 - Portamento</option>
          <option value="66">CC66 - Sostenuto</option>
          <option value="67">CC67 - Soft Pedal</option>
          <option value="68">CC68 - Legato</option>
          <option value="69">CC69 - Hold 2</option>
          <option value="70">CC70 - Sound Variation</option>
          <option value="71">CC71 - Timbre</option>
          <option value="72">CC72 - Release Time</option>
          <option value="73">CC73 - Attack Time</option>
          <option value="74">CC74 - Brightness</option>
          <option value="75">CC75 - Decay Time</option>
          <option value="76">CC76 - Vibrato Rate</option>
          <option value="77">CC77 - Vibrato Depth</option>
          <option value="78">CC78 - Vibrato Delay</option>
          <option value="79">CC79 - Ctrl 79</option>
          <option value="80">CC80 - Decay</option>
          <option value="81">CC81 - HPF Frequency</option>
          <option value="82">CC82 - General #5</option>
          <option value="83">CC83 - General #6</option>
          <option value="84">CC84 - Portamento Control</option>
          <option value="85">CC85 - Ctrl 85</option>
          <option value="86">CC86 - Ctrl 86</option>
          <option value="87">CC87 - Ctrl 87</option>
          <option value="88">CC88 - High Resolution Velocity Prefix</option>
          <option value="89">CC89 - Ctrl 89</option>
          <option value="90">CC90 - Ctrl 90</option>
          <option value="91">CC91 - Reverb</option>
          <option value="92">CC92 - Tremolo Depth</option>
          <option value="93">CC93 - Chorus Send Level</option>
          <option value="94">CC94 - Celeste (Detune) Depth</option>
          <option value="95">CC95 - Phaser Depth</option>
          <option value="96">CC96 - Data Increment</option>
          <option value="97">CC97 - Data Decrement</option>
          <option value="98">CC98 - Non-Reg. LSB</option>
          <option value="99">CC99 - Non-Reg. MSB</option>
          <option value="100">CC100 - Reg.Par. LSB</option>
          <option value="101">CC101 - Reg.Par. MSB</option>
          <option value="102">CC102 - Ctrl 102</option>
          <option value="103">CC103 - Ctrl 103</option>
          <option value="104">CC104 - Ctrl 104</option>
          <option value="105">CC105 - Ctrl 105</option>
          <option value="106">CC106 - Ctrl 106</option>
          <option value="107">CC107 - Ctrl 107</option>
          <option value="108">CC108 - Ctrl 108</option>
          <option value="109">CC109 - Ctrl 109</option>
          <option value="110">CC110 - Ctrl 110</option>
          <option value="111">CC111 - Ctrl 111</option>
          <option value="112">CC112 - Ctrl 112</option>
          <option value="113">CC113 - Ctrl 113</option>
          <option value="114">CC114 - Ctrl 114</option>
          <option value="115">CC115 - Ctrl 115</option>
          <option value="116">CC116 - Ctrl 116</option>
          <option value="117">CC117 - Ctrl 117</option>
          <option value="118">CC118 - Ctrl 118</option>
          <option value="119">CC119 - Ctrl 119</option>
          <option value="120">CC120 - All Sound Off</option>
          <option value="121">CC121 - Reset All Controllers</option>
          <option value="122">CC122 - Local Control</option>
          <option value="123">CC123 - All Notes Off</option>
          <option value="124">CC124 - Omni Mode Off</option>
          <option value="125">CC125 - Omni Mode On</option>
          <option value="126">CC126 - Mono Mode On</option>
          <option value="127">CC127 - Poly Mode On</option>
        </select>
        <small style="color: #888; display: block; margin-top: 5px;">Logic Pro default: CC7 (Volume) with channel = mixer channel number</small>
      </div>
      <div class="form-group" id="midi-channel-group">
        <label>MIDI Channel (1-16)</label>
        <input type="number" id="midi-channel" value="1" min="1" max="16" />
        <small style="color: #888; display: block; margin-top: 5px;">Logic Pro uses channels 1-16 (MIDI 0-15 internally)</small>
      </div>
      <div class="form-group" id="midi-device-filter-group">
        <label>MIDI Device Filter</label>
        <select id="midi-device-filter" onchange="updateDeviceFilterSelectColor(this)">
          <option value="">Any connected device</option>
          <!-- Populated dynamically from connected devices -->
        </select>
        <small style="color: #888; display: block; margin-top: 5px;">Optional: only respond to signals from this specific device</small>
      </div>
      <div class="form-group" id="note-group" style="display:none;">
        <label>Note Number (Trigger)</label>
        <input type="number" id="midi-note" value="60" min="0" max="127" oninput="updateNoteDisplay()" />
        <small style="color: #888;" id="note-display">C4 (60)</small>
      </div>
      <div class="form-group" id="note-invert-group" style="display:none;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="midi-note-invert" style="width: auto; margin: 0;" />
          <span>Invert Note Logic (for Mute/Solo)</span>
        </label>
        <small style="color: #888; display: block; margin-top: 5px;">When checked: Note ON = deactivate, Note OFF = activate</small>
      </div>
      <div class="form-group" id="note-value-group" style="display:none;">
        <label>Note Range (C1-C4 = 24-60)</label>
        <div style="display: flex; gap: 10px; align-items: center;">
          <div style="flex: 1;">
            <label style="font-size: 0.75rem; color: #888;">Min Note</label>
            <input type="number" id="midi-note-min" value="24" min="0" max="127" oninput="updateNoteMinDisplay()" />
            <small style="color: #888; display: block;" id="note-min-display">C1 (24)</small>
          </div>
          <div style="flex: 1;">
            <label style="font-size: 0.75rem; color: #888;">Max Note</label>
            <input type="number" id="midi-note-max" value="60" min="0" max="127" oninput="updateNoteMaxDisplay()" />
            <small style="color: #888; display: block;" id="note-max-display">C4 (60)</small>
          </div>
        </div>
        <small style="color: #888; display: block; margin-top: 5px;">Note number maps to fader value (min=0%, max=100%)</small>
      </div>
      <div class="form-group" id="midi-listen-group">
        <label>MIDI Learn</label>
        <div style="display: flex; align-items: center; gap: 12px;">
          <button class="btn" id="midi-listen-btn" type="button" onclick="toggleMidiListen()">Learn</button>
          <span id="midi-listen-status" style="color: #888; font-size: 0.85rem;"></span>
        </div>
        <small style="color: #888; display: block; margin-top: 5px;">Click Learn, then send a MIDI signal to auto-detect type, channel, and CC/note</small>
      </div>
      <div class="modal-buttons">
        <button class="btn" id="mapping-submit-btn" onclick="addMapping()">Add Mapping</button>
        <button class="btn danger" id="mapping-clear-btn" onclick="clearCurrentMapping()" style="display:none;">Clear</button>
        <button class="btn" onclick="hideAddMapping()">Cancel</button>
      </div>
    </div>
  </div>

  <div id="save-preset-modal" class="modal">
    <div class="modal-content">
      <h2>üíæ Save Preset</h2>
      <div class="form-group">
        <label>Preset Name</label>
        <input type="text" id="preset-name" placeholder="My Preset" />
      </div>
      <div class="form-group">
        <label>Description (optional)</label>
        <input type="text" id="preset-description" placeholder="Description" />
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="savePreset()">Save</button>
        <button class="btn" onclick="hideSavePreset()">Cancel</button>
      </div>
    </div>
  </div>

  <div id="midi-select-modal" class="modal">
    <div class="modal-content">
      <h2>üéπ MIDI Connection</h2>
      <div id="midi-devices-list" class="mixer-list">
        <div class="empty-state">Loading MIDI devices...</div>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="refreshMidiDevices()">üîÑ Refresh</button>
        <button class="btn" onclick="hideMidiSelect()">Close</button>
      </div>
    </div>
  </div>

  <div id="preferences-modal" class="modal">
    <div class="modal-content">
      <h2>‚öôÔ∏è Preferences</h2>
      <div class="form-group">
        <label>Fader Smoothing</label>
        <input type="range" id="fader-smoothing" min="0" max="500" value="200" step="50" oninput="updateSmoothingDisplay()" />
        <small style="color: #888; display: block; margin-top: 5px;">
          Speed: <span id="smoothing-display">200</span>ms (relative to change amount)
        </small>
        <small style="color: #888; display: block; margin-top: 5px;">
          Lower = faster response, Higher = smoother transitions
        </small>
      </div>
      <div class="form-group" style="margin-top: 20px;">
        <label style="display: flex; align-items: center; cursor: pointer;">
          <input type="checkbox" id="midi-feedback-enabled" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;" />
          <span>Enable MIDI Feedback</span>
        </label>
        <small style="color: #888; display: block; margin-top: 5px;">
          Send fader positions back to MIDI controller (e.g., Logic Pro)
        </small>
        <small style="color: #ff9800; display: block; margin-top: 5px;">
          ‚ö†Ô∏è Disable if experiencing MIDI feedback loops
        </small>
      </div>
      <div class="form-group">
        <label style="font-size:0.75rem;color:rgba(255,255,255,0.7)">Channel Level Display</label>
        <select id="level-visibility-select" style="width:100%;padding:4px;background:rgba(40,40,40,0.9);color:#fff;border:1px solid rgba(255,255,255,0.2);border-radius:4px;font-size:0.75rem">
          <option value="none">None</option>
          <option value="indicator">Indicator (dot)</option>
          <option value="meter">Meter</option>
        </select>
        <label style="display: flex; align-items: center; cursor: pointer; margin-top: 6px;">
          <input type="checkbox" id="peak-hold-check" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;" />
          <span>Peak hold</span>
        </label>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="savePreferences()">Save</button>
        <button class="btn" onclick="hidePreferences()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Mappings List Modal -->
  <div id="mappings-list-modal" class="modal">
    <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
      <h2>üìã All MIDI Mappings</h2>
      <div id="mappings-list-view" style="margin: 20px 0;">
        <!-- Will be populated by JavaScript -->
      </div>
      <div class="modal-buttons">
        <button class="btn danger" onclick="clearAllMappingsFromList()" style="margin-right: auto;">üßπ Clear All Mappings</button>
        <button class="btn" onclick="hideMappingsList()">Close</button>
      </div>
    </div>
  </div>

  <!-- Context Menus -->
  <!-- Fader Volume Context Menu -->
  <div id="fader-context-menu" class="context-menu">
    <div class="context-menu-header">üéöÔ∏è Volume Fader</div>
    <div class="context-menu-item" onclick="contextMenuEditFader()">‚úèÔ∏è Edit Volume Mapping</div>
    <div class="context-menu-item" onclick="contextMenuLearnFader()">üéπ Learn Volume Mapping</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuClearFader()">üßπ Clear Volume Mapping</div>
  </div>

  <!-- Mute Button Context Menu -->
  <div id="mute-context-menu" class="context-menu">
    <div class="context-menu-header">üîá Mute Button</div>
    <div class="context-menu-item" onclick="contextMenuEditMute()">‚úèÔ∏è Edit Mute Mapping</div>
    <div class="context-menu-item" onclick="contextMenuLearnMute()">üéπ Learn Mute Mapping</div>
  </div>

  <!-- Solo Button Context Menu -->
  <div id="solo-context-menu" class="context-menu">
    <div class="context-menu-header">üîä Solo Button</div>
    <div class="context-menu-item" onclick="contextMenuEditSolo()">‚úèÔ∏è Edit Solo Mapping</div>
    <div class="context-menu-item" onclick="contextMenuLearnSolo()">üéπ Learn Solo Mapping</div>
  </div>

  <!-- Channel Context Menu -->
  <div id="channel-context-menu" class="context-menu">
    <div class="context-menu-header">üìª Channel</div>
    <div class="context-menu-item" onclick="contextMenuEditFader()">‚úèÔ∏è Edit Volume</div>
    <div class="context-menu-item" onclick="contextMenuLearnFader()">üéπ Learn Volume</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item danger" onclick="contextMenuClearAllMappings()">üßπ Clear All MIDI Mappings</div>
  </div>

  <!-- Mute Group Context Menu -->
  <div id="mutegroup-context-menu" class="context-menu">
    <div class="context-menu-header">üéöÔ∏è Mute Group</div>
    <div class="context-menu-item" onclick="contextMenuEditMuteGroup()">‚úèÔ∏è Edit Mute Group Mapping</div>
    <div class="context-menu-item" onclick="contextMenuLearnMuteGroup()">üéπ Learn Mute Group Mapping</div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="contextMenuClearMuteGroup()">üßπ Clear Mute Group Mapping</div>
  </div>

  <!-- MIDI Log Window -->
  <div id="midi-log-window" class="midi-log-window">
    <div class="midi-log-header">
      <h3>üìä MIDI Events</h3>
      <div class="midi-log-controls">
        <button class="midi-log-btn" onclick="clearMidiLog()">Clear</button>
        <button class="midi-log-btn" onclick="toggleMidiLog()">Close</button>
      </div>
    </div>
    <div class="midi-log-content" id="midi-log-content">
      <div style="color: #666; text-align: center; padding: 20px;">No MIDI events yet...</div>
    </div>
  </div>

  <!-- Status Log Modal -->
  <div id="status-log-modal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
      <h2>üìã Initialization Log</h2>
      <div style="max-height: 400px; overflow-y: auto; background: #1a1a1a; padding: 15px; border-radius: 4px; font-family: monospace; font-size: 12px;">
        <div id="status-log-content"></div>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="clearStatusLog()">Clear Log</button>
        <button class="btn" onclick="hideStatusLog()">Close</button>
      </div>
    </div>
  </div>

  <!-- Changelog Modal -->
  <div id="changelog-modal" class="modal">
    <div class="modal-content" style="max-width: 660px; max-height: 80vh; display: flex; flex-direction: column;">
      <!-- Row 1: App name + version, clickable ‚Üí repo -->
      <div style="margin-bottom:6px;">
        <a href="#" onclick="event.preventDefault();ipcRenderer.openExternal('https://github.com/sandinak/studiolive-midi-controller')"
           style="color:#e0e0e0;text-decoration:none;font-size:1.1rem;font-weight:600;">
          StudioLive MIDI Controller
        </a>
        <span id="changelog-version-badge" style="color:#888;font-size:1.1rem;margin-left:8px;"></span>
      </div>
      <!-- Row 2: author (left) + Docs button (right) -->
      <div style="display:flex;justify-content:space-between;align-items:center;padding-bottom:10px;border-bottom:1px solid #333;flex-shrink:0;">
        <span style="font-size:0.8rem;color:#888;">
          By: <a href="#" onclick="event.preventDefault();ipcRenderer.openExternal('https://github.com/sandinak')"
                 style="color:#58a6ff;text-decoration:none;">sandinak</a>
        </span>
        <button class="btn" onclick="ipcRenderer.invoke('open-docs')"
                style="font-size:0.7rem;padding:2px 8px;width:auto;margin-top:0;">üìñ Docs</button>
      </div>
      <div id="changelog-content" class="changelog-rendered"></div>
      <div class="modal-buttons">
        <button class="btn" onclick="hideChangelogModal()">Close</button>
      </div>
    </div>
  </div>

  <!-- Update Available Modal -->
  <div id="update-modal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
      <h2>üéâ Update Available</h2>
      <div style="padding: 20px 0;">
        <p style="font-size: 1.1rem; margin-bottom: 15px;">
          A new version of StudioLive MIDI Controller is available!
        </p>
        <div style="background: #1a1a1a; padding: 15px; border-radius: 4px; margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <span style="color: #888;">Current Version:</span>
            <span id="update-current-version" style="font-weight: bold;">-</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span style="color: #888;">Latest Version:</span>
            <span id="update-latest-version" style="font-weight: bold; color: #4CAF50;">-</span>
          </div>
        </div>
        <div id="update-release-notes" style="background: #1a1a1a; padding: 15px; border-radius: 4px; margin-bottom: 15px; max-height: 200px; overflow-y: auto; display: none;">
          <h3 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #4CAF50;">üìù Release Notes</h3>
          <div id="update-release-notes-content" style="color: #ccc; font-size: 0.85rem; line-height: 1.5; white-space: pre-wrap;"></div>
        </div>
        <p style="color: #888; font-size: 0.9rem;">
          Click "Download Update" to visit the release page and download the latest version.
        </p>
      </div>
      <div class="modal-buttons">
        <button class="btn" onclick="hideUpdateModal()">Later</button>
        <button class="btn" onclick="downloadUpdate()" style="background: #4CAF50;">Download Update</button>
      </div>
    </div>
  </div>

  <script>
    // Use contextBridge API exposed by preload.js (contextIsolation is enabled)
    const ipcRenderer = window.electronAPI;

    // Inline HTML sanitizer ‚Äî escapes untrusted strings before DOM insertion
    function sanitizeHtml(str) {
      if (str === null || str === undefined) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
    }

    // Track mapping activity
    const mappingActivity = new Map();

    // Default color - grey so it's clear when mixer colors are applied
    const DEFAULT_COLOR = '#666666';

    // Store fader colors to preserve them across updates
    const faderColors = new Map();

    // Fader filter state: 'all' or 'mapped'
    let faderFilter = 'all';

    // Level visibility and meter globals
    let currentLevelVisibility = 'none';
    let currentPeakHold = false;
    const midiDeviceColors = {};
    const peakData = {};
    const PEAK_HOLD_MS = 3000;
    const MG_INPUT = 0;  // MeterGroups.INPUT_SIGNAL

    // Cached meter DOM element references ‚Äî rebuilt by buildMeterElCache() after loadFaders()
    const meterFillEls = {};   // faderId ‚Üí fill element
    const meterPeakEls = {};   // faderId ‚Üí peak element
    const meterDotEls  = {};   // faderId ‚Üí dot element
    let pendingMeterData = null;
    let meterRafId = null;

    function buildMeterElCache() {
      // Clear existing cache
      for (const k in meterFillEls) delete meterFillEls[k];
      for (const k in meterPeakEls) delete meterPeakEls[k];
      for (const k in meterDotEls)  delete meterDotEls[k];
      document.querySelectorAll('[id^="fader-meter-fill-"]').forEach(el => {
        meterFillEls[el.id.slice('fader-meter-fill-'.length)] = el;
      });
      document.querySelectorAll('[id^="fader-meter-peak-"]').forEach(el => {
        meterPeakEls[el.id.slice('fader-meter-peak-'.length)] = el;
      });
      document.querySelectorAll('[id^="fader-dot-"]').forEach(el => {
        meterDotEls[el.id.slice('fader-dot-'.length)] = el;
      });
    }

    // Flag to prevent auto-updating MIDI settings when editing
    let isEditingMapping = false;

    // Channel data cache (shared across loadFaders and updateFilterDropdown)
    let channelDataCache = {};

    // Current mappings (shared across components)
    let currentMappings = [];

    // Mappings list modal state
    let currentMappingsList = [];
    let returnToMappingsList = false;
    let midiLearnActive = false;

    // Flag to prevent multiple simultaneous loadFaders calls
    let isLoadingFaders = false;

    // Set of currently connected MIDI device names (updated on connect/disconnect events)
    let connectedMidiDevices = new Set();

    // Status log for tracking initialization and errors
    let statusLog = [];
    const MAX_LOG_ENTRIES = 100;

    // Add entry to status log
    function addStatusLog(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const entry = { timestamp, message, type };
      statusLog.push(entry);

      // Keep only last MAX_LOG_ENTRIES
      if (statusLog.length > MAX_LOG_ENTRIES) {
        statusLog.shift();
      }

    }

    // Show status log modal
    function showStatusLog() {
      const modal = document.getElementById('status-log-modal');
      const content = document.getElementById('status-log-content');

      if (statusLog.length === 0) {
        content.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No log entries yet...</div>';
      } else {
        content.innerHTML = statusLog.map(entry => {
          let color = '#4CAF50'; // green for info
          let icon = '‚ÑπÔ∏è';

          if (entry.type === 'error') {
            color = '#f44336'; // red
            icon = '‚ùå';
          } else if (entry.type === 'warning') {
            color = '#ff9800'; // orange
            icon = '‚ö†Ô∏è';
          } else if (entry.type === 'success') {
            color = '#4CAF50'; // green
            icon = '‚úÖ';
          }

          return `<div style="margin-bottom: 8px; color: ${color};">
            <span style="color: #888;">[${entry.timestamp}]</span> ${icon} ${entry.message}
          </div>`;
        }).reverse().join(''); // Reverse to show newest first
      }

      modal.classList.add('show');
    }

    // Hide status log modal
    function hideStatusLog() {
      const modal = document.getElementById('status-log-modal');
      modal.classList.remove('show');
    }

    // Clear status log
    function clearStatusLog() {
      statusLog = [];
      const content = document.getElementById('status-log-content');
      content.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No log entries yet...</div>';
    }

    // Update modal functions
    let updateDownloadUrl = '';

    function showUpdateModal(currentVersion, latestVersion, downloadUrl, releaseNotes) {
      updateDownloadUrl = downloadUrl;
      document.getElementById('update-current-version').textContent = currentVersion;
      document.getElementById('update-latest-version').textContent = latestVersion;

      // Show release notes if available
      if (releaseNotes) {
        const notesContainer = document.getElementById('update-release-notes');
        const notesContent = document.getElementById('update-release-notes-content');
        notesContent.textContent = releaseNotes;
        notesContainer.style.display = 'block';
      } else {
        document.getElementById('update-release-notes').style.display = 'none';
      }

      const modal = document.getElementById('update-modal');
      modal.classList.add('show');
    }

    function hideUpdateModal() {
      const modal = document.getElementById('update-modal');
      modal.classList.remove('show');
    }

    // Markdown helpers for changelog rendering
    function escapeHtml(text) {
      return String(text)
        .replace(/&/g, '&amp;').replace(/</g, '&lt;')
        .replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function processInlineMarkdown(text) {
      return escapeHtml(text)
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, label, url) =>
          `<a href="#" onclick="event.preventDefault();ipcRenderer.openExternal('${url}')">${label}</a>`);
    }

    function renderMarkdown(md) {
      const lines = md.split('\n');
      let html = '';
      let inList = false;
      for (const rawLine of lines) {
        // Skip reference-style link definitions [id]: url
        if (/^\[[^\]]+\]:\s+https?:\/\//.test(rawLine)) continue;
        const line = rawLine.trimEnd();
        if (inList && !/^[-*] /.test(line)) { html += '</ul>'; inList = false; }
        if      (/^### /.test(line)) { html += `<h3>${processInlineMarkdown(line.slice(4))}</h3>`; }
        else if (/^## /.test(line))  { html += `<h2>${processInlineMarkdown(line.slice(3))}</h2>`; }
        else if (/^# /.test(line))   { html += `<h1>${processInlineMarkdown(line.slice(2))}</h1>`; }
        else if (/^---/.test(line))  { html += '<hr>'; }
        else if (/^[-*] /.test(line)) {
          if (!inList) { html += '<ul>'; inList = true; }
          html += `<li>${processInlineMarkdown(line.slice(2))}</li>`;
        } else if (line.trim() !== '') {
          html += `<p>${processInlineMarkdown(line)}</p>`;
        }
      }
      if (inList) html += '</ul>';
      return html;
    }

    // Pending update info ‚Äî set by checkForUpdates() when a newer version is found
    let pendingUpdate = null; // { latestVersion, downloadUrl, releaseNotes }

    // Changelog modal
    async function showChangelogModal() {
      const modal = document.getElementById('changelog-modal');
      const content = document.getElementById('changelog-content');

      // Populate version badge ‚Äî read from data-version attribute to avoid
      // picking up badge text that may have been appended to #status-version
      const badge = document.getElementById('changelog-version-badge');
      if (badge) {
        const versionEl = document.getElementById('status-version');
        const v = versionEl?.dataset?.version || versionEl?.textContent?.split(' ')[0]?.trim();
        badge.textContent = v ? `v${v}` : '';
      }

      content.innerHTML = '<p style="color:#666">Loading‚Ä¶</p>';
      modal.classList.add('show');

      // If an update is pending, show a banner above the changelog content
      const existingBanner = modal.querySelector('.update-banner');
      if (existingBanner) existingBanner.remove();
      if (pendingUpdate) {
        const banner = document.createElement('div');
        banner.className = 'update-banner';
        banner.style.cssText = 'background:#1e3a1e;border:1px solid #4CAF50;border-radius:4px;padding:10px 14px;margin-bottom:12px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0;';
        const text = document.createElement('span');
        text.style.color = '#4CAF50';
        text.textContent = `Update available: v${pendingUpdate.latestVersion}`;
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.style.cssText = 'background:#4CAF50;font-size:0.75rem;padding:3px 10px;width:auto;margin:0;';
        btn.textContent = 'Download';
        btn.addEventListener('click', () => {
          window.electronAPI.openExternal(pendingUpdate.downloadUrl);
          hideChangelogModal();
        });
        banner.appendChild(text);
        banner.appendChild(btn);
        content.parentNode.insertBefore(banner, content);
      }

      try {
        const result = await ipcRenderer.invoke('get-changelog');
        if (result.success) {
          // Drop everything before the first version heading (## [x.y.z])
          let md = result.content;
          const firstVer = md.search(/^## \[/m);
          if (firstVer !== -1) md = md.slice(firstVer);
          content.innerHTML = renderMarkdown(md);
        } else {
          content.innerHTML = `<p style="color:#f44336">Could not load changelog: ${escapeHtml(result.error)}</p>`;
        }
      } catch (e) {
        content.innerHTML = `<p style="color:#f44336">Error: ${escapeHtml(e.message)}</p>`;
      }
    }

    function hideChangelogModal() {
      document.getElementById('changelog-modal').classList.remove('show');
    }

    function downloadUpdate() {
      if (updateDownloadUrl) {
        window.electronAPI.openExternal(updateDownloadUrl);
      }
      hideUpdateModal();
    }

    // Check for updates
    async function checkForUpdates() {
      try {
        const result = await ipcRenderer.invoke('check-for-updates');

        // Always update the version display with the real version from package.json
        const versionEl = document.getElementById('status-version');
        if (versionEl && result.currentVersion) {
          versionEl.textContent = result.currentVersion;
          // Store clean version in data attribute so showChangelogModal can read it
          // even after a badge child node has been appended
          versionEl.dataset.version = result.currentVersion;
        }

        if (result.success) {
          addStatusLog(`Version check: ${result.currentVersion} (latest: ${result.latestVersion})`, 'info');

          if (result.updateAvailable) {
            addStatusLog(`Update available: ${result.latestVersion}`, 'warning');

            // Store update info for the changelog modal banner
            pendingUpdate = {
              latestVersion: result.latestVersion,
              downloadUrl: result.downloadUrl,
              releaseNotes: result.releaseNotes,
            };

            // Show update badge in status bar ‚Äî DOM construction (no innerHTML, no inline onclick)
            if (versionEl) {
              const badge = document.createElement('span');
              badge.style.cssText = 'background:#f4c430;color:#111;font-size:0.6rem;padding:1px 5px;border-radius:3px;margin-left:4px;cursor:pointer;vertical-align:middle;';
              badge.textContent = `‚Üë ${result.latestVersion}`;
              badge.title = 'Update available ‚Äî click to view changelog';
              badge.addEventListener('click', (e) => {
                e.stopPropagation(); // prevent parent click listener firing twice
                showChangelogModal();
              });
              versionEl.appendChild(badge);
            }

            // Auto-show update modal once on startup after a short delay
            setTimeout(() => {
              showUpdateModal(result.currentVersion, result.latestVersion, result.downloadUrl, result.releaseNotes);
            }, 2000);
          }
        } else {
          addStatusLog(`Update check failed: ${result.error}`, 'warning');
        }
      } catch (error) {
        console.error('[Renderer] Error checking for updates:', error);
        addStatusLog(`Update check error: ${error.message || error}`, 'warning');
      }
    }

    // Update status bar initialization message
    function updateStatusInit(message) {
      const statusInit = document.getElementById('status-init');
      if (statusInit) {
        statusInit.textContent = message;
      }

      // Add to log (but not "Ready" messages to avoid spam)
      if (message !== 'Ready') {
        addStatusLog(message, 'info');
      } else {
        addStatusLog(message, 'success');
      }
    }

    // Update status with a minimum display time (so users can read it)
    // For now, just update immediately without delay to avoid blocking
    async function updateStatusInitWithDelay(message, minDisplayMs = 0) {
      updateStatusInit(message);
      // Small delay to allow UI to update
      if (minDisplayMs > 0) {
        await new Promise(resolve => setTimeout(resolve, minDisplayMs));
      }
    }

    // Update status bar profile
    function updateStatusProfile(profileName) {
      const statusProfile = document.getElementById('status-profile');
      if (statusProfile) {
        statusProfile.textContent = profileName || 'None';
      }
    }

    // Update status bar last saved
    function updateStatusLastSaved(timestamp) {
      const statusLastSaved = document.getElementById('status-last-saved');
      if (statusLastSaved) {
        if (timestamp) {
          const date = new Date(timestamp);
          statusLastSaved.textContent = date.toLocaleTimeString();
          // Clear unsaved indicator when saved
          markConfigSaved();
        } else {
          statusLastSaved.textContent = 'Never';
        }
      }
    }

    // Mark config as changed (unsaved)
    function markConfigChanged() {
      const unsavedIndicator = document.getElementById('status-unsaved');
      if (unsavedIndicator) {
        unsavedIndicator.style.display = 'inline';
        unsavedIndicator.title = 'Unsaved changes';
      }
    }

    // Mark config as saved
    function markConfigSaved() {
      const unsavedIndicator = document.getElementById('status-unsaved');
      if (unsavedIndicator) {
        unsavedIndicator.style.display = 'none';
      }
    }

    // Calculate text color based on background brightness
    function getTextColorForBackground(hexColor) {
      // Remove # if present
      const hex = hexColor.replace('#', '');

      // Convert to RGB
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);

      // Calculate relative luminance (perceived brightness)
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

      // Return dark text for light backgrounds, light text for dark backgrounds
      return luminance > 0.5 ? '#1a1a1a' : '#ffffff';
    }

    // Precomputed lookup table: u16 value (0‚Äì65535) ‚Üí display percentage (0‚Äì100)
    // Avoids per-sample log10 in the hot meter loop (computed once at startup)
    const u16ToPctLUT = new Float32Array(65536);
    for (let i = 1; i < 65536; i++) {
      const dB = 20 * Math.log10(i / 65535);
      u16ToPctLUT[i] = Math.max(0, Math.min(100, (dB + 60) / 60 * 100));
    }
    // u16ToPctLUT[0] = 0 (silence) ‚Äî already 0 by Float32Array initialization

    // Get color for meter based on level percentage
    function meterColor(pct) {
      if (pct < 70) return '#4CAF50';
      if (pct < 90) return '#f4c430';
      return '#f44336';
    }

    // Get color for always-visible indicator dot (grey when silent)
    function dotColor(pct) {
      if (pct <= 5)  return '#555';      // grey ‚Äî silent / no signal
      if (pct < 70)  return '#4CAF50';   // green ‚Äî nominal
      if (pct < 90)  return '#f4c430';   // yellow ‚Äî warning
      return '#f44336';                  // red ‚Äî peak
    }

    /**
     * Targeted update for MIDI device color ‚Äî sets the background of the mapping label.
     * Much faster than a full loadFaders() re-render.
     * @param {string} deviceName - the MIDI device name
     * @param {string} color - hex color string, or '' to clear the background
     */
    function applyDeviceColorToLabels(deviceName, color) {
      const deviceMissing = deviceName && !connectedMidiDevices.has(deviceName);
      for (const mapping of currentMappings) {
        if (mapping.midi.device !== deviceName) continue;
        const ch = mapping.mixer.channel;
        const faderId = ch.type ? `${ch.type}-${ch.channel}` : null;
        if (!faderId) continue;
        // Update label background/color
        document.querySelectorAll(`[data-fader-id="${faderId}"] .fader-mapping-info`).forEach(el => {
          if (deviceMissing) {
            el.style.background = '';
            el.style.color = '';
            el.style.borderColor = '';
            el.classList.add('device-missing');
          } else if (color) {
            el.style.background = color;
            el.style.color = getTextColorForBackground(color);
            el.style.borderColor = color;
            el.classList.remove('device-missing');
          } else {
            el.style.background = '';
            el.style.color = '';
            el.style.borderColor = '';
            el.classList.remove('device-missing');
          }
        });
        // Also update fader-container border
        document.querySelectorAll(`[data-fader-id="${faderId}"].fader-container, [data-fader-id="${faderId}"] .fader-container`).forEach(el => {
          if (deviceMissing) {
            el.style.borderColor = '';
            el.style.boxShadow = '';
            el.classList.add('device-missing');
          } else if (color) {
            el.style.borderColor = color;
            el.style.boxShadow = `0 0 4px ${color}66`;
            el.classList.remove('device-missing');
          } else {
            el.style.borderColor = '';
            el.style.boxShadow = '';
            el.classList.remove('device-missing');
          }
        });
      }
    }

    /**
     * Walk all rendered fader-mapping-info and fader-container elements,
     * applying or removing the device-missing class based on current connected state.
     */
    function updateMissingDeviceBorders() {
      for (const mapping of currentMappings) {
        const device = mapping.midi?.device;
        if (!device) continue;
        const ch = mapping.mixer.channel;
        const faderId = ch.type ? `${ch.type}-${ch.channel}` : null;
        if (!faderId) continue;
        const missing = !connectedMidiDevices.has(device);
        document.querySelectorAll(`[data-fader-id="${faderId}"] .fader-mapping-info`).forEach(el => {
          if (missing) {
            el.style.background = '';
            el.style.color = '';
            el.style.borderColor = '';
            el.classList.add('device-missing');
          } else {
            el.classList.remove('device-missing');
            // Re-apply device color if set
            const color = midiDeviceColors[device] || '';
            if (color) {
              el.style.background = color;
              el.style.color = getTextColorForBackground(color);
              el.style.borderColor = color;
            }
          }
        });
        document.querySelectorAll(`[data-fader-id="${faderId}"].fader-container, [data-fader-id="${faderId}"] .fader-container`).forEach(el => {
          if (missing) {
            el.style.borderColor = '';
            el.style.boxShadow = '';
            el.classList.add('device-missing');
          } else {
            el.classList.remove('device-missing');
            const color = midiDeviceColors[device] || '';
            if (color) {
              el.style.borderColor = color;
              el.style.boxShadow = `0 0 4px ${color}66`;
            }
          }
        });
      }
    }

    // Apply level visibility settings to all faders
    function applyLevelVisibilitySettings() {
      // Show/hide meter bars based on visibility setting
      document.querySelectorAll('.fader-meter').forEach(el => {
        el.style.display = currentLevelVisibility === 'meter' ? '' : 'none';
      });
      // Indicator dots are always visible ‚Äî no show/hide needed
      // Update preference UI
      const sel = document.getElementById('level-visibility-select');
      if (sel) sel.value = currentLevelVisibility;
      const chk = document.getElementById('peak-hold-check');
      if (chk) chk.checked = currentPeakHold;
    }

    // Icon mapping from Universal Control icon IDs to emoji
    // Based on PreSonus StudioLive icon categories
    const ICON_MAP = {
      // Drums
      'drumpad': 'üéõÔ∏è',        // Digital drum pad
      'drumset': 'ü•Å',
      'drums': 'ü•Å',
      'kickin': 'ü•Å',
      'kickout': 'ü•Å',
      'kick': 'ü•Å',
      'snare': 'ü•Å',
      'snaretop': 'ü•Å',
      'snarebottom': 'ü•Å',
      'racktom': 'ü•Å',
      'floortom': 'ü•Å',
      'midtom': 'ü•Å',
      'hihat': 'ü•Å',
      'hightom': 'ü•Å',
      'ohleft': 'ü•Å',
      'ohright': 'ü•Å',
      'oh': 'ü•Å',

      // Guitars
      'electricguitar': 'üé∏',
      'electric2': 'üé∏',
      'electric': 'üé∏',
      'acousticguitar': '<img src="icons/acoustic-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'acoustic2': '<img src="icons/acoustic-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'acoustic': '<img src="icons/acoustic-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'bass': '<img src="icons/bass-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'bassguitar': '<img src="icons/bass-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'electricbass': '<img src="icons/bass-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'acousticbass': '<img src="icons/bass-guitar.svg" style="width:1em;height:1em;display:inline-block;vertical-align:middle;" />',
      'upright': 'üéª',         // Upright/double bass uses violin emoji
      'uprightbass': 'üéª',
      'doublebass': 'üéª',
      'dobro': 'ü™ï',
      'banjo': 'ü™ï',
      'guitar': 'üé∏',
      'mandolin': 'ü™ï',
      'pedalsteel': 'üé∏',
      'shamisen': 'üé∏',
      'sitar': 'ü™ï',
      'ukulele': 'ü™ï',

      // Keyboards
      'piano': 'üéπ',
      'organ': 'üéπ',
      'pipeorgan': 'üéπ',
      'keys': 'üéπ',
      'keyboard': 'üéπ',
      'keyboardstier': 'üéπ',
      'synth': 'üéπ',
      'vibraphone': 'üéπ',
      'accordion': 'ü™ó',
      'clavinet': 'üéπ',
      'harpsichord': 'üéπ',

      // Other (most important for your use case)
      'metronome': 'üéº',       // Metronome/click (using musical score icon)
      'click': 'üéº',
      'computer': 'üíª',        // Computer/backing
      'backing': 'üíª',
      'headphones': 'üéß',      // Headphones/headset
      'headphone': 'üéß',
      'headset': 'üéß',
      'microphone': 'üé§',
      'mic': 'üé§',
      'broadcaster': 'üìª',
      'djbox': 'üéõÔ∏è',
      'externalfx': '‚ú®',
      'firewire': 'üîå',
      'fohmain': 'üîä',
      'handclap': 'üëè',
      'iem': 'üéß',
      'ipad': 'üì±',
      'ipod': 'üì±',
      'mix': 'üéõÔ∏è',
      'phone': 'üì±',
      'rock': 'üé∏',
      'sidefillmonitor': 'üîä',
      'smiley': 'üòä',
      'ssd': 'üíæ',
      'tablet': 'üì±',
      'talkback': 'üí¨',
      'telephone': '‚òéÔ∏è',
      'thumbup': 'üëç',
      'turntable': 'üíø',
      'video': 'üìπ',
      'wedgemonitor': 'üîä',
      'wirelessmic': 'üé§',
      'cryroom': 'üë∂',
      'delayfill': 'üîä',

      // Percussion
      'bell': 'üîî',
      'bongo': 'ü•Å',
      'chimes': 'üéê',
      'congas': 'ü•Å',
      'cowbell': 'üîî',
      'cymbal': 'ü•Å',
      'cymbals': 'ü•Å',
      'handpan': 'ü•Å',
      'kalimba': 'üéπ',
      'miscperc': 'ü•Å',
      'orchestrdrum': 'ü•Å',
      'shakers': 'ü•Å',
      'steeldrum': 'ü•Å',
      'tambourine': 'ü•Å',
      'timbales': 'ü•Å',
      'timpani': 'ü•Å',
      'triangle': 'üî∫',
      'washboard': 'ü•Å',
      'woodblock': 'ü•Å',
      'xylophone': 'üéπ',
      'percussion': 'ü•Å',

      // Strings
      'cello': 'üéª',
      'fiddle': 'üéª',
      'harp': 'üéª',
      'stringsection': 'üéª',
      'uprightbass': 'üéª',
      'viola': 'üéª',
      'violin': 'üéª',
      'strings': 'üéª',

      // Vocals
      'backupvocals': 'üé§',
      'choirsingle': 'üé§',
      'choir': 'üé§',
      'crowdambient': 'üé§',
      'leadvocals': 'üé§',
      'speech': 'üé§',
      'vocalcue': 'üé§',
      'vocalmic': 'üé§',
      'vocals': 'üé§',
      'vocal': 'üé§',

      // Woodwinds
      'altosaxophone': 'üé∑',
      'baritone': 'üé∑',
      'bassclarinet': 'üé∑',
      'bassoon': 'üé∑',
      'clarinet': 'üé∑',
      'flute': 'üé∑',
      'oboe': 'üé∑',
      'sax': 'üé∑',
      'saxophone': 'üé∑',
      'sopranophone': 'üé∑',
      'tenorsaphone': 'üé∑',
      'woodwinds': 'üé∑',

      // Brass
      'brasssection': 'üé∫',
      'brass': 'üé∫',
      'cornet': 'üé∫',
      'flugelhorn': 'üé∫',
      'frenchhorn': 'üé∫',
      'trombone': 'üé∫',
      'trumpet': 'üé∫',
      'tuba': 'üé∫',

      // FX and routing
      'fx': '‚ú®',
      'effect': '‚ú®',
      'return': '‚Ü©Ô∏è',
      'aux': 'üîä',
      'main': 'üîä',

      // Default
      'default': 'üéöÔ∏è'
    };

    function getIconForId(iconId, channelType, channelNum) {
      if (!iconId) return '';
      const id = iconId.toLowerCase().replace(/[_\s-\/]/g, '');  // Remove separators including slashes

      // Check for specific matches first (order matters - more specific before generic!)
      const orderedKeys = [
        // Specific drum parts first
        'drumpad', 'drumset', 'snarebottom', 'snaretop', 'racktom', 'floortom', 'midtom',
        'hightom', 'kickin', 'kickout', 'ohleft', 'ohright', 'hihat',
        // Then generic drums
        'kick', 'snare', 'drums', 'oh',
        // Specific guitars
        'electricguitar', 'electric2', 'acousticguitar', 'acoustic2', 'uprightbass',
        // Then generic guitars
        'electric', 'acoustic', 'bass', 'guitar', 'dobro', 'banjo', 'mandolin',
        'pedalsteel', 'shamisen', 'sitar', 'ukulele',
        // Keyboards - specific first
        'pipeorgan', 'keyboardstier', 'vibraphone', 'harpsichord',
        // Then generic keyboards
        'piano', 'organ', 'keys', 'keyboard', 'synth', 'accordion', 'clavinet',
        // Other (important for your channels)
        'metronome', 'computer', 'headphones', 'headphone', 'headset', 'microphone',
        'broadcaster', 'djbox', 'externalfx', 'firewire', 'fohmain', 'handclap',
        'sidefillmonitor', 'wedgemonitor', 'wirelessmic', 'cryroom', 'delayfill',
        'iem', 'ipad', 'ipod', 'mix', 'phone', 'rock', 'smiley', 'ssd', 'tablet',
        'talkback', 'telephone', 'thumbup', 'turntable', 'video',
        // Percussion - specific first
        'orchestrdrum', 'miscperc', 'steeldrum', 'bassclarinet', 'altosaxophone',
        'tenorsaphone', 'sopranophone', 'brasssection', 'stringsection', 'backupvocals',
        'leadvocals', 'choirsingle', 'crowdambient', 'vocalcue', 'vocalmic',
        // Then generic percussion
        'bell', 'bongo', 'chimes', 'congas', 'cowbell', 'cymbal', 'cymbals', 'handpan',
        'kalimba', 'shakers', 'tambourine', 'timbales', 'timpani', 'triangle',
        'washboard', 'woodblock', 'xylophone', 'percussion',
        // Strings
        'cello', 'fiddle', 'harp', 'viola', 'violin', 'strings',
        // Vocals
        'choir', 'speech', 'vocals', 'vocal', 'mic',
        // Woodwinds
        'bassoon', 'baritone', 'clarinet', 'flute', 'oboe', 'saxophone', 'sax', 'woodwinds',
        // Brass
        'frenchhorn', 'flugelhorn', 'cornet', 'trombone', 'trumpet', 'tuba', 'brass',
        // FX and routing
        'fx', 'effect', 'return', 'aux', 'main'
      ];

      for (const key of orderedKeys) {
        if (id.includes(key)) {
          return ICON_MAP[key];
        }
      }

      return ICON_MAP.default;
    }

    // Sidebar toggle
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('open');
    }

    // Open specific connection panel
    function openConnectionPanel(type) {
      if (type === 'midi') {
        showMidiSelect();
      } else if (type === 'mixer') {
        showDiscovery();
      }
    }

    // Flash activity indicator (supports multiple IDs). Optional devColor overrides default.
    function flashActivity(baseId, devColor) {
      const ids = [baseId, `status-${baseId}`];
      ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          if (devColor) el.style.background = devColor;
          el.classList.add('active');
          setTimeout(() => {
            el.classList.remove('active');
            if (devColor) el.style.background = '';
          }, 200);
        }
      });
    }

    // Add change source indicator to fader
    let changeIndicatorTimeouts = new Map();
    function indicateFaderChange(channelType, channelNum, source) {
      const faderId = `${channelType}-${channelNum}`;
      const faderChannel = document.querySelector(`[data-fader-id="${faderId}"]`)?.closest('.fader-channel');

      if (faderChannel) {
        // Clear existing timeout
        const key = faderId;
        if (changeIndicatorTimeouts.has(key)) {
          clearTimeout(changeIndicatorTimeouts.get(key));
        }

        // Remove all change classes
        faderChannel.classList.remove('change-midi', 'change-api', 'change-ui');

        // Add appropriate class
        if (source === 'midi') {
          faderChannel.classList.add('change-midi');
        } else if (source === 'api') {
          faderChannel.classList.add('change-api');
        } else if (source === 'ui') {
          faderChannel.classList.add('change-ui');
        }

        // Remove after 300ms
        const timeout = setTimeout(() => {
          faderChannel.classList.remove('change-midi', 'change-api', 'change-ui');
          changeIndicatorTimeouts.delete(key);
        }, 300);

        changeIndicatorTimeouts.set(key, timeout);
      }
    }

    // MIDI Log functionality
    const midiLogEntries = [];
    const MAX_MIDI_LOG_ENTRIES = 100;

    function toggleMidiLog() {
      const logWindow = document.getElementById('midi-log-window');
      logWindow.classList.toggle('show');
    }

    function clearMidiLog() {
      midiLogEntries.length = 0;
      const logContent = document.getElementById('midi-log-content');
      logContent.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No MIDI events yet...</div>';
    }

    function addMidiLogEntry(midiMessage) {
      const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });

      let type = 'unknown';
      let details = '';

      if (midiMessage.type === 'cc') {
        type = 'cc';
        details = `CC${midiMessage.controller} Ch${midiMessage.channel} = ${midiMessage.value}`;
      } else if (midiMessage.type === 'note_on') {
        type = 'note';
        const noteName = getNoteNameFromNumber(midiMessage.note);
        details = `Note ON ${noteName} (${midiMessage.note}) Ch${midiMessage.channel} Vel=${midiMessage.value}`;
      } else if (midiMessage.type === 'note_off') {
        type = 'note';
        const noteName = getNoteNameFromNumber(midiMessage.note);
        details = `Note OFF ${noteName} (${midiMessage.note}) Ch${midiMessage.channel}`;
      } else if (midiMessage.type === 'pitch_bend') {
        type = 'cc';
        details = `Pitch Bend Ch${midiMessage.channel} = ${midiMessage.value}`;
      }

      const entry = { timestamp, type, details };
      midiLogEntries.push(entry);

      // Keep only last MAX_MIDI_LOG_ENTRIES
      if (midiLogEntries.length > MAX_MIDI_LOG_ENTRIES) {
        midiLogEntries.shift();
      }

      // Update UI
      const logContent = document.getElementById('midi-log-content');
      const entryDiv = document.createElement('div');
      entryDiv.className = `midi-log-entry ${type}`;
      entryDiv.innerHTML = `<span class="midi-log-timestamp">${timestamp}</span><span class="midi-log-type">${type.toUpperCase()}</span><span class="midi-log-details">${details}</span>`;

      logContent.appendChild(entryDiv);

      // Remove placeholder if exists
      const placeholder = logContent.querySelector('div[style*="color: #666"]');
      if (placeholder) {
        placeholder.remove();
      }

      // Auto-scroll to bottom
      logContent.scrollTop = logContent.scrollHeight;

      // Keep only last MAX_MIDI_LOG_ENTRIES in DOM
      while (logContent.children.length > MAX_MIDI_LOG_ENTRIES) {
        logContent.removeChild(logContent.firstChild);
      }
    }

    function getNoteNameFromNumber(noteNumber) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const octave = Math.floor(noteNumber / 12) - 1;
      const noteName = noteNames[noteNumber % 12];
      return `${noteName}${octave}`;
    }

    // Helper function to get CC shorthand name
    function getCCShorthand(ccNumber) {
      const CC_SHORTHAND = {
        1: 'Mod',
        2: 'Breath',
        7: 'Vol',
        10: 'Pan',
        11: 'Expr',
        64: 'Sus',
        71: 'Res',
        74: 'Bright',
        91: 'Rev',
        93: 'Chor',
        102: 'Vol2',
        103: 'Pan2',
        104: 'Expr2'
      };
      return CC_SHORTHAND[ccNumber] || `CC${ccNumber}`;
    }

    // Listen for preset loaded event (from default preset on startup)
    ipcRenderer.on('preset-loaded', async (data) => {
      if (data.name) {
        updateStatusProfile(data.name);
        const savedDisplay = data.mtime
          ? new Date(data.mtime).toLocaleString([], { dateStyle: 'short', timeStyle: 'short' })
          : new Date().toLocaleTimeString();
        updateStatusLastSaved(savedDisplay);

        // Load fader filter state from preset
        const filter = await ipcRenderer.invoke('get-fader-filter');
        if (filter) {
          faderFilter = filter;
          const filterSelect = document.getElementById('filter-select');
          if (filterSelect) {
            filterSelect.value = faderFilter;
          }
        }
      }
    });

    // Load level visibility preference
    ipcRenderer.invoke('get-level-visibility').then(prefs => {
      if (prefs) {
        currentLevelVisibility = prefs.visibility || 'none';
        currentPeakHold = prefs.peakHold || false;
        applyLevelVisibilitySettings();
      }
    });

    // Load MIDI device colors
    ipcRenderer.invoke('get-midi-device-colors').then(colors => {
      if (colors) {
        Object.assign(midiDeviceColors, colors);
      }
    });

    // Helper: flash mapping-list activity dots for a given device
    function flashMappingActivityForDevice(device, devColor) {
      currentMappings.forEach((m, idx) => {
        if (!device || m.midi.device !== device) return;
        const el = document.getElementById(`mapping-activity-${idx}`);
        if (!el) return;
        if (devColor) { el.style.background = devColor; el.style.boxShadow = `0 0 12px ${devColor}`; }
        el.classList.add('active');
        setTimeout(() => {
          el.classList.remove('active');
          el.style.background = '';
          el.style.boxShadow = '';
        }, 300);
      });
    }

    // Listen for MIDI activity
    ipcRenderer.on('midi-activity', async (midiMessage) => {
      const devColor = midiMessage.device ? (midiDeviceColors[midiMessage.device] || '') : '';
      flashActivity('midi-activity', devColor);
      flashMappingActivityForDevice(midiMessage.device, devColor);
      addMidiLogEntry(midiMessage);

      // MIDI learn: intercept and auto-fill form fields
      if (midiLearnActive && (midiMessage.type === 'cc' || midiMessage.type === 'note_on')) {
        applyMidiLearnResult(midiMessage, midiMessage.device);
        return;
      }

      // Update MIDI indicator for CC messages
      if (midiMessage.type === 'cc') {
        // Use cached currentMappings to avoid IPC round-trip on every MIDI message
        const mapping = currentMappings.find(m =>
          m.midi.type === 'cc' &&
          m.midi.channel === midiMessage.channel &&
          m.midi.controller === midiMessage.controller
        );
        if (mapping) {
          const channelType = mapping.mixer.channel.type || 'LINE';
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          updateMidiIndicator(channelType, channelNum, midiMessage.value);
          indicateFaderChange(channelType, channelNum, 'midi');
        }
      }
    });

    // Listen for mixer activity
    ipcRenderer.on('mixer-activity', (mixerCommand) => {
      flashActivity('mixer-activity');

      // Update fader if it's a volume command
      if (mixerCommand.action === 'volume' && mixerCommand.value !== undefined && mixerCommand.channel) {
        const channelType = mixerCommand.channel.type || 'LINE';
        const channelNum = mixerCommand.channel.channel;
        updateFaderByValue(channelType, channelNum, mixerCommand.value);
        indicateFaderChange(channelType, channelNum, 'midi');
      }
    });

    // Listen for mixer level changes (from physical mixer or Universal Control)
    ipcRenderer.on('mixer-level', (data) => {
      flashActivity('mixer-activity');
      // data.channel.type, data.channel.channel, data.level
      // Update fader for any channel type (LINE, MAIN, AUX, etc.)
      if (data.channel) {
        updateFaderByValue(data.channel.type, data.channel.channel, data.level);
        indicateFaderChange(data.channel.type, data.channel.channel, 'api');

        // Update MIDI indicator to match fader position when quiescent
        updateMidiIndicatorToFader(data.channel.type, data.channel.channel, data.level);
      }
    });

    // Listen for mixer state ready event (when channel names are available)
    let mixerStateReadyHandled = false;
    let mixerStateReadyTimestamp = 0;
    ipcRenderer.on('mixer-state-ready', async () => {
      const now = Date.now();

      // Prevent duplicate handling if event fires multiple times within 15 seconds
      if (mixerStateReadyHandled && (now - mixerStateReadyTimestamp) < 15000) {
        return;
      }
      mixerStateReadyHandled = true;
      mixerStateReadyTimestamp = now;


      // Get mixer info now that state is ready
      const mixerStatus = await ipcRenderer.invoke('get-mixer-status');

      // Prefer deviceName, then model, then name
      // Don't show both if they're the same
      const deviceName = mixerStatus.deviceName || '';
      const model = mixerStatus.model || '';
      const name = mixerStatus.name || '';

      let displayText = 'Unknown';
      if (deviceName && model && deviceName !== model) {
        displayText = `${deviceName} (${model})`;
      } else if (deviceName) {
        displayText = deviceName;
      } else if (model) {
        displayText = model;
      } else if (name) {
        displayText = name;
      }

      await updateStatusInitWithDelay(`Connected to ${displayText}`);
      await updateStatusInitWithDelay('Mixer connected - loading channels...');

      // Load mappings first (populates currentMappings global variable)
      await loadMappings();

      // Then load faders (which will call loadMuteGroups at the end)
      loadFaders().then(() => {
        // loadFaders will set status to 'Ready' when complete
      }).catch(err => {
        const errorMsg = `Error: ${err.message || 'Failed to load channels'}`;
        updateStatusInit(errorMsg);
        addStatusLog(errorMsg, 'error');
      });
    });

    // Listen for connection events (initial connect or reconnect)
    ipcRenderer.on('connection-restored', (data) => {
      if (data.type === 'midi') {
        addStatusLog(`MIDI connected: ${data.device}`, 'success');
        if (data.device) {
          connectedMidiDevices.add(data.device);
          updateMissingDeviceBorders();
        }
      } else if (data.type === 'mixer') {
        addStatusLog(`Mixer connected: ${data.ip}`, 'success');
      }
      updateStatus();
    });

    // Listen for mixer disconnection ‚Äî update status bar warning immediately
    ipcRenderer.on('mixer-lost', () => {
      addStatusLog('Mixer disconnected ‚Äî searching for reconnect', 'warning');
      updateStatus();
    });

    // Listen for MIDI device loss ‚Äî update status and fader borders immediately
    ipcRenderer.on('midi-device-lost', (deviceName) => {
      if (deviceName) {
        connectedMidiDevices.delete(deviceName);
        updateMissingDeviceBorders();
        addStatusLog(`MIDI disconnected: ${deviceName}`, 'warning');
      }
      updateStatus();
    });

    // Listen for mixer mute changes (from physical mixer or Universal Control)
    ipcRenderer.on('mixer-mute', (data) => {
      // data.channel.type, data.channel.channel, data.status
      if (data.channel) {
        updateMuteButton(data.channel.type, data.channel.channel, data.status);
      }
    });

    // Listen for mixer solo changes (from physical mixer or Universal Control)
    ipcRenderer.on('mixer-solo', (data) => {
      // data.channel.type, data.channel.channel, data.status
      if (data.channel) {
        updateSoloButton(data.channel.type, data.channel.channel, data.status);
      }
    });

    // Listen for mixer meter data ‚Äî direct DOM writes for minimum latency
    // (IPC payload is already just the INPUT_SIGNAL u16 array from main process)
    ipcRenderer.on('mixer-meter', (inputLevels) => {
      if (!inputLevels) return;

      const isMeter = currentLevelVisibility === 'meter';
      const now = Date.now();

      for (let i = 0; i < inputLevels.length; i++) {
        const faderId = `LINE-${i + 1}`;
        const pct = u16ToPctLUT[inputLevels[i]];

        // Indicator dot is always visible: grey when silent, color when active
        const dot = meterDotEls[faderId];
        if (dot) dot.style.background = dotColor(pct);

        if (isMeter) {
          const color = meterColor(pct);
          const fill = meterFillEls[faderId];
          if (fill) {
            fill.style.height = pct + '%';
            fill.style.background = color;
          }

          if (currentPeakHold) {
            const pk = peakData[faderId] || { value: 0, ts: 0 };
            if (pct >= pk.value) {
              peakData[faderId] = { value: pct, ts: now };
              const pkEl = meterPeakEls[faderId];
              if (pkEl) {
                pkEl.style.display = 'block';
                pkEl.style.bottom = pct + '%';
                pkEl.style.background = color;
              }
            } else if (now - pk.ts > PEAK_HOLD_MS) {
              peakData[faderId] = { value: 0, ts: 0 };
              const pkEl = meterPeakEls[faderId];
              if (pkEl) pkEl.style.display = 'none';
            }
          }
        }
      }
    });

    // Listen for mixer property changes (main assignment, input source, etc.)
    ipcRenderer.on('mixer-property-change', async (data) => {
      // Log all property changes to see what we're getting

      // data.channel.type, data.channel.channel, data.value, data.type
      if (data.channel && data.type) {
        const channelType = data.channel.type;
        const channelNum = data.channel.channel;

        if (data.type === 'lr') {
          // Main assignment changed
          updateMainAssignIndicator(channelType, channelNum, data.value);
        } else if (data.type === 'inputsrc') {
          // Input source changed
          updateInputSourceIndicator(channelType, channelNum, data.value);
        } else if (data.type === 'icon') {
          // Channel icon changed
          updateChannelIcon(channelType, channelNum, data.value);
        } else if (data.type === 'name') {
          // Channel name changed
          updateChannelName(channelType, channelNum, data.value);
        } else if (data.type === 'link') {
          // Channel link status changed - need to reload faders
          loadFaders();
        } else if (data.type === 'mute') {
          // Channel mute state changed
          updateMuteButton(channelType, channelNum, data.value);
        }
      }

      // Check if this is a mute group state change
      // The path might be something like "mutegroup/mutegroup1"
      if (data.path && data.path.includes('mutegroup/mutegroup')) {
        const match = data.path.match(/mutegroup\/mutegroup(\d+)$/);
        if (match) {
          const groupNum = parseInt(match[1], 10);
          const muteGroupActive = data.value > 0;

          // Update the mute group button state
          const button = document.getElementById(`mute-group-${groupNum}`);
          if (button) {
            if (muteGroupActive) {
              button.classList.add('active');
            } else {
              button.classList.remove('active');
            }
          }

          // Update the mute button states for all channels in this mute group
          // NOTE: The mixer doesn't change individual channel mute states when a mute group is activated.
          // The mute group acts as a "master mute" that overrides individual states.
          // So we set the visual state based on the mute group state, not the individual channel states.
          const assignments = await ipcRenderer.invoke('get-mute-group-assignments', groupNum);

          for (const assignment of assignments) {
            // If mute group is active, show channels as muted
            // If mute group is inactive, query the actual channel mute state
            if (muteGroupActive) {
              updateMuteButton(assignment.type, assignment.channel, true);
            } else {
              // Query the actual channel mute state
              const muted = await ipcRenderer.invoke('get-channel-mute', assignment.type, assignment.channel);
              if (muted !== null) {
                updateMuteButton(assignment.type, assignment.channel, muted);
              }
            }
          }
        }
      }
    });

    // Update fader visual (value is 0-1)
    function updateFader(channel, value) {
      const faderFill = document.getElementById(`fader-fill-${channel}`);
      const faderValue = document.getElementById(`fader-value-${channel}`);
      if (faderFill && faderValue) {
        const percentage = Math.round(value * 100);
        faderFill.style.height = `${percentage}%`;
        faderValue.textContent = `${percentage}%`;
      }
    }

    // Update fader visual by percentage value (value is 0-100)
    // channelType and channelNum are used to create unique fader ID
    function updateFaderByValue(channelType, channelNum, percentage) {
      const faderId = `${channelType}-${channelNum}`;
      const faderFill = document.getElementById(`fader-fill-${faderId}`);
      const faderValue = document.getElementById(`fader-value-${faderId}`);

      if (faderFill) {
        const roundedPercentage = Math.round(percentage);

        // Calculate delta for smoothing
        const currentHeight = parseFloat(faderFill.style.height) || 0;
        const delta = Math.abs(roundedPercentage - currentHeight);

        // Only update if there's a meaningful change (reduces jitter)
        if (delta < 0.5) return;

        // Use consistent transition speed for smoother motion
        // Longer transitions for larger movements
        const transitionSpeed = delta > 10 ? faderSmoothingSpeed : Math.min(delta * 30, faderSmoothingSpeed);

        // Apply smooth transition with ease-out for more natural motion
        faderFill.style.transition = `height ${transitionSpeed}ms ease-out`;
        faderFill.style.height = `${roundedPercentage}%`;
        // faderValue may not exist for the right side of stereo pairs
        if (faderValue) {
          faderValue.textContent = `${roundedPercentage}%`;
        }
      }
    }

    // Store timeout IDs for hiding MIDI indicators
    const midiIndicatorTimeouts = new Map();

    // Update MIDI indicator position based on MIDI value (0-127)
    function updateMidiIndicator(channelType, channelNum, midiValue) {
      const faderId = `${channelType}-${channelNum}`;
      const midiIndicator = document.getElementById(`fader-midi-${faderId}`);
      if (midiIndicator) {
        // Apply device color if available, otherwise orange default
        const mapping = currentMappings.find(m => {
          const ch = m.mixer.channel;
          return (ch.type || 'LINE') === channelType && (ch.channel || ch) === channelNum;
        });
        const devColor = mapping?.midi?.device ? (midiDeviceColors[mapping.midi.device] || '') : '';
        const lineColor = devColor || '#ff9800';
        midiIndicator.style.background = lineColor;
        midiIndicator.style.boxShadow = `0 0 8px ${lineColor}cc`;

        // Convert MIDI value (0-127) to percentage (0-100)
        // This matches the mapping engine's conversion: value / 127 * 100
        const percentage = (midiValue / 127) * 100;
        midiIndicator.style.bottom = `${percentage}%`;
        midiIndicator.style.display = 'block';

        // Clear existing timeout
        if (midiIndicatorTimeouts.has(faderId)) {
          clearTimeout(midiIndicatorTimeouts.get(faderId));
        }

        // Hide indicator after 2 seconds of no MIDI activity
        const timeout = setTimeout(() => {
          midiIndicator.style.display = 'none';
          midiIndicatorTimeouts.delete(faderId);
        }, 2000);
        midiIndicatorTimeouts.set(faderId, timeout);
      }
    }

    // Update MIDI indicator to match fader position (when quiescent)
    function updateMidiIndicatorToFader(channelType, channelNum, percentage) {
      const faderId = `${channelType}-${channelNum}`;
      const midiIndicator = document.getElementById(`fader-midi-${faderId}`);

      // Only update if there's no active MIDI timeout (not currently showing MIDI activity)
      if (midiIndicator && !midiIndicatorTimeouts.has(faderId)) {
        midiIndicator.style.bottom = `${percentage}%`;
        // Keep it hidden - it will show when MIDI activity occurs
        midiIndicator.style.display = 'none';
      }
    }

    // Tab switching
    function showTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');

      // Update tab content
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById(`${tabName}-view`).classList.add('active');
    }

    // Modal functions
    async function showDiscovery() {
      document.getElementById('discovery-modal').classList.add('show');

      // Pre-fill from current or remembered mixer status
      try {
        const mixerStatus = await ipcRenderer.invoke('get-mixer-status');

        // Pre-fill manual IP field with current or preferred IP
        const manualIpInput = document.getElementById('manual-ip');
        const ip = mixerStatus.ip || mixerStatus.preferredIp;
        if (manualIpInput && ip) {
          manualIpInput.value = ip;
        }

        // If there's a remembered mixer and we haven't scanned yet, show it at top
        const listEl = document.getElementById('mixer-list');
        const prefIp = mixerStatus.preferredIp;
        if (prefIp && listEl && !listEl.querySelector('.mixer-item')) {
          // Use live data if connected, otherwise use remembered metadata
          const displayIp = mixerStatus.ip || prefIp;
          const displayModel = mixerStatus.model || mixerStatus.preferredModel || '';
          const displayDeviceName = mixerStatus.deviceName || mixerStatus.preferredDeviceName || '';
          const displaySerial = mixerStatus.serial || mixerStatus.preferredSerial || '';

          listEl.innerHTML = '';
          const div = document.createElement('div');
          div.className = 'mixer-item' + (mixerStatus.connected ? ' connected-device' : '');
          div.setAttribute('data-ip', displayIp);
          div.title = `IP: ${displayIp}\nModel: ${displayModel}${displayDeviceName ? '\nDevice Name: ' + displayDeviceName : ''}\nSerial: ${displaySerial}${mixerStatus.connected ? '\n‚úì Currently connected' : ''}`;

          const infoDiv = document.createElement('div');
          infoDiv.className = 'mixer-info';

          const nameDiv = document.createElement('div');
          nameDiv.className = 'mixer-name';
          nameDiv.textContent = displayIp + (displayModel ? ' ‚Äî ' + displayModel : '') + (displayDeviceName ? ' ' + displayDeviceName : '');

          const detailDiv = document.createElement('div');
          detailDiv.className = 'mixer-details';
          detailDiv.textContent = (displaySerial ? 'Serial: ' + displaySerial : '') + (mixerStatus.connected ? ' ‚úì Connected' : ' (remembered ‚Äî scan to verify)');

          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.textContent = mixerStatus.connected ? 'Reconnect' : 'Connect';
          btn.addEventListener('click', () => connectToMixer(displayIp, displayModel, displayDeviceName, displaySerial));

          infoDiv.appendChild(nameDiv);
          infoDiv.appendChild(detailDiv);
          div.appendChild(infoDiv);
          div.appendChild(btn);
          listEl.appendChild(div);
        }
      } catch (error) {
        console.error('Error getting mixer status:', error);
      }
    }

    function hideDiscovery() {
      document.getElementById('discovery-modal').classList.remove('show');
    }

    function updateMidiTypeFields() {
      const midiType = document.getElementById('midi-type').value;
      const mixerAction = document.getElementById('mixer-action').value;
      const ccGroup = document.getElementById('cc-group');
      const ccThresholdGroup = document.getElementById('cc-threshold-group');
      const noteGroup = document.getElementById('note-group');
      const noteInvertGroup = document.getElementById('note-invert-group');
      const noteValueGroup = document.getElementById('note-value-group');
      const midiChannelGroup = document.getElementById('midi-channel-group');
      const deviceFilterGroup = document.getElementById('midi-device-filter-group');
      const listenGroup = document.getElementById('midi-listen-group');

      // Determine if this is a boolean control (mute/solo/mutegroup)
      const isBooleanControl = mixerAction === 'mute' || mixerAction === 'solo' || mixerAction === 'mutegroup';

      if (midiType === 'none') {
        ccGroup.style.display = 'none';
        ccThresholdGroup.style.display = 'none';
        noteGroup.style.display = 'none';
        noteInvertGroup.style.display = 'none';
        noteValueGroup.style.display = 'none';
        midiChannelGroup.style.display = 'none';
        deviceFilterGroup.style.display = 'none';
        listenGroup.style.display = 'none';
      } else if (midiType === 'cc') {
        ccGroup.style.display = 'block';
        ccThresholdGroup.style.display = isBooleanControl ? 'block' : 'none';
        noteGroup.style.display = 'none';
        noteInvertGroup.style.display = 'none';
        noteValueGroup.style.display = 'none';
      } else if (midiType === 'note') {
        ccGroup.style.display = 'none';
        ccThresholdGroup.style.display = 'none';
        noteGroup.style.display = 'block';
        noteInvertGroup.style.display = isBooleanControl ? 'block' : 'none';
        noteValueGroup.style.display = 'none';
        updateNoteDisplay();
      } else if (midiType === 'note-value') {
        ccGroup.style.display = 'none';
        ccThresholdGroup.style.display = 'none';
        noteGroup.style.display = 'none';
        noteInvertGroup.style.display = 'none';
        noteValueGroup.style.display = 'block';
        updateNoteMinDisplay();
        updateNoteMaxDisplay();
      }
      // Restore MIDI channel / device filter / learn for all real MIDI types
      if (midiType !== 'none') {
        midiChannelGroup.style.display = '';
        deviceFilterGroup.style.display = '';
        listenGroup.style.display = '';
      }
    }

    function updateNoteDisplay() {
      const noteNum = parseInt(document.getElementById('midi-note').value) || 60;
      const noteName = getNoteNameFromNumber(noteNum);
      document.getElementById('note-display').textContent = `${noteName} (${noteNum})`;
    }

    function updateNoteMinDisplay() {
      const noteNum = parseInt(document.getElementById('midi-note-min').value) || 24;
      const noteName = getNoteNameFromNumber(noteNum);
      document.getElementById('note-min-display').textContent = `${noteName} (${noteNum})`;
    }

    function updateNoteMaxDisplay() {
      const noteNum = parseInt(document.getElementById('midi-note-max').value) || 60;
      const noteName = getNoteNameFromNumber(noteNum);
      document.getElementById('note-max-display').textContent = `${noteName} (${noteNum})`;
    }

    function showAddMapping() {
      const modal = document.getElementById('add-mapping-modal');
      const modalTitle = modal.querySelector('h2');

      // Reset modal to "add" mode
      modalTitle.textContent = '‚ûï Create Mapping';
      delete modal.dataset.editingIndex;
      document.getElementById('mapping-submit-btn').textContent = 'Add Mapping';
      document.getElementById('mapping-clear-btn').style.display = 'none';

      // Reset form to defaults
      document.getElementById('midi-type').value = 'cc';
      // Don't set midi-channel here - let updateMidiSettingsForChannel() set it based on mixer channel
      document.getElementById('midi-cc').value = '7'; // Default to CC7 (Volume)
      document.getElementById('midi-cc-threshold').value = '64'; // Default threshold
      document.getElementById('midi-note').value = '60';
      document.getElementById('midi-note-invert').checked = false; // Default not inverted
      document.getElementById('midi-note-min').value = '24';
      document.getElementById('midi-note-max').value = '60';
      document.getElementById('mixer-action').value = 'volume';
      document.getElementById('mixer-channel-type').value = 'LINE';
      updateMidiTypeFields();

      // Reset device filter and populate with connected devices
      document.getElementById('midi-device-filter').value = '';
      populateMidiDeviceFilter();

      modal.classList.add('show');
      updateChannelNumberOptions(); // Populate channel numbers and auto-set MIDI settings (including MIDI channel)
    }

    async function populateMidiDeviceFilter(selectedDevice) {
      const select = document.getElementById('midi-device-filter');
      const devices = await ipcRenderer.invoke('get-connected-midi-devices');
      // Rebuild options, keep "Any" as first
      select.innerHTML = '<option value="">Any connected device</option>';
      for (const dev of devices) {
        const opt = document.createElement('option');
        opt.value = dev;
        const color = midiDeviceColors[dev];
        opt.textContent = dev;
        if (color) {
          opt.style.backgroundColor = color;
          opt.style.color = getTextColorForBackground(color);
        }
        if (dev === selectedDevice) opt.selected = true;
        select.appendChild(opt);
      }
      // Apply selected device color to the select element itself
      updateDeviceFilterSelectColor(select);
    }

    function updateDeviceFilterSelectColor(select) {
      if (!select) select = document.getElementById('midi-device-filter');
      const val = select.value;
      const color = val ? midiDeviceColors[val] : null;
      if (color) {
        select.style.backgroundColor = color;
        select.style.color = getTextColorForBackground(color);
      } else {
        select.style.backgroundColor = '';
        select.style.color = '';
      }
    }

    function hideAddMapping() {
      const modal = document.getElementById('add-mapping-modal');
      modal.classList.remove('show');

      // Cancel MIDI learn if active
      if (midiLearnActive) {
        midiLearnActive = false;
        ipcRenderer.invoke('stop-midi-scan');
        const btn = document.getElementById('midi-listen-btn');
        const status = document.getElementById('midi-listen-status');
        if (btn) { btn.textContent = 'Learn'; btn.classList.remove('listening'); }
        if (status) { status.textContent = ''; }
      }

      // Reset modal title, editing flag, and button labels
      const modalTitle = modal.querySelector('h2');
      modalTitle.textContent = '‚ûï Create Mapping';
      delete modal.dataset.editingIndex;
      document.getElementById('mapping-submit-btn').textContent = 'Add Mapping';
      document.getElementById('mapping-clear-btn').style.display = 'none';

      // If we came from the mappings list and user cancelled, return to it
      if (returnToMappingsList) {
        returnToMappingsList = false;
        setTimeout(() => showMappingsList(), 100);
      }
    }

    function toggleMidiListen() {
      const btn = document.getElementById('midi-listen-btn');
      const status = document.getElementById('midi-listen-status');
      if (midiLearnActive) {
        midiLearnActive = false;
        btn.textContent = 'Learn';
        btn.classList.remove('listening');
        status.textContent = '';
        ipcRenderer.invoke('stop-midi-scan');
      } else {
        midiLearnActive = true;
        btn.textContent = 'Cancel';
        btn.classList.add('listening');
        status.textContent = 'Listening on all MIDI ports... move a fader or press a pad';
        status.style.color = '#ff9800';
        ipcRenderer.invoke('start-midi-scan');
      }
    }

    // Handle MIDI scan result (fires from any port, not just the connected one)
    ipcRenderer.on('midi-scan-captured', ({ deviceName, message }) => {
      if (!midiLearnActive) return;
      applyMidiLearnResult(message, deviceName);
    });

    async function applyMidiLearnResult(msg, deviceName) {
      const btn = document.getElementById('midi-listen-btn');
      const status = document.getElementById('midi-listen-status');

      midiLearnActive = false;
      btn.textContent = 'Learn';
      btn.classList.remove('listening');
      ipcRenderer.invoke('stop-midi-scan');

      // Auto-connect to the detected device if it isn't already connected
      if (deviceName) {
        const connectedDevices = await ipcRenderer.invoke('get-connected-midi-devices');
        if (!connectedDevices.includes(deviceName)) {
          await ipcRenderer.invoke('connect-midi-device', deviceName);
          updateStatus();
        }
      }

      const devLabel = deviceName ? ` [${deviceName}]` : '';

      if (msg.type === 'cc') {
        document.getElementById('midi-type').value = 'cc';
        document.getElementById('midi-channel').value = msg.channel;
        document.getElementById('midi-cc').value = msg.controller;
        updateMidiTypeFields();
        status.textContent = `Detected: CC${msg.controller} Ch${msg.channel}${devLabel}`;
        status.style.color = '#4a9b7f';
        if (deviceName) populateMidiDeviceFilter(deviceName);
      } else if (msg.type === 'note_on') {
        document.getElementById('midi-type').value = 'note';
        document.getElementById('midi-channel').value = msg.channel;
        document.getElementById('midi-note').value = msg.note;
        updateMidiTypeFields();
        updateNoteDisplay();
        status.textContent = `Detected: Note ${msg.note} (${getNoteNameFromNumber(msg.note)}) Ch${msg.channel}${devLabel}`;
        status.style.color = '#4a9b7f';
        if (deviceName) populateMidiDeviceFilter(deviceName);
      } else if (msg.type === 'pitch_bend') {
        // Pitch bend not mappable ‚Äî re-enable learn so user can try a CC control
        status.textContent = `Detected: Pitch Bend Ch${msg.channel}${devLabel} ‚Äî use a CC fader instead`;
        status.style.color = '#ff9800';
        midiLearnActive = true;
        btn.textContent = 'Cancel';
        btn.classList.add('listening');
        ipcRenderer.invoke('start-midi-scan');
      }
    }

    // Update channel number dropdown based on selected channel type
    // Helper function to get default CC based on channel number
    function getDefaultCC(channelNum) {
      // Channels 1-16: CC7 (Volume)
      // Channels 17-32: CC102 (Volume Alt)
      // Channels 33-48: CC103 (Pan Alt)
      // Channels 49+: CC104 (Expression Alt)
      if (channelNum <= 16) return 7;
      if (channelNum <= 32) return 102;
      if (channelNum <= 48) return 103;
      return 104;
    }

    async function updateChannelNumberOptions() {
      const channelType = document.getElementById('mixer-channel-type').value;
      const channelNumSelect = document.getElementById('mixer-channel-num');

      // Define max channels for each type (these are typical values)
      const maxChannels = {
        'LINE': 32, // Support up to 32 channels
        'RETURN': 4,
        'FXRETURN': 4,
        'TALKBACK': 1,
        'AUX': 16,
        'FX': 4,
        'SUB': 8,
        'MAIN': 1,
        'DCA': 8
      };

      const max = maxChannels[channelType] || 16;

      // Get channel names from mixer if connected
      try {
        const channelNames = await ipcRenderer.invoke('get-channel-names', channelType.toLowerCase(), max);

        channelNumSelect.innerHTML = '';
        for (let i = 1; i <= max; i++) {
          const option = document.createElement('option');
          option.value = i;
          const channelInfo = channelNames.find(c => c.channel === i);
          const channelName = channelInfo ? channelInfo.name : `Ch ${i}`;
          option.textContent = `${i}: ${channelName}`;
          channelNumSelect.appendChild(option);
        }

        // Auto-update MIDI settings when channel is selected
        updateMidiSettingsForChannel();
      } catch (error) {
        // Fallback if mixer not connected
        channelNumSelect.innerHTML = '';
        for (let i = 1; i <= max; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = `Channel ${i}`;
          channelNumSelect.appendChild(option);
        }

        // Auto-update MIDI settings when channel is selected
        updateMidiSettingsForChannel();
      }
    }

    // Update MIDI settings based on selected mixer channel
    function updateMidiSettingsForChannel() {
      // Don't auto-update when editing an existing mapping
      if (isEditingMapping) return;

      const channelNum = parseInt(document.getElementById('mixer-channel-num').value);
      const midiChannelInput = document.getElementById('midi-channel');
      const midiCCSelect = document.getElementById('midi-cc');

      // Set MIDI channel to match mixer channel (wrapping at 16)
      const midiChannel = ((channelNum - 1) % 16) + 1;
      midiChannelInput.value = midiChannel;

      // Set default CC based on channel number
      const defaultCC = getDefaultCC(channelNum);
      midiCCSelect.value = defaultCC;
    }

    async function showSavePreset() {
      try {
        // Get current preset path if any
        const currentPath = await ipcRenderer.invoke('get-current-preset-path');

        const result = await ipcRenderer.invoke('save-preset-dialog', currentPath);
        if (result.success) {
          // Update status bar
          const statusProfile = document.getElementById('status-profile');
          const statusLastSaved = document.getElementById('status-last-saved');
          if (statusProfile) statusProfile.textContent = result.name || 'Saved';
          if (statusLastSaved) statusLastSaved.textContent = new Date().toLocaleTimeString();

          markConfigSaved();
        }
      } catch (error) {
        alert(`‚úó Error saving preset: ${error.message}`);
      }
    }

    function hideSavePreset() {
      document.getElementById('save-preset-modal').classList.remove('show');
    }

    async function showLoadPreset() {
      try {
        const result = await ipcRenderer.invoke('load-preset-dialog');
        if (result.success) {
          // Load fader filter state from preset
          const filter = await ipcRenderer.invoke('get-fader-filter');
          if (filter) {
            faderFilter = filter;
            const filterSelect = document.getElementById('filter-select');
            if (filterSelect) {
              filterSelect.value = faderFilter;
            }
          }

          // Reload mappings and faders
          await loadMappings();
          await loadFaders();

          // Update status bar
          const statusProfile = document.getElementById('status-profile');
          const statusLastSaved = document.getElementById('status-last-saved');
          if (statusProfile) statusProfile.textContent = result.name || 'Loaded';
          if (statusLastSaved) statusLastSaved.textContent = result.mtime
            ? new Date(result.mtime).toLocaleString([], { dateStyle: 'short', timeStyle: 'short' })
            : new Date().toLocaleTimeString();

          markConfigSaved();
        }
      } catch (error) {
        alert(`‚úó Error loading preset: ${error.message}`);
      }
    }

    function showMidiSelect() {
      document.getElementById('midi-select-modal').classList.add('show');
      loadMidiDevices();
    }

    function hideMidiSelect() {
      document.getElementById('midi-select-modal').classList.remove('show');
    }

    // Preferences functions
    let faderSmoothingSpeed = 300; // Default smoothing speed in ms
    let midiFeedbackEnabled = true; // Default: enabled

    function showPreferences() {
      const modal = document.getElementById('preferences-modal');
      const smoothingInput = document.getElementById('fader-smoothing');
      const midiFeedbackCheckbox = document.getElementById('midi-feedback-enabled');

      // Load current preferences
      const savedSmoothing = localStorage.getItem('faderSmoothingSpeed');
      if (savedSmoothing) {
        faderSmoothingSpeed = parseInt(savedSmoothing);
        smoothingInput.value = faderSmoothingSpeed;
        updateSmoothingDisplay();
      }

      const savedMidiFeedback = localStorage.getItem('midiFeedbackEnabled');
      if (savedMidiFeedback !== null) {
        midiFeedbackEnabled = savedMidiFeedback === 'true';
      }
      midiFeedbackCheckbox.checked = midiFeedbackEnabled;

      modal.classList.add('show');
    }

    function hidePreferences() {
      document.getElementById('preferences-modal').classList.remove('show');
    }

    async function showMappingsList() {
      const modal = document.getElementById('mappings-list-modal');
      const listView = document.getElementById('mappings-list-view');

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        if (mappings.length === 0) {
          listView.innerHTML = '<div class="empty-state">No mappings configured yet.</div>';
          currentMappingsList = [];
        } else {
          // Group mappings by trigger type first, then MIDI channel
          const sortedMappings = [...mappings].sort((a, b) => {
            // Sort by type first (cc before note types)
            const aIsCC = a.midi.type === 'cc';
            const bIsCC = b.midi.type === 'cc';
            if (aIsCC !== bIsCC) {
              return aIsCC ? -1 : 1;
            }
            // Then by MIDI channel
            if (a.midi.channel !== b.midi.channel) {
              return a.midi.channel - b.midi.channel;
            }
            // Then by controller/note number
            const aNum = a.midi.controller || a.midi.note || a.midi.noteMin || 0;
            const bNum = b.midi.controller || b.midi.note || b.midi.noteMin || 0;
            return aNum - bNum;
          });

          listView.innerHTML = `
            <table style="width: 100%; border-collapse: collapse;">
              <thead>
                <tr style="border-bottom: 2px solid rgba(255,255,255,0.2); text-align: left;">
                  <th style="padding: 8px;">MIDI Input</th>
                  <th style="padding: 8px;">MIDI Trigger</th>
                  <th style="padding: 8px;">Mixer Function</th>
                  <th style="padding: 8px;">Mixer Channel</th>
                  <th style="padding: 8px; text-align: center;">Actions</th>
                </tr>
              </thead>
              <tbody>
                ${sortedMappings.map((m, index) => {
                  // MIDI Input - Channel and device (show device when mapping has a filter)
                  const midiInput = m.midi.device
                    ? `Ch ${m.midi.channel} [${shortenMidiDeviceName(m.midi.device)}]`
                    : `Ch ${m.midi.channel}`;

                  // MIDI Trigger - What triggers it and value ranges
                  let midiTrigger = '';
                  const isBooleanControl = m.mixer.action === 'mute' || m.mixer.action === 'solo' || m.mixer.action === 'mutegroup';

                  if (m.midi.type === 'cc') {
                    if (isBooleanControl && m.midi.threshold !== undefined) {
                      midiTrigger = `CC${m.midi.controller} (‚â•${m.midi.threshold} = ON)`;
                    } else {
                      midiTrigger = `CC${m.midi.controller} (0-127)`;
                    }
                  } else if (m.midi.type === 'note-value') {
                    midiTrigger = `Note ${m.midi.noteMin}-${m.midi.noteMax}`;
                  } else if (m.midi.type === 'note-on') {
                    const invertText = m.midi.invert ? ' (inverted)' : '';
                    midiTrigger = `Note ${m.midi.note} ON ‚Üí Activate${invertText}`;
                  } else if (m.midi.type === 'note-off') {
                    const invertText = m.midi.invert ? ' (inverted)' : '';
                    midiTrigger = `Note ${m.midi.note} OFF ‚Üí Deactivate${invertText}`;
                  } else if (m.midi.type === 'note-toggle') {
                    const invertText = m.midi.invert ? ' (inverted)' : '';
                    midiTrigger = `Note ${m.midi.note} ‚Üí Toggle${invertText}`;
                  } else if (m.midi.type === 'note') {
                    const invertText = m.midi.invert ? ' (inverted)' : '';
                    midiTrigger = `Note ${m.midi.note}${invertText}`;
                  }

                  // Mixer Function - More descriptive
                  let mixerFunction = '';
                  if (m.mixer.action === 'volume') {
                    mixerFunction = 'üéöÔ∏è Volume Control';
                  } else if (m.mixer.action === 'mute') {
                    mixerFunction = 'üîá Mute Control';
                  } else if (m.mixer.action === 'solo') {
                    mixerFunction = 'üîä Solo Control';
                  } else if (m.mixer.action === 'pan') {
                    mixerFunction = '‚ÜîÔ∏è Pan Control';
                  } else if (m.mixer.action === 'mutegroup') {
                    mixerFunction = 'üéöÔ∏è Mute Group';
                  } else {
                    mixerFunction = m.mixer.action.charAt(0).toUpperCase() + m.mixer.action.slice(1);
                  }

                  // Mixer Channel - More descriptive
                  let mixerChannel = '';
                  if (m.mixer.action === 'mutegroup') {
                    mixerChannel = `Mute Group ${m.mixer.channel.channel}`;
                  } else {
                    const channelType = m.mixer.channel.type || 'LINE';
                    const channelNum = m.mixer.channel.channel || m.mixer.channel;
                    const typeLabel = {
                      'LINE': 'Input',
                      'AUX': 'Aux',
                      'FX': 'FX',
                      'FXRETURN': 'FX Return',
                      'SUB': 'Sub',
                      'MAIN': 'Main',
                      'DCA': 'DCA'
                    }[channelType] || channelType;
                    mixerChannel = `${typeLabel} ${channelNum}`;
                  }

                  return `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                      <td style="padding: 8px; font-family: monospace;">${midiInput}</td>
                      <td style="padding: 8px; font-family: monospace;">${midiTrigger}</td>
                      <td style="padding: 8px;">${mixerFunction}</td>
                      <td style="padding: 8px;">${mixerChannel}</td>
                      <td style="padding: 8px; text-align: center;">
                        <button class="icon-btn" onclick="editMappingFromList(${index})" title="Edit Mapping" style="margin-right: 4px;">‚úèÔ∏è</button>
                        <button class="icon-btn" onclick="deleteMappingFromList(${index})" title="Delete Mapping">üóëÔ∏è</button>
                      </td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          `;

          // Store the sorted mappings for edit/delete operations
          currentMappingsList = sortedMappings;
        }

        modal.classList.add('show');
      } catch (error) {
        const errEl = document.createElement('div');
        errEl.className = 'empty-state';
        errEl.textContent = 'Error loading mappings: ' + (error.message || String(error));
        listView.innerHTML = '';
        listView.appendChild(errEl);
        modal.classList.add('show');
      }
    }

    function hideMappingsList() {
      document.getElementById('mappings-list-modal').classList.remove('show');
    }

    async function editMappingFromList(index) {
      const mapping = currentMappingsList[index];
      if (!mapping) return;

      // Set flag to return to mappings list after saving
      returnToMappingsList = true;

      // Close the mappings list modal
      hideMappingsList();

      // Set flag to prevent auto-updating MIDI settings
      isEditingMapping = true;

      // Get all mappings to find the actual index
      const allMappings = await ipcRenderer.invoke('get-mappings');
      const actualIndex = allMappings.findIndex(m => {
        if (m.mixer.action === 'mutegroup' && mapping.mixer.action === 'mutegroup') {
          return m.mixer.channel.channel === mapping.mixer.channel.channel;
        } else if (m.mixer.action !== 'mutegroup' && mapping.mixer.action !== 'mutegroup') {
          return m.mixer.action === mapping.mixer.action &&
                 (m.mixer.channel.type || 'LINE') === (mapping.mixer.channel.type || 'LINE') &&
                 (m.mixer.channel.channel || m.mixer.channel) == (mapping.mixer.channel.channel || mapping.mixer.channel);
        }
        return false;
      });

      if (actualIndex === -1) {
        alert('Mapping not found');
        return;
      }

      // Populate the add-mapping modal with existing data
      const modal = document.getElementById('add-mapping-modal');

      // Set MIDI type (preserve exact type: none, cc, note, note-value)
      document.getElementById('midi-type').value = mapping.midi.type || 'none';
      updateMidiTypeFields();

      // Set MIDI channel
      document.getElementById('midi-channel').value = mapping.midi.channel;

      // Set MIDI controller/note values
      if (mapping.midi.type === 'cc') {
        document.getElementById('midi-cc').value = mapping.midi.controller;
        // Set threshold for boolean controls
        if (mapping.midi.threshold !== undefined) {
          document.getElementById('midi-cc-threshold').value = mapping.midi.threshold;
        } else {
          document.getElementById('midi-cc-threshold').value = 64; // Default
        }
      } else if (mapping.midi.type === 'note-value') {
        const noteTypeSelect = document.getElementById('note-type');
        if (noteTypeSelect) {
          noteTypeSelect.value = 'note-value';
          // Trigger change event to update fields
          noteTypeSelect.dispatchEvent(new Event('change'));
        }
        setTimeout(() => {
          document.getElementById('midi-note-min').value = mapping.midi.noteMin || 24;
          document.getElementById('midi-note-max').value = mapping.midi.noteMax || 60;
        }, 50);
      } else {
        // note, note-on, note-off, note-toggle
        const noteTypeSelect = document.getElementById('note-type');
        if (noteTypeSelect) {
          noteTypeSelect.value = mapping.midi.type;
          // Trigger change event to update fields
          noteTypeSelect.dispatchEvent(new Event('change'));
        }
        setTimeout(() => {
          const noteInput = document.getElementById('midi-note');
          if (noteInput) {
            noteInput.value = mapping.midi.note;
          }
          // Set invert for boolean controls
          const noteInvertCheckbox = document.getElementById('midi-note-invert');
          if (noteInvertCheckbox) {
            noteInvertCheckbox.checked = mapping.midi.invert || false;
          }
        }, 50);
      }

      // Set mixer action and channel
      document.getElementById('mixer-action').value = mapping.mixer.action;
      document.getElementById('mixer-channel-type').value = mapping.mixer.channel.type || 'LINE';

      // Update channel number options and then set the value
      await updateChannelNumberOptions();
      document.getElementById('mixer-channel-num').value = mapping.mixer.channel.channel || mapping.mixer.channel;

      // Clear the flag
      isEditingMapping = false;

      // Change modal title and button labels to indicate editing
      const modalTitle = modal.querySelector('h2');
      modalTitle.textContent = '‚úèÔ∏è Edit Mapping';
      document.getElementById('mapping-submit-btn').textContent = 'Save';
      document.getElementById('mapping-clear-btn').style.display = '';

      // Store the editing index
      modal.dataset.editingIndex = actualIndex;

      // Show the modal
      modal.classList.add('show');
    }

    async function deleteMappingFromList(index) {
      const mapping = currentMappingsList[index];
      if (!mapping) return;

      // Determine the description for confirmation
      let desc = '';
      if (mapping.mixer.action === 'mutegroup') {
        desc = `Mute Group ${mapping.mixer.channel.channel}`;
      } else {
        const channelType = mapping.mixer.channel.type || 'LINE';
        const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
        const actionName = {
          'volume': 'Volume',
          'mute': 'Mute',
          'solo': 'Solo',
          'pan': 'Pan'
        }[mapping.mixer.action] || mapping.mixer.action;
        desc = `${channelType} ${channelNum} - ${actionName}`;
      }

      if (!confirm(`Delete mapping for ${desc}?`)) {
        return;
      }

      try {
        // Get all mappings to find the actual index
        const allMappings = await ipcRenderer.invoke('get-mappings');
        const actualIndex = allMappings.findIndex(m => {
          if (m.mixer.action === 'mutegroup' && mapping.mixer.action === 'mutegroup') {
            return m.mixer.channel.channel === mapping.mixer.channel.channel;
          } else if (m.mixer.action !== 'mutegroup' && mapping.mixer.action !== 'mutegroup') {
            return m.mixer.action === mapping.mixer.action &&
                   (m.mixer.channel.type || 'LINE') === (mapping.mixer.channel.type || 'LINE') &&
                   (m.mixer.channel.channel || m.mixer.channel) == (mapping.mixer.channel.channel || mapping.mixer.channel);
          }
          return false;
        });

        if (actualIndex === -1) {
          alert('Mapping not found');
          return;
        }

        // Actually remove the mapping entry
        await ipcRenderer.invoke('remove-mapping', actualIndex);

        // Reload the mappings list
        await showMappingsList();

        // Reload the UI to update visual indicators
        await loadFaders();
        await loadMappings();
        markConfigChanged();
      } catch (error) {
        alert(`Error deleting mapping: ${error.message}`);
      }
    }

    async function clearAllMappingsFromList() {
      // Get all mappings
      const allMappings = await ipcRenderer.invoke('get-mappings');
      const mappingCount = allMappings.filter(m => m.midi.type !== 'none').length;

      if (mappingCount === 0) {
        alert('No mappings to clear.');
        return;
      }

      // Double confirmation
      if (!confirm(`‚ö†Ô∏è Clear ALL ${mappingCount} MIDI mappings?\n\nThis will remove all MIDI mappings from all channels and mute groups.\n\nThis action cannot be undone!`)) {
        return;
      }

      // Second confirmation
      if (!confirm(`Are you absolutely sure?\n\nThis will clear ${mappingCount} mappings.`)) {
        return;
      }

      try {
        // Clear all mappings by setting them to 'none'
        for (let i = 0; i < allMappings.length; i++) {
          const clearedMapping = { ...allMappings[i] };
          clearedMapping.midi = { type: 'none', channel: 1 };
          await ipcRenderer.invoke('update-mapping', i, clearedMapping);
        }

        // Close the mappings list
        hideMappingsList();

        // Reload the UI to update visual indicators
        await loadFaders();
        await loadMappings();
        markConfigChanged();

        alert(`‚úì Successfully cleared all ${mappingCount} mappings.`);
      } catch (error) {
        alert(`Error clearing mappings: ${error.message}`);
      }
    }

    function updateSmoothingDisplay() {
      const smoothingInput = document.getElementById('fader-smoothing');
      const display = document.getElementById('smoothing-display');
      display.textContent = smoothingInput.value;
    }

    function savePreferences() {
      const smoothingInput = document.getElementById('fader-smoothing');
      const midiFeedbackCheckbox = document.getElementById('midi-feedback-enabled');

      faderSmoothingSpeed = parseInt(smoothingInput.value);
      midiFeedbackEnabled = midiFeedbackCheckbox.checked;

      localStorage.setItem('faderSmoothingSpeed', faderSmoothingSpeed);
      localStorage.setItem('midiFeedbackEnabled', midiFeedbackEnabled.toString());

      // Send preference to main process
      ipcRenderer.invoke('set-midi-feedback-enabled', midiFeedbackEnabled);

      hidePreferences();
    }

    document.getElementById('level-visibility-select').addEventListener('change', async (e) => {
      currentLevelVisibility = e.target.value;
      await ipcRenderer.invoke('set-level-visibility', currentLevelVisibility);
      applyLevelVisibilitySettings();
    });

    document.getElementById('peak-hold-check').addEventListener('change', async (e) => {
      currentPeakHold = e.target.checked;
      await ipcRenderer.invoke('set-peak-hold', currentPeakHold);
    });

    // Helper function to shorten MIDI device names
    function shortenMidiDeviceName(deviceName) {
      if (!deviceName) return deviceName;
      // Shorten "Logic Pro Virtual Out" to "Logic Pro"
      return deviceName.replace(/Logic Pro Virtual Out/gi, 'Logic Pro');
    }

    // Load preferences on startup
    document.addEventListener('DOMContentLoaded', () => {
      const savedSmoothing = localStorage.getItem('faderSmoothingSpeed');
      if (savedSmoothing) {
        faderSmoothingSpeed = parseInt(savedSmoothing);
      }

      const savedMidiFeedback = localStorage.getItem('midiFeedbackEnabled');
      if (savedMidiFeedback !== null) {
        midiFeedbackEnabled = savedMidiFeedback === 'true';
      }

      // Send preference to main process
      ipcRenderer.invoke('set-midi-feedback-enabled', midiFeedbackEnabled);
    });

    // MIDI type change handler
    document.addEventListener('DOMContentLoaded', () => {
      const midiTypeSelect = document.getElementById('midi-type');
      if (midiTypeSelect) {
        midiTypeSelect.addEventListener('change', (e) => {
          const ccGroup = document.getElementById('cc-group');
          const noteGroup = document.getElementById('note-group');
          if (e.target.value === 'cc') {
            ccGroup.style.display = 'block';
            noteGroup.style.display = 'none';
          } else {
            ccGroup.style.display = 'none';
            noteGroup.style.display = 'block';
          }
        });
      }
    });

    // Track whether a scan is currently in progress (for progressive result handler)
    let discoveryInProgress = false;

    // Helper: append a single mixer entry to the list
    function appendMixerToList(mixer) {
      const listEl = document.getElementById('mixer-list');
      if (!listEl) return;
      // Remove the "Scanning..." placeholder on first result
      const placeholder = listEl.querySelector('.scan-status-placeholder');
      if (placeholder) placeholder.remove();

      const ip = mixer.ip || '';
      const modelName = mixer.model || mixer.name || '';
      const deviceName = mixer.deviceName || '';
      const serial = mixer.serial || '';

      const div = document.createElement('div');
      div.className = 'mixer-item';
      div.setAttribute('data-ip', ip);
      div.title = `IP: ${ip}\nModel: ${modelName}${deviceName ? '\nDevice Name: ' + deviceName : ''}\nSerial: ${serial}`;

      const infoDiv = document.createElement('div');
      infoDiv.className = 'mixer-info';

      const nameDiv = document.createElement('div');
      nameDiv.className = 'mixer-name';
      nameDiv.textContent = ip + ' ' + modelName + (deviceName ? ' ' + deviceName : '');

      const detailDiv = document.createElement('div');
      detailDiv.className = 'mixer-details';
      detailDiv.textContent = 'Serial: ' + serial;

      const connectBtn = document.createElement('button');
      connectBtn.className = 'btn';
      connectBtn.textContent = 'Connect';
      connectBtn.addEventListener('click', () => connectToMixer(ip, modelName, deviceName, serial));

      infoDiv.appendChild(nameDiv);
      infoDiv.appendChild(detailDiv);
      div.appendChild(infoDiv);
      div.appendChild(connectBtn);
      listEl.appendChild(div);
    }

    // Progressive discovery: append each device as it's found during an active scan
    ipcRenderer.on('discovery-result', (device) => {
      if (!discoveryInProgress) return;
      appendMixerToList(device);
    });

    // Scan for mixers
    async function scanForMixers() {
      const btn = document.getElementById('scan-btn');
      const listEl = document.getElementById('mixer-list');

      btn.disabled = true;
      btn.textContent = 'Scanning...';
      listEl.innerHTML = '<div class="empty-state scan-status-placeholder">Scanning network...</div>';

      discoveryInProgress = true;
      try {
        await ipcRenderer.invoke('discover-mixers');
        // Results were shown progressively via discovery-result events
        const items = listEl.querySelectorAll('.mixer-item');
        if (items.length === 0) {
          listEl.innerHTML = '<div class="empty-state">No mixers found. Try manual connection below.</div>';
        }
      } catch (error) {
        const errDiv = document.createElement('div');
        errDiv.className = 'empty-state';
        errDiv.textContent = 'Error: ' + (error.message || String(error));
        listEl.innerHTML = '';
        listEl.appendChild(errDiv);
      } finally {
        discoveryInProgress = false;
        btn.disabled = false;
        btn.textContent = 'Scan Network';
        // Clean up placeholder if no results came in
        const placeholder = listEl.querySelector('.scan-status-placeholder');
        if (placeholder) placeholder.remove();
      }
    }

    // Connect to mixer
    async function connectToMixer(ip, model, deviceName, serial) {
      try {
        await updateStatusInitWithDelay(`Connecting to ${model || 'mixer'} at ${ip}...`);
        const result = await ipcRenderer.invoke('connect-mixer', ip, model, deviceName, serial);
        if (result.success) {
          await updateStatusInitWithDelay('Connected - waiting for mixer state...');
          hideDiscovery();
          updateStatus();
        } else {
          const errorMsg = `Connection failed: ${result.error}`;
          updateStatusInit(errorMsg);
          addStatusLog(errorMsg, 'error');
          alert(`‚úó Failed to connect: ${result.error}`);
        }
      } catch (error) {
        const errorMsg = `Error: ${error.message}`;
        updateStatusInit(errorMsg);
        addStatusLog(errorMsg, 'error');
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Connect manually
    async function connectManual() {
      const ip = document.getElementById('manual-ip').value.trim();
      if (!ip) {
        alert('Please enter an IP address');
        return;
      }
      await connectToMixer(ip);
    }

    // Load MIDI devices
    async function loadMidiDevices() {
      try {
        const { inputs, connected } = await ipcRenderer.invoke('get-midi-devices');
        // connected is now an array of device names
        const connectedSet = new Set(Array.isArray(connected) ? connected : (connected ? [connected] : []));
        const listEl = document.getElementById('midi-devices-list');

        if (inputs.length === 0) {
          listEl.innerHTML = '<div class="empty-state">No MIDI input devices found. Make sure Logic Pro is running or your MIDI controller is connected.</div>';
        } else {
          let html = `<div class="midi-section-header">MIDI Inputs (${inputs.length})</div>`;
          html += inputs.map(device => {
            const isConnected = connectedSet.has(device);
            const escapedDevice = device.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            const colorValue = midiDeviceColors[device] || '#888888';
            return `
              <div class="mixer-item${isConnected ? ' connected-device' : ''}">
                <div class="mixer-info">
                  <div class="mixer-name">üéπ ${device}</div>
                  ${isConnected ? '<div class="mixer-details" style="color: #4a9b7f; font-size: 0.8rem;">‚óè Connected</div>' : ''}
                </div>
                <div style="display:flex;align-items:center;gap:3px">
                  <input type="color" class="device-color-picker" value="${colorValue}" data-device="${device}" title="Set device color" style="width:28px;height:20px;padding:1px 2px;border:1px solid rgba(255,255,255,0.2);background:rgba(40,40,40,0.8);border-radius:3px;cursor:pointer">
                  <button class="device-color-reset" data-device="${device}" title="Remove device color" style="width:18px;height:20px;padding:0;font-size:0.7rem;line-height:1;background:rgba(80,80,80,0.5);border:1px solid rgba(255,255,255,0.15);border-radius:3px;cursor:pointer;color:#aaa;${midiDeviceColors[device] ? '' : 'visibility:hidden'}">‚úï</button>
                </div>
                ${isConnected
                  ? `<button class="btn" style="background:rgba(200,50,50,0.3); border-color:#c74a3a;" onclick="disconnectMidiDevice('${escapedDevice}')">Disconnect</button>`
                  : `<button class="btn" onclick="connectToMidiDevice('${escapedDevice}')">Connect</button>`
                }
              </div>
            `;
          }).join('');
          listEl.innerHTML = html;

          // Color picker ‚Äî update badges immediately without full loadFaders()
          listEl.querySelectorAll('.device-color-picker').forEach(picker => {
            picker.addEventListener('change', async (e) => {
              const deviceName = e.target.dataset.device;
              const color = e.target.value;
              midiDeviceColors[deviceName] = color;
              await ipcRenderer.invoke('set-midi-device-color', deviceName, color);
              applyDeviceColorToLabels(deviceName, color);
              // Show the reset button now that a color is set
              const resetBtn = e.target.closest('div').querySelector('.device-color-reset');
              if (resetBtn) resetBtn.style.visibility = '';
              updateDeviceFilterSelectColor();
            });
          });

          // Reset button ‚Äî clears the device color
          listEl.querySelectorAll('.device-color-reset').forEach(btn => {
            btn.addEventListener('click', async (e) => {
              const deviceName = e.target.dataset.device;
              delete midiDeviceColors[deviceName];
              await ipcRenderer.invoke('set-midi-device-color', deviceName, '');
              applyDeviceColorToLabels(deviceName, '');
              // Reset picker to default gray and hide the reset button
              const picker = e.target.closest('div').querySelector('.device-color-picker');
              if (picker) picker.value = '#888888';
              e.target.style.visibility = 'hidden';
              updateDeviceFilterSelectColor();
            });
          });
        }
      } catch (error) {
        const listEl = document.getElementById('midi-devices-list');
        listEl.innerHTML = `<div class="empty-state">Error: ${error.message}</div>`;
      }
    }

    // Disconnect a MIDI device
    async function disconnectMidiDevice(deviceName) {
      try {
        // Check for mappings that use this device
        const deviceMappings = currentMappings.filter(m => m.midi && m.midi.device === deviceName);
        if (deviceMappings.length > 0) {
          const clearThem = confirm(
            `"${deviceName}" has ${deviceMappings.length} mapping${deviceMappings.length !== 1 ? 's' : ''}.\n\nClear those mappings now?`
          );
          if (clearThem) {
            const allMappings = await ipcRenderer.invoke('get-mappings');
            // Remove in reverse order so indices stay valid
            const indices = allMappings
              .map((m, i) => (m.midi && m.midi.device === deviceName ? i : -1))
              .filter(i => i >= 0)
              .reverse();
            for (const idx of indices) {
              await ipcRenderer.invoke('remove-mapping', idx);
            }
            markConfigChanged();
          }
        }

        await ipcRenderer.invoke('disconnect-midi-device', deviceName);
        addStatusLog(`MIDI disconnected: ${deviceName}`, 'info');
        await loadMidiDevices();
        await loadMappings();
        await loadFaders();
        updateStatus();
      } catch (error) {
        alert(`‚úó Error disconnecting: ${error.message}`);
      }
    }

    // Refresh MIDI devices
    async function refreshMidiDevices() {
      await loadMidiDevices();
    }

    // Channel management functions
    async function removeSelectedChannels() {
      const selectedFaders = document.querySelectorAll('.fader-channel.selected');
      if (selectedFaders.length === 0) {
        alert('No channels selected. Click on a fader to select it, then try again.');
        return;
      }

      if (!confirm(`Remove ${selectedFaders.length} selected channel(s)?`)) {
        return;
      }

      try {
        for (const fader of selectedFaders) {
          const faderId = fader.getAttribute('data-fader-id');
          const [channelType, channelNum] = faderId.split('-');

          // Find and remove the mapping
          const mappings = await ipcRenderer.invoke('get-mappings');
          const mappingIndex = mappings.findIndex(m =>
            m.mixer.action === 'volume' &&
            (m.mixer.channel.type || 'LINE') === channelType &&
            (m.mixer.channel.channel || m.mixer.channel) == channelNum
          );

          if (mappingIndex !== -1) {
            await ipcRenderer.invoke('remove-mapping', mappingIndex);
          }
        }

        await loadFaders();
        await loadMappings();
        markConfigChanged();
        // Removed alert - silent removal
      } catch (error) {
        alert(`‚úó Error removing channels: ${error.message}`);
      }
    }

    async function clearAllChannels() {
      if (!confirm('Clear ALL channel mappings (except MAIN)? This will only clear the MIDI mappings, not the faders.')) {
        return;
      }

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        // Remove all mappings except MAIN in reverse order to maintain indices
        let removedCount = 0;
        for (let i = mappings.length - 1; i >= 0; i--) {
          const mapping = mappings[i];
          const channelType = mapping.mixer.channel.type || 'LINE';

          // Skip MAIN channels
          if (channelType === 'MAIN') {
            continue;
          }

          await ipcRenderer.invoke('remove-mapping', i);
          removedCount++;
        }

        await loadFaders();
        await loadMappings();
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error clearing channels: ${error.message}`);
      }
    }

    // Handle filter dropdown change
    async function onFilterChange() {
      const filterSelect = document.getElementById('filter-select');
      faderFilter = filterSelect.value;

      // Save filter state to mapping engine
      await ipcRenderer.invoke('set-fader-filter', faderFilter);
      markConfigChanged();

      loadFaders();
    }

    // Update filter dropdown with DCA groups and auto-filter groups
    async function updateFilterDropdown() {
      const filterSelect = document.getElementById('filter-select');
      if (!filterSelect) {
        return;
      }

      // Save current selection
      const currentValue = filterSelect.value;

      // Remove old group options
      const options = Array.from(filterSelect.options);
      options.forEach(opt => {
        if (opt.value.startsWith('dca-') || opt.value.startsWith('auto-')) {
          filterSelect.removeChild(opt);
        }
      });

      let addedCount = 0;

      // Add DCA group options (only for named DCA groups, not default names)
      const dcaData = channelDataCache['dca'];
      if (dcaData && dcaData.names) {
        dcaData.names.forEach(dca => {
          // Skip default names like "Ch 1", "DCA 1", etc.
          const isDefaultName = !dca.name ||
                               dca.name === `Ch ${dca.channel}` ||
                               dca.name === `DCA ${dca.channel}`;

          if (!isDefaultName) {
            const option = document.createElement('option');
            option.value = `dca-${dca.channel}`;
            option.textContent = `üîç DCA: ${dca.name}`;
            filterSelect.appendChild(option);
            addedCount++;
          }
        });
      }

      // Fetch and add auto-filter group options
      try {
        const autoFilterGroups = await ipcRenderer.invoke('get-autofilter-group-names', 8);

        autoFilterGroups.forEach(group => {
          // Skip default names like "Auto 1", empty names, or names without the ~ prefix
          const isDefaultName = !group.name ||
                               group.name === `Auto ${group.channel}` ||
                               group.name === `Ch ${group.channel}`;

          if (!isDefaultName) {
            const option = document.createElement('option');
            option.value = `auto-${group.channel}`;
            option.textContent = `üîç ${group.name}`;
            filterSelect.appendChild(option);
            addedCount++;
          }
        });
      } catch (error) {
      }

      // Restore previous selection (or use faderFilter global)
      const valueToRestore = currentValue || faderFilter;
      if (valueToRestore && filterSelect.querySelector(`option[value="${valueToRestore}"]`)) {
        filterSelect.value = valueToRestore;
      }

    }

    // Mute group functions
    let muteGroupsData = [];

    async function loadMuteGroups() {
      try {
        const groups = await ipcRenderer.invoke('get-mute-group-names');
        muteGroupsData = groups;
        renderMuteGroups();
      } catch (error) {
        console.error('[loadMuteGroups] Error loading mute groups:', error);
      }
    }

    function renderMuteGroups() {
      const container = document.getElementById('mute-groups-container');
      if (!container) {
        console.error('[renderMuteGroups] Container not found!');
        return;
      }

      container.innerHTML = '';

      if (!muteGroupsData || muteGroupsData.length === 0) {
        console.warn('[renderMuteGroups] No mute groups data to render');
        return;
      }

      muteGroupsData.forEach(group => {
        const button = document.createElement('button');

        // Check if this mute group has a MIDI mapping
        const isMapped = currentMappings.some(m =>
          m.mixer.action === 'mutegroup' && m.mixer.channel.channel === group.group
        );

        button.className = `btn mute-group-btn${group.active ? ' active' : ''}${isMapped ? ' mapped' : ''}`;
        button.id = `mute-group-${group.group}`;
        button.setAttribute('data-group-num', group.group);
        button.textContent = group.name;

        // Update tooltip to show MIDI mapping info if mapped
        if (isMapped) {
          const mapping = currentMappings.find(m =>
            m.mixer.action === 'mutegroup' && m.mixer.channel.channel === group.group
          );
          const midiInfo = mapping.midi.type === 'cc'
            ? `CC${mapping.midi.controller} Ch${mapping.midi.channel}`
            : `Note ${mapping.midi.note} Ch${mapping.midi.channel}`;
          button.title = `Mute Group ${group.group}: ${group.name}\n${midiInfo}`;
          const mgDevColor = mapping.midi?.device ? (midiDeviceColors[mapping.midi.device] || '') : '';
          if (mgDevColor) {
            button.style.borderColor = mgDevColor;
            button.style.boxShadow = `0 0 4px ${mgDevColor}66`;
          }
        } else {
          button.title = `Mute Group ${group.group}: ${group.name}`;
        }

        button.onclick = () => toggleMuteGroup(group.group);

        // Add right-click context menu for editing
        button.oncontextmenu = (e) => {
          e.preventDefault();
          showMuteGroupContextMenu(group.group, e.clientX, e.clientY);
        };

        // Add MIDI indicator dot if mapped
        if (isMapped) {
          const indicator = document.createElement('div');
          indicator.className = 'midi-indicator';
          button.appendChild(indicator);
        }

        container.appendChild(button);
      });
    }

    // Helper function to position context menu within viewport bounds
    function positionContextMenu(contextMenu, x, y) {
      // First, show the menu to get its dimensions
      contextMenu.classList.add('show');

      const menuRect = contextMenu.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Adjust x position if menu would overflow right edge
      if (x + menuRect.width > viewportWidth) {
        x = viewportWidth - menuRect.width - 10; // 10px padding from edge
      }

      // Adjust y position if menu would overflow bottom edge
      if (y + menuRect.height > viewportHeight) {
        y = viewportHeight - menuRect.height - 10; // 10px padding from edge
      }

      // Ensure menu doesn't go off left or top edge
      x = Math.max(10, x);
      y = Math.max(10, y);

      contextMenu.style.left = `${x}px`;
      contextMenu.style.top = `${y}px`;
    }

    // Mute group context menu
    let currentContextMenuMuteGroup = null;

    function showMuteGroupContextMenu(groupNum, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('mutegroup-context-menu');
      currentContextMenuMuteGroup = groupNum;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuEditMuteGroup() {
      if (currentContextMenuMuteGroup === null) {
        hideAllContextMenus();
        return;
      }

      const groupNum = currentContextMenuMuteGroup;

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'mutegroup' &&
          m.mixer.channel.channel === groupNum
        );

        // Set flag to prevent auto-update during editing
        isEditingMapping = true;

        // Populate the modal
        const modal = document.getElementById('add-mapping-modal');

        if (mappingIndex !== -1) {
          // Editing existing mute group mapping
          const mapping = mappings[mappingIndex];

          document.getElementById('midi-type').value = mapping.midi.type;
          if (mapping.midi.type === 'cc') {
            document.getElementById('midi-cc').value = mapping.midi.controller;
          } else if (mapping.midi.type === 'note') {
            document.getElementById('midi-note').value = mapping.midi.note;
          }
          document.getElementById('midi-channel').value = mapping.midi.channel;

          modal.dataset.editingIndex = mappingIndex;
          modal.querySelector('h2').textContent = '‚úèÔ∏è Edit Mute Group Mapping';
          document.getElementById('mapping-submit-btn').textContent = 'Save';
          document.getElementById('mapping-clear-btn').style.display = '';
        } else {
          // Creating new mute group mapping
          document.getElementById('midi-type').value = 'note';
          document.getElementById('midi-note').value = String(70 + groupNum); // Default to note 71-78
          document.getElementById('midi-channel').value = '1';

          delete modal.dataset.editingIndex;
          modal.querySelector('h2').textContent = '‚ûï Create Mute Group Mapping';
          document.getElementById('mapping-submit-btn').textContent = 'Add Mapping';
          document.getElementById('mapping-clear-btn').style.display = 'none';
        }

        // Set channel info - mute groups don't have a channel type, just use the group number
        // We'll need to handle this specially in the addMapping function
        document.getElementById('mixer-channel-type').value = 'LINE'; // Placeholder
        await updateChannelNumberOptions();
        document.getElementById('mixer-channel-num').value = groupNum;

        // Set action to mutegroup (note: this may not be in the dropdown yet)
        const actionSelect = document.getElementById('mixer-action');
        // Check if mutegroup option exists, if not add it temporarily
        if (![...actionSelect.options].some(opt => opt.value === 'mutegroup')) {
          const option = document.createElement('option');
          option.value = 'mutegroup';
          option.textContent = 'Mute Group';
          actionSelect.appendChild(option);
        }
        actionSelect.value = 'mutegroup';

        // Store the group number for later use
        modal.dataset.muteGroupNum = groupNum;

        // Update MIDI type fields
        updateMidiTypeFields();

        isEditingMapping = false;

        // Populate device filter, pre-selecting existing mapping's device if any
        const existingMuteGroupMapping = mappingIndex !== -1 ? mappings[mappingIndex] : null;
        await populateMidiDeviceFilter(existingMuteGroupMapping && existingMuteGroupMapping.midi.device);

        // Show modal
        modal.classList.add('show');
      } catch (error) {
        isEditingMapping = false;
        alert(`‚úó Error: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuClearMuteGroup() {
      if (currentContextMenuMuteGroup === null) {
        hideAllContextMenus();
        return;
      }

      const groupNum = currentContextMenuMuteGroup;

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'mutegroup' &&
          m.mixer.channel.channel === groupNum
        );

        if (mappingIndex !== -1) {
          await ipcRenderer.invoke('remove-mapping', mappingIndex);
          await loadMappings();
          renderMuteGroups(); // Re-render mute groups to update mapped state
          markConfigChanged();
        }
      } catch (error) {
        alert(`‚úó Error clearing mute group mapping: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function toggleMuteGroup(groupNum) {
      try {
        const result = await ipcRenderer.invoke('toggle-mute-group', groupNum);
        if (result.success) {
          // Update the mute group button state
          const button = document.getElementById(`mute-group-${groupNum}`);
          const newState = await ipcRenderer.invoke('get-mute-group-state', groupNum);

          if (button) {
            if (newState) {
              button.classList.add('active');
            } else {
              button.classList.remove('active');
            }
          }

          // Update the mute button states for all channels in this mute group.
          // NOTE: The mixer doesn't update individual channel mute states when a mute
          // group is activated ‚Äî the group acts as a master override. Querying
          // get-channel-mute immediately would return stale (pre-toggle) values.
          // Instead, drive visual state directly from the new group state.
          const assignments = await ipcRenderer.invoke('get-mute-group-assignments', groupNum);

          for (const assignment of assignments) {
            if (newState) {
              // Group just activated ‚Üí show all assigned channels as muted
              updateMuteButton(assignment.type, assignment.channel, true);
            } else {
              // Group just deactivated ‚Üí query the actual individual channel state
              const muted = await ipcRenderer.invoke('get-channel-mute', assignment.type, assignment.channel);
              if (muted !== null) {
                updateMuteButton(assignment.type, assignment.channel, muted);
              }
            }
          }
        } else {
          console.error(`[toggleMuteGroup] Failed to toggle mute group ${groupNum}:`, result.error);
        }
      } catch (error) {
        console.error(`[toggleMuteGroup] Error toggling mute group ${groupNum}:`, error);
      }
    }

    // Edit fader mapping (double-click handler)
    async function editFaderMapping(faderId) {
      try {
        const [channelType, channelNum] = faderId.split('-');
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'volume' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        if (mappingIndex === -1) {
          // No mapping exists - open add mapping dialog with pre-filled channel info
          showAddMapping();
          document.getElementById('mixer-channel-type').value = channelType;
          await updateChannelNumberOptions();
          document.getElementById('mixer-channel-num').value = channelNum;
          // Update MIDI settings to match the mixer channel
          updateMidiSettingsForChannel();
          return;
        }

        const mapping = mappings[mappingIndex];

        // Set flag to prevent auto-updating MIDI settings
        isEditingMapping = true;

        // Populate the add-mapping modal with existing data
        document.getElementById('midi-type').value = mapping.midi.type;

        if (mapping.midi.type === 'cc') {
          document.getElementById('midi-cc').value = mapping.midi.controller;
        } else if (mapping.midi.type === 'note') {
          document.getElementById('midi-note').value = mapping.midi.note;
        } else if (mapping.midi.type === 'note-value') {
          document.getElementById('midi-note-min').value = mapping.midi.noteMin || 24;
          document.getElementById('midi-note-max').value = mapping.midi.noteMax || 60;
        }

        // Update field visibility
        updateMidiTypeFields();

        document.getElementById('mixer-action').value = mapping.mixer.action;
        document.getElementById('mixer-channel-type').value = mapping.mixer.channel.type || 'LINE';

        // Update channel number options and then set the value
        await updateChannelNumberOptions();
        document.getElementById('mixer-channel-num').value = mapping.mixer.channel.channel || mapping.mixer.channel;

        // Set MIDI settings (won't be overwritten now because of isEditingMapping flag)
        document.getElementById('midi-channel').value = mapping.midi.channel;
        if (mapping.midi.type === 'cc') {
          document.getElementById('midi-cc').value = mapping.midi.controller;
        }

        // Clear the flag
        isEditingMapping = false;

        // Change modal title and buttons to indicate editing
        const modal = document.getElementById('add-mapping-modal');
        const modalTitle = modal.querySelector('h2');
        modalTitle.textContent = '‚úèÔ∏è Edit Mapping';
        document.getElementById('mapping-submit-btn').textContent = 'Save';
        document.getElementById('mapping-clear-btn').style.display = '';

        // Store the mapping index so we know we're editing
        modal.dataset.editingIndex = mappingIndex;

        // Populate device filter dropdown and pre-select the mapping's device if set
        const editedMapping = mappings[mappingIndex];
        await populateMidiDeviceFilter(editedMapping && editedMapping.midi && editedMapping.midi.device);

        // Show the modal
        modal.classList.add('show');
      } catch (error) {
        // Silent error handling
        isEditingMapping = false; // Make sure to clear flag on error
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Context menu management
    let currentContextMenuFaderId = null;

    function hideAllContextMenus() {
      document.getElementById('fader-context-menu')?.classList.remove('show');
      document.getElementById('mute-context-menu')?.classList.remove('show');
      document.getElementById('solo-context-menu')?.classList.remove('show');
      document.getElementById('channel-context-menu')?.classList.remove('show');
      document.getElementById('mutegroup-context-menu')?.classList.remove('show');
      currentContextMenuFaderId = null;
    }

    // Fader volume context menu
    function showFaderVolumeContextMenu(faderId, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('fader-context-menu');
      currentContextMenuFaderId = faderId;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuEditFader() {
      if (currentContextMenuFaderId) {
        await editFaderMapping(currentContextMenuFaderId);
      }
      hideAllContextMenus();
    }

    // Start MIDI learn mode if the mapping modal is open and learn isn't already active
    function activateMidiLearnInModal() {
      const modal = document.getElementById('add-mapping-modal');
      if (modal && modal.classList.contains('show') && !midiLearnActive) {
        toggleMidiListen();
      }
    }

    async function contextMenuLearnFader() {
      // Save ID before hiding menus (hideAllContextMenus nulls it out)
      const faderId = currentContextMenuFaderId;
      hideAllContextMenus();
      if (faderId) {
        await editFaderMapping(faderId);
        activateMidiLearnInModal();
      }
    }

    async function contextMenuLearnMute() {
      // contextMenuEditMute uses currentContextMenuFaderId and calls hideAllContextMenus itself
      await contextMenuEditMute();
      activateMidiLearnInModal();
    }

    async function contextMenuLearnSolo() {
      await contextMenuEditSolo();
      activateMidiLearnInModal();
    }

    async function contextMenuLearnMuteGroup() {
      await contextMenuEditMuteGroup();
      activateMidiLearnInModal();
    }

    async function contextMenuClearFader() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'volume' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        if (mappingIndex !== -1) {
          await ipcRenderer.invoke('remove-mapping', mappingIndex);
          await loadFaders();
          await loadMappings();
          markConfigChanged();
        }
      } catch (error) {
        alert(`‚úó Error clearing volume mapping: ${error.message}`);
      }

      hideAllContextMenus();
    }

    // Mute button context menu
    function showMuteContextMenu(faderId, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('mute-context-menu');
      currentContextMenuFaderId = faderId;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuEditMute() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      try {
        const [channelType, channelNum] = currentContextMenuFaderId.split('-');
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'mute' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        // Set flag to prevent auto-update during editing
        isEditingMapping = true;

        // Populate the modal
        const modal = document.getElementById('add-mapping-modal');

        if (mappingIndex !== -1) {
          // Editing existing mute mapping
          const mapping = mappings[mappingIndex];

          document.getElementById('midi-type').value = mapping.midi.type;
          if (mapping.midi.type === 'cc') {
            document.getElementById('midi-cc').value = mapping.midi.controller;
          } else if (mapping.midi.type === 'note') {
            document.getElementById('midi-note').value = mapping.midi.note;
          }
          document.getElementById('midi-channel').value = mapping.midi.channel;

          modal.dataset.editingIndex = mappingIndex;
          modal.querySelector('h2').textContent = '‚úèÔ∏è Edit Mute Mapping';
          document.getElementById('mapping-submit-btn').textContent = 'Save';
          document.getElementById('mapping-clear-btn').style.display = '';
        } else {
          // Creating new mute mapping
          document.getElementById('midi-type').value = 'note';
          document.getElementById('midi-note').value = '60';
          document.getElementById('midi-channel').value = channelNum;

          delete modal.dataset.editingIndex;
          modal.querySelector('h2').textContent = '‚ûï Create Mute Mapping';
          document.getElementById('mapping-submit-btn').textContent = 'Add Mapping';
          document.getElementById('mapping-clear-btn').style.display = 'none';
        }

        // Set channel info
        document.getElementById('mixer-channel-type').value = channelType;
        await updateChannelNumberOptions();
        document.getElementById('mixer-channel-num').value = channelNum;

        // Set action to mute
        document.getElementById('mixer-action').value = 'mute';

        // Update MIDI type fields
        updateMidiTypeFields();

        isEditingMapping = false;

        // Populate device filter, pre-selecting existing mapping's device if any
        const existingMuteMapping = mappingIndex !== -1 ? mappings[mappingIndex] : null;
        await populateMidiDeviceFilter(existingMuteMapping && existingMuteMapping.midi.device);

        // Show modal
        modal.classList.add('show');
      } catch (error) {
        isEditingMapping = false;
        alert(`‚úó Error: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuClearMute() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'mute' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        if (mappingIndex !== -1) {
          await ipcRenderer.invoke('remove-mapping', mappingIndex);
          await loadFaders();
          await loadMappings();
          markConfigChanged();
        }
      } catch (error) {
        alert(`‚úó Error clearing mute mapping: ${error.message}`);
      }

      hideAllContextMenus();
    }

    // Solo button context menu
    function showSoloContextMenu(faderId, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('solo-context-menu');
      currentContextMenuFaderId = faderId;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuEditSolo() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      try {
        const [channelType, channelNum] = currentContextMenuFaderId.split('-');
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'solo' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        // Set flag to prevent auto-update during editing
        isEditingMapping = true;

        // Populate the modal
        const modal = document.getElementById('add-mapping-modal');

        if (mappingIndex !== -1) {
          // Editing existing solo mapping
          const mapping = mappings[mappingIndex];

          document.getElementById('midi-type').value = mapping.midi.type;
          if (mapping.midi.type === 'cc') {
            document.getElementById('midi-cc').value = mapping.midi.controller;
          } else if (mapping.midi.type === 'note') {
            document.getElementById('midi-note').value = mapping.midi.note;
          }
          document.getElementById('midi-channel').value = mapping.midi.channel;

          modal.dataset.editingIndex = mappingIndex;
          modal.querySelector('h2').textContent = '‚úèÔ∏è Edit Solo Mapping';
          document.getElementById('mapping-submit-btn').textContent = 'Save';
          document.getElementById('mapping-clear-btn').style.display = '';
        } else {
          // Creating new solo mapping
          document.getElementById('midi-type').value = 'note';
          document.getElementById('midi-note').value = '61';
          document.getElementById('midi-channel').value = channelNum;

          delete modal.dataset.editingIndex;
          modal.querySelector('h2').textContent = '‚ûï Create Solo Mapping';
          document.getElementById('mapping-submit-btn').textContent = 'Add Mapping';
          document.getElementById('mapping-clear-btn').style.display = 'none';
        }

        // Set channel info
        document.getElementById('mixer-channel-type').value = channelType;
        await updateChannelNumberOptions();
        document.getElementById('mixer-channel-num').value = channelNum;

        // Set action to solo
        document.getElementById('mixer-action').value = 'solo';

        // Update MIDI type fields
        updateMidiTypeFields();

        isEditingMapping = false;

        // Populate device filter, pre-selecting existing mapping's device if any
        const existingSoloMapping = mappingIndex !== -1 ? mappings[mappingIndex] : null;
        await populateMidiDeviceFilter(existingSoloMapping && existingSoloMapping.midi.device);

        // Show modal
        modal.classList.add('show');
      } catch (error) {
        isEditingMapping = false;
        alert(`‚úó Error: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuClearSolo() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');
        const mappingIndex = mappings.findIndex(m =>
          m.mixer.action === 'solo' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        if (mappingIndex !== -1) {
          await ipcRenderer.invoke('remove-mapping', mappingIndex);
          await loadFaders();
          await loadMappings();
          markConfigChanged();
        }
      } catch (error) {
        alert(`‚úó Error clearing solo mapping: ${error.message}`);
      }

      hideAllContextMenus();
    }

    // Channel context menu
    function showChannelContextMenu(faderId, x, y) {
      hideAllContextMenus();
      const contextMenu = document.getElementById('channel-context-menu');
      currentContextMenuFaderId = faderId;
      positionContextMenu(contextMenu, x, y);
    }

    async function contextMenuToggleMain() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      try {
        const currentState = await ipcRenderer.invoke('get-channel-main-assign', channelType, channelNum);
        await ipcRenderer.invoke('set-channel-main-assign', channelType, channelNum, !currentState);
        await loadFaders(); // Reload to update visual state
      } catch (error) {
        alert(`‚úó Error toggling main assign: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuRemoveChannel() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      if (!confirm(`Remove ${channelType} ${channelNum} from the fader view?\n\nThis will also clear all MIDI mappings for this channel.`)) {
        hideAllContextMenus();
        return;
      }

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        // Find all mappings for this channel (volume, mute, solo, etc.)
        const indicesToRemove = [];
        mappings.forEach((m, index) => {
          if ((m.mixer.channel.type || 'LINE') === channelType &&
              (m.mixer.channel.channel || m.mixer.channel) == channelNum) {
            indicesToRemove.push(index);
          }
        });

        // Remove in reverse order to maintain indices
        for (let i = indicesToRemove.length - 1; i >= 0; i--) {
          await ipcRenderer.invoke('remove-mapping', indicesToRemove[i]);
        }

        await loadFaders();
        await loadMappings();
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error removing channel: ${error.message}`);
      }

      hideAllContextMenus();
    }

    async function contextMenuClearAllMappings() {
      if (!currentContextMenuFaderId) {
        hideAllContextMenus();
        return;
      }

      const [channelType, channelNum] = currentContextMenuFaderId.split('-');

      if (!confirm(`Clear ALL MIDI mappings (volume, mute, solo) for ${channelType} ${channelNum}?`)) {
        hideAllContextMenus();
        return;
      }

      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        // Find all mappings for this channel (volume, mute, solo, etc.)
        const indicesToRemove = [];
        mappings.forEach((m, index) => {
          if ((m.mixer.channel.type || 'LINE') === channelType &&
              (m.mixer.channel.channel || m.mixer.channel) == channelNum) {
            indicesToRemove.push(index);
          }
        });

        // Remove in reverse order to maintain indices
        for (let i = indicesToRemove.length - 1; i >= 0; i--) {
          await ipcRenderer.invoke('remove-mapping', indicesToRemove[i]);
        }

        await loadFaders();
        await loadMappings();
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error clearing all mappings: ${error.message}`);
      }

      hideAllContextMenus();
    }

    // Connect to MIDI device (additive ‚Äî keeps existing connections)
    async function connectToMidiDevice(deviceName) {
      try {
        const result = await ipcRenderer.invoke('connect-midi-device', deviceName);
        if (result.success) {
          // Reload the device list in-place (don't close modal ‚Äî user may want to add more)
          await loadMidiDevices();
          updateStatus();
        } else {
          alert(`‚úó Failed to connect: ${result.error}`);
        }
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Add or update mapping
    async function addMapping() {
      const modal = document.getElementById('add-mapping-modal');
      const isEditing = modal.dataset.editingIndex !== undefined;
      const editingIndex = isEditing ? parseInt(modal.dataset.editingIndex) : -1;

      const midiType = document.getElementById('midi-type').value;
      const midiChannel = parseInt(document.getElementById('midi-channel').value);
      const midiDeviceFilter = document.getElementById('midi-device-filter').value || undefined;
      const mixerAction = document.getElementById('mixer-action').value;
      const channelType = document.getElementById('mixer-channel-type').value;
      const channelNum = parseInt(document.getElementById('mixer-channel-num').value);

      const mapping = {
        midi: {
          type: midiType,
          channel: midiChannel,
          ...(midiDeviceFilter ? { device: midiDeviceFilter } : {})
        },
        mixer: {
          action: mixerAction,
          channel: {
            type: channelType,
            channel: channelNum
          }
        }
      };

      if (midiType === 'cc') {
        mapping.midi.controller = parseInt(document.getElementById('midi-cc').value);
        // Add threshold for boolean controls (mute/solo/mutegroup)
        if (mixerAction === 'mute' || mixerAction === 'solo' || mixerAction === 'mutegroup') {
          mapping.midi.threshold = parseInt(document.getElementById('midi-cc-threshold').value) || 64;
        }
      } else if (midiType === 'note') {
        mapping.midi.note = parseInt(document.getElementById('midi-note').value);
        // Add invert for boolean controls (mute/solo/mutegroup)
        if (mixerAction === 'mute' || mixerAction === 'solo' || mixerAction === 'mutegroup') {
          mapping.midi.invert = document.getElementById('midi-note-invert').checked;
        }
      } else if (midiType === 'note-value') {
        mapping.midi.noteMin = parseInt(document.getElementById('midi-note-min').value);
        mapping.midi.noteMax = parseInt(document.getElementById('midi-note-max').value);
      }

      try {
        // Check if this is a volume mapping on the second channel of a stereo pair
        if (mixerAction === 'volume' && channelNum % 2 === 0) {
          // Check if the previous channel (odd channel) is linked
          const prevChannelLink = await ipcRenderer.invoke('get-channel-link', channelType, channelNum - 1);
          if (prevChannelLink) {
            alert(`‚úó Cannot map volume on channel ${channelNum}!\n\nThis channel is the second channel of a stereo pair (linked with channel ${channelNum - 1}).\n\nVolume control is handled by the first channel of the stereo pair.`);
            return;
          }
        }

        // Get existing mappings for validation
        const existingMappings = await ipcRenderer.invoke('get-mappings');

        // Check for MIDI conflicts (same MIDI channel + CC/note) - skip if type is "none"
        if (midiType !== 'none') {
          const midiConflictIndex = existingMappings.findIndex((m, idx) => {
            // Skip if we're editing this mapping
            if (isEditing && idx === editingIndex) return false;

            // Skip if the existing mapping has no MIDI type
            if (m.midi.type === 'none') return false;

            // Check if MIDI settings conflict
            if (m.midi.channel !== midiChannel) return false;

            if (midiType === 'cc' && m.midi.type === 'cc') {
              return m.midi.controller === mapping.midi.controller;
            } else if (midiType === 'note' && m.midi.type === 'note') {
              return m.midi.note === mapping.midi.note;
            } else if (midiType === 'note-value' && m.midi.type === 'note-value') {
              // Check for overlapping note ranges
              const existingMin = m.midi.noteMin || 24;
              const existingMax = m.midi.noteMax || 60;
              const newMin = mapping.midi.noteMin || 24;
              const newMax = mapping.midi.noteMax || 60;
              return !(newMax < existingMin || newMin > existingMax);
            }
            return false;
          });

          if (midiConflictIndex !== -1) {
            const conflictMapping = existingMappings[midiConflictIndex];
            const conflictChannel = `${conflictMapping.mixer.channel.type || 'LINE'} ${conflictMapping.mixer.channel.channel || conflictMapping.mixer.channel}`;
            const midiInfo = mapping.midi.type === 'cc'
              ? `CC${mapping.midi.controller} Ch${mapping.midi.channel}`
              : mapping.midi.type === 'note-value'
              ? `Note ${mapping.midi.noteMin}-${mapping.midi.noteMax} Ch${mapping.midi.channel}`
              : `Note ${mapping.midi.note} Ch${mapping.midi.channel}`;

            alert(`‚úó MIDI Conflict!\n\nThis MIDI configuration (${midiInfo}) is already used by ${conflictChannel}.\n\nPlease choose different MIDI settings.`);
            return;
          }
        }

        if (isEditing) {
          // We're editing an existing mapping - remove the old one first
          await ipcRenderer.invoke('remove-mapping', editingIndex);
          await ipcRenderer.invoke('add-mapping', mapping);
          markConfigChanged();
        } else {
          // Check if a mapping already exists for this mixer channel + action
          const existingIndex = existingMappings.findIndex(m =>
            m.mixer.action === mixerAction &&
            (m.mixer.channel.type || 'LINE') === channelType &&
            (m.mixer.channel.channel || m.mixer.channel) == channelNum
          );

          if (existingIndex !== -1) {
            if (midiType === 'none') {
              // View-only: silently replace any existing mapping for this channel
              await ipcRenderer.invoke('remove-mapping', existingIndex);
            } else {
              // Ask user if they want to update the existing mapping
              const existingMapping = existingMappings[existingIndex];
              const existingMidiInfo = existingMapping.midi.type === 'cc'
                ? `${getCCShorthand(existingMapping.midi.controller)} Ch${existingMapping.midi.channel}`
                : existingMapping.midi.type === 'note-value'
                ? `Note ${existingMapping.midi.noteMin}-${existingMapping.midi.noteMax} Ch${existingMapping.midi.channel}`
                : existingMapping.midi.type === 'none'
                ? 'View only'
                : `Note ${existingMapping.midi.note} Ch${existingMapping.midi.channel}`;
              const newMidiInfo = mapping.midi.type === 'cc'
                ? `${getCCShorthand(mapping.midi.controller)} Ch${mapping.midi.channel}`
                : mapping.midi.type === 'note-value'
                ? `Note ${mapping.midi.noteMin}-${mapping.midi.noteMax} Ch${mapping.midi.channel}`
                : `Note ${mapping.midi.note} Ch${mapping.midi.channel}`;

              if (!confirm(`A mapping already exists for ${channelType} ${channelNum} (${mixerAction}):\n\nExisting: ${existingMidiInfo}\nNew: ${newMidiInfo}\n\nUpdate the existing mapping?`)) {
                return;
              }

              // Remove the old mapping and add the new one
              await ipcRenderer.invoke('remove-mapping', existingIndex);
            }
          }

          await ipcRenderer.invoke('add-mapping', mapping);
          markConfigChanged();
        }

        hideAddMapping();
        loadMappings();
        loadFaders(); // Reload faders to show new mapping

        // If we came from the mappings list, return to it
        if (returnToMappingsList) {
          returnToMappingsList = false;
          setTimeout(() => showMappingsList(), 100);
        }
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Clear the mapping currently open in the edit modal
    async function clearCurrentMapping() {
      const modal = document.getElementById('add-mapping-modal');
      const index = parseInt(modal.dataset.editingIndex, 10);
      if (isNaN(index)) return;
      if (!confirm('Remove this mapping?')) return;
      try {
        hideAddMapping();
        await ipcRenderer.invoke('remove-mapping', index);
        loadMappings();
        loadFaders();
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Remove mapping
    async function removeMapping(index) {
      if (!confirm('Remove this mapping?')) return;

      try {
        await ipcRenderer.invoke('remove-mapping', index);
        loadMappings();
        loadFaders(); // Update faders UI
        markConfigChanged();
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Save preset
    async function savePreset() {
      const name = document.getElementById('preset-name').value.trim();
      const description = document.getElementById('preset-description').value.trim();

      if (!name) {
        alert('Please enter a preset name');
        return;
      }

      try {
        const result = await ipcRenderer.invoke('save-preset', name, description);
        if (result.success) {
          alert(`‚úì Preset saved to ${result.path}`);
          hideSavePreset();
          updateStatus();
          updateStatusLastSaved(Date.now());
        } else {
          alert(`‚úó Failed to save: ${result.error}`);
        }
      } catch (error) {
        alert(`‚úó Error: ${error.message}`);
      }
    }

    // Load mappings
    async function loadMappings() {
      try {
        const mappings = await ipcRenderer.invoke('get-mappings');

        // Store in global variable for use by other components (e.g., mute groups)
        currentMappings = mappings;

        const channelNames = await ipcRenderer.invoke('get-channel-names', 'line', 16);
        const listEl = document.getElementById('mappings-list');

        if (mappings.length === 0) {
          listEl.innerHTML = '<div class="empty-state">No mappings yet. Click "Create New" to add one.</div>';
        } else {
          listEl.innerHTML = mappings.map((mapping, index) => {
            const midiDesc = mapping.midi.type === 'cc'
              ? `CC ${mapping.midi.controller} (Ch ${mapping.midi.channel})`
              : `Note ${mapping.midi.note} (Ch ${mapping.midi.channel})`;

            // Extract channel number and get name
            const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
            const channelInfo = channelNames.find(c => c.channel === channelNum);
            const channelName = channelInfo ? channelInfo.name : `Ch ${channelNum}`;
            const mixerDesc = `${mapping.mixer.action} - ${channelNum}: ${channelName}`;

            // Apply device color to the MIDI source label
            const devColor = mapping.midi.device ? (midiDeviceColors[mapping.midi.device] || '') : '';
            const sourceStyle = devColor
              ? `background:${devColor};color:${getTextColorForBackground(devColor)};padding:2px 6px;border-radius:3px;`
              : '';

            return `
              <div class="mapping-card">
                <div class="mapping-activity" id="mapping-activity-${index}"></div>
                <div class="mapping-info">
                  <div class="mapping-source" style="${sourceStyle}">üéπ ${midiDesc}</div>
                  <div class="mapping-arrow">‚Üí</div>
                  <div class="mapping-target">üéõÔ∏è ${mixerDesc}</div>
                </div>
                <button class="btn-small danger" onclick="removeMapping(${index})">Delete</button>
              </div>
            `;
          }).join('');
        }
      } catch (error) {
        // Silent error handling
      }
    }

    // Load faders
    async function loadFaders() {
      // Prevent multiple simultaneous calls
      if (isLoadingFaders) {
        addStatusLog('Skipped duplicate loadFaders call', 'warning');
        return;
      }

      isLoadingFaders = true;

      try {
        await updateStatusInitWithDelay('Loading channel mappings...');
        const mappings = await ipcRenderer.invoke('get-mappings');

        const volumeMappings = mappings.filter(m => m.mixer.action === 'volume');

        // Reset channel data cache
        channelDataCache = {};

        // Always fetch LINE channel data
        await updateStatusInitWithDelay('Fetching LINE channel data...');
        try {
          const names = await ipcRenderer.invoke('get-channel-names', 'line', 16);
          const colors = await ipcRenderer.invoke('get-channel-colors', 'line', 16);
          const icons = await ipcRenderer.invoke('get-channel-icons', 'line', 16);
          const inputSources = await ipcRenderer.invoke('get-channel-input-sources', 'line', 16);

          // Debug logging for input sources

          // Fetch stereo link status for each channel
          const links = [];
          for (let i = 1; i <= 16; i++) {
            const link = await ipcRenderer.invoke('get-channel-link', 'line', i);
            links.push({ channel: i, link });
          }


          channelDataCache['line'] = { names, colors, icons, links, inputSources };
        } catch (error) {
          console.error('[Renderer] Error fetching LINE channel data:', error);
          const errorMsg = `Error fetching LINE channels: ${error.message || error}`;
          updateStatusInit(errorMsg);
          addStatusLog(errorMsg, 'error');
          channelDataCache['line'] = { names: [], colors: [], icons: [], links: [], inputSources: [] };
        }

        // Always fetch SUB channel data (for subgroups)
        await updateStatusInitWithDelay('Fetching SUB channel data...');
        try {
          const names = await ipcRenderer.invoke('get-channel-names', 'sub', 8);
          const colors = await ipcRenderer.invoke('get-channel-colors', 'sub', 8);
          const icons = await ipcRenderer.invoke('get-channel-icons', 'sub', 8);
          const inputSources = await ipcRenderer.invoke('get-channel-input-sources', 'sub', 8);


          // Fetch stereo link status for each channel
          const links = [];
          for (let i = 1; i <= 8; i++) {
            const link = await ipcRenderer.invoke('get-channel-link', 'sub', i);
            links.push({ channel: i, link });
          }

          channelDataCache['sub'] = { names, colors, icons, links, inputSources };
        } catch (error) {
          console.error('[Renderer] Error fetching SUB channel data:', error);
          const errorMsg = `Error fetching SUB channels: ${error.message || error}`;
          updateStatusInit(errorMsg);
          addStatusLog(errorMsg, 'error');
          channelDataCache['sub'] = { names: [], colors: [], icons: [], links: [], inputSources: [] };
        }

        // Always fetch DCA channel data (for DCA groups)
        await updateStatusInitWithDelay('Fetching DCA group data...');
        try {
          const names = await ipcRenderer.invoke('get-channel-names', 'dca', 8);
          const colors = await ipcRenderer.invoke('get-channel-colors', 'dca', 8);
          const icons = await ipcRenderer.invoke('get-channel-icons', 'dca', 8);
          const inputSources = await ipcRenderer.invoke('get-channel-input-sources', 'dca', 8);


          // Fetch stereo link status for each channel
          const links = [];
          for (let i = 1; i <= 8; i++) {
            const link = await ipcRenderer.invoke('get-channel-link', 'dca', i);
            links.push({ channel: i, link });
          }

          channelDataCache['dca'] = { names, colors, icons, links, inputSources };

          // Update filter dropdown with DCA groups
          updateFilterDropdown();
        } catch (error) {
          console.error('[Renderer] Error fetching DCA channel data:', error);
          const errorMsg = `Error fetching DCA groups: ${error.message || error}`;
          updateStatusInit(errorMsg);
          addStatusLog(errorMsg, 'error');
          channelDataCache['dca'] = { names: [], colors: [], icons: [], links: [], inputSources: [] };
        }

        // Fetch channel data for other channel types that have mappings
        for (const mapping of volumeMappings) {
          const channelType = (mapping.mixer.channel.type || 'LINE').toLowerCase();
          if (channelType !== 'line' && !channelDataCache[channelType]) {
            try {
              const names = await ipcRenderer.invoke('get-channel-names', channelType, 16);
              const colors = await ipcRenderer.invoke('get-channel-colors', channelType, 16);
              const icons = await ipcRenderer.invoke('get-channel-icons', channelType, 16);
              const inputSources = await ipcRenderer.invoke('get-channel-input-sources', channelType, 16);

              // Fetch stereo link status for each channel
              const links = [];
              for (let i = 1; i <= 16; i++) {
                const link = await ipcRenderer.invoke('get-channel-link', channelType, i);
                links.push({ channel: i, link });
              }

              channelDataCache[channelType] = { names, colors, icons, links, inputSources };
            } catch (error) {
              // Silent error handling
              channelDataCache[channelType] = { names: [], colors: [], icons: [], links: [], inputSources: [] };
            }
          }
        }

        // Build fader list based on filter mode
        let fadersToRender = [];

        if (faderFilter === 'all') {
          // Show all LINE channels 1-16, but skip second channel of stereo pairs
          const lineData = channelDataCache['line'] || { names: [], colors: [], icons: [], links: [], inputSources: [] };

          for (let i = 1; i <= 16; i++) {
            // Check if this channel is the RIGHT side of a stereo pair
            // A channel is the right side if it's even AND the previous (odd) channel is linked
            if (i % 2 === 0) {
              const prevChannelLink = lineData.links.find(c => c.channel === (i - 1));
              if (prevChannelLink?.link) {
                // Skip this channel - it's the R channel of a stereo pair
                continue;
              }
            }

            const existingMapping = volumeMappings.find(m =>
              (m.mixer.channel.type || 'LINE') === 'LINE' &&
              (m.mixer.channel.channel || m.mixer.channel) === i
            );

            if (existingMapping) {
              fadersToRender.push(existingMapping);
            } else {
              // Create a virtual mapping with no MIDI type
              fadersToRender.push({
                midi: { type: 'none', channel: 1 },
                mixer: { action: 'volume', channel: { type: 'LINE', channel: i } }
              });
            }
          }

          // Add all non-LINE mapped channels (AUX, FX, SUB, MAIN, etc.)
          const nonLineChannels = volumeMappings.filter(m => (m.mixer.channel.type || 'LINE') !== 'LINE');
          fadersToRender.push(...nonLineChannels);

          // Add DCA faders for DCA groups that are "in use"
          // A DCA is "in use" if it has EITHER:
          // 1. A custom name (not default like "Ch 1" or "DCA 1"), OR
          // 2. Channels assigned to it
          const dcaData = channelDataCache['dca'] || { names: [] };
          for (let i = 1; i <= 8; i++) {
            const dcaName = dcaData.names.find(n => n.channel === i);

            // Check if this DCA has a custom name (not default)
            const hasCustomName = dcaName &&
                                  dcaName.name &&
                                  dcaName.name.trim() !== '' &&
                                  dcaName.name !== `Ch ${i}` &&
                                  dcaName.name !== `DCA ${i}`;

            // Check if this DCA has any channels assigned to it
            const assignedChannels = await ipcRenderer.invoke('get-dca-group-assignments', i);
            const hasChannelsAssigned = assignedChannels && assignedChannels.length > 0;

            // Only add if it has a custom name OR channels assigned
            if (hasCustomName || hasChannelsAssigned) {
              // Check if we already have this DCA in the list
              const existingDca = fadersToRender.find(m =>
                (m.mixer.channel.type || 'LINE') === 'DCA' &&
                m.mixer.channel.channel === i
              );

              if (!existingDca) {
                // Add virtual DCA fader
                fadersToRender.push({
                  midi: { type: 'none', channel: 1 },
                  mixer: { action: 'volume', channel: { type: 'DCA', channel: i } }
                });
                const reason = hasCustomName && hasChannelsAssigned ? 'custom name + channels' :
                               hasCustomName ? 'custom name' : 'channels assigned';
              }
            }
          }
        } else if (faderFilter === 'added') {
          // Show all explicitly added channels (both view-only and mapped)
          fadersToRender = volumeMappings;
        } else if (faderFilter === 'mapped') {
          // Show only mapped channels (exclude channels with type 'none')
          fadersToRender = volumeMappings.filter(m => m.midi.type !== 'none');
        } else if (faderFilter.startsWith('dca-')) {
          // Show only channels assigned to this DCA group
          const dcaChannel = parseInt(faderFilter.replace('dca-', ''));

          // Get LINE channels assigned to this DCA group
          const assignedChannels = await ipcRenderer.invoke('get-dca-group-assignments', dcaChannel);

          // Add assigned LINE channels
          const lineData = channelDataCache['line'] || { names: [], colors: [], icons: [], links: [], inputSources: [] };

          for (const lineChannel of assignedChannels) {
            // Skip if this is the RIGHT side of a stereo pair
            if (lineChannel % 2 === 0) {
              const prevChannelLink = lineData.links.find(c => c.channel === (lineChannel - 1));
              if (prevChannelLink?.link) {
                continue;
              }
            }

            const existingMapping = volumeMappings.find(m =>
              (m.mixer.channel.type || 'LINE') === 'LINE' &&
              (m.mixer.channel.channel || m.mixer.channel) === lineChannel
            );

            if (existingMapping) {
              fadersToRender.push(existingMapping);
            } else {
              // Create a virtual mapping with no MIDI type
              fadersToRender.push({
                midi: { type: 'none', channel: 1 },
                mixer: { action: 'volume', channel: { type: 'LINE', channel: lineChannel } }
              });
            }
          }

          // Add the DCA fader itself
          const dcaMapping = volumeMappings.find(m =>
            (m.mixer.channel.type || 'LINE') === 'DCA' &&
            m.mixer.channel.channel === dcaChannel
          );

          if (dcaMapping) {
            fadersToRender.push(dcaMapping);
          } else {
            // Create virtual DCA fader
            fadersToRender.push({
              midi: { type: 'none', channel: 1 },
              mixer: { action: 'volume', channel: { type: 'DCA', channel: dcaChannel } }
            });
          }
        } else if (faderFilter.startsWith('auto-')) {
          // Show only channels assigned to this auto-filter group
          const autoGroupChannel = parseInt(faderFilter.replace('auto-', ''));

          // Get LINE channels assigned to this auto-filter group
          const assignedChannels = await ipcRenderer.invoke('get-autofilter-group-assignments', autoGroupChannel);

          // Add assigned LINE channels
          const lineData = channelDataCache['line'] || { names: [], colors: [], icons: [], links: [], inputSources: [] };

          for (const lineChannel of assignedChannels) {
            // Skip if this is the RIGHT side of a stereo pair
            if (lineChannel % 2 === 0) {
              const prevChannelLink = lineData.links.find(c => c.channel === (lineChannel - 1));
              if (prevChannelLink?.link) {
                continue;
              }
            }

            const existingMapping = volumeMappings.find(m =>
              (m.mixer.channel.type || 'LINE') === 'LINE' &&
              (m.mixer.channel.channel || m.mixer.channel) === lineChannel
            );

            if (existingMapping) {
              fadersToRender.push(existingMapping);
            } else {
              // Create a virtual mapping with no MIDI type
              fadersToRender.push({
                midi: { type: 'none', channel: 1 },
                mixer: { action: 'volume', channel: { type: 'LINE', channel: lineChannel } }
              });
            }
          }
        } else {
          // Unknown filter mode, show mapped
          fadersToRender = volumeMappings;
        }

        // Always include MAIN channel in every view (ensure at least 1 MAIN fader is visible)
        const mainAlreadyIncluded = fadersToRender.some(m => (m.mixer.channel.type || 'LINE') === 'MAIN');
        if (!mainAlreadyIncluded) {
          const existingMain = volumeMappings.find(m => (m.mixer.channel.type || 'LINE') === 'MAIN');
          fadersToRender.push(existingMain || {
            midi: { type: 'none', channel: 1 },
            mixer: { action: 'volume', channel: { type: 'MAIN', channel: 1 } }
          });
        }


        // Separate channels by type for proper layout
        // Layout: LINE inputs in regular container (left side)
        // Right side (main container): DCA, SUB, AUX, FX, FXRETURN, then MAIN (from left to right)
        const lineInputs = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'LINE');
        const dcaChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'DCA');
        const subChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'SUB');
        const fxChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'FX');
        const fxReturnChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'FXRETURN');
        const auxChannels = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'AUX');
        const mainMappings = fadersToRender.filter(m => (m.mixer.channel.type || 'LINE') === 'MAIN');

        // Sort each group by channel number (numerically left to right)
        const sortByChannelNum = (a, b) => {
          const aNum = a.mixer.channel.channel || 0;
          const bNum = b.mixer.channel.channel || 0;
          return aNum - bNum;
        };

        lineInputs.sort(sortByChannelNum);
        dcaChannels.sort(sortByChannelNum);
        subChannels.sort(sortByChannelNum);
        fxChannels.sort(sortByChannelNum);
        fxReturnChannels.sort(sortByChannelNum);
        auxChannels.sort(sortByChannelNum);
        mainMappings.sort(sortByChannelNum);

        // Regular container: LINE only (left to right)
        const sortedRegularMappings = [...lineInputs];

        // Main container: DCA, SUB, AUX, FX, FXRETURN, then MAIN (left to right)
        const sortedMainMappings = [...dcaChannels, ...subChannels, ...auxChannels, ...fxChannels, ...fxReturnChannels, ...mainMappings];

        const container = document.getElementById('faders-container');
        const mainContainer = document.getElementById('faders-main-container');

        // Helper function to convert inputsrc number to SVG icon HTML
        const getInputSourceLabel = (inputsrc) => {
          const src = (inputsrc === null || inputsrc === undefined) ? 0 : inputsrc;
          switch (src) {
            case 0: // Analog ‚Äî XLR connector: outer ring w/ latch notch at top, filled inner circle, pins at 3/6/9
              return `<svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" aria-label="Analog (XLR)"><circle cx="8" cy="8" r="6.5" stroke-width="1.5" stroke-dasharray="28.63 4 8.21"/><rect x="5.5" y="0.2" width="5" height="2.2" rx="0.4" fill="currentColor" stroke="none"/><circle cx="11.6" cy="8" r="1.0" fill="currentColor" stroke="none"/><circle cx="8" cy="11.6" r="1.0" fill="currentColor" stroke="none"/><circle cx="4.4" cy="8" r="1.0" fill="currentColor" stroke="none"/><circle cx="8" cy="8" r="3.6" fill="currentColor" stroke="none"/><circle cx="8" cy="8" r="1.0" fill="rgba(0,0,0,0.6)" stroke="none"/></svg>`;
            case 1: // Network ‚Äî hierarchy diagram
              return `<svg viewBox="0 0 16 16" width="16" height="16" fill="currentColor" aria-label="Network"><rect x="5" y="1" width="6" height="3.5" rx="0.8"/><rect x="1" y="11.5" width="4" height="3.5" rx="0.8"/><rect x="6" y="11.5" width="4" height="3.5" rx="0.8"/><rect x="11" y="11.5" width="4" height="3.5" rx="0.8"/><rect x="7.3" y="4.5" width="1.4" height="3" rx="0.3"/><rect x="1.5" y="8.8" width="13" height="1.4" rx="0.3"/><rect x="2.5" y="8.8" width="1.4" height="2.7" rx="0.3"/><rect x="7.3" y="8.8" width="1.4" height="2.7" rx="0.3"/><rect x="12.1" y="8.8" width="1.4" height="2.7" rx="0.3"/></svg>`;
            case 2: // USB ‚Äî USB trident symbol
              return `<svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.4" aria-label="USB"><line x1="8" y1="2" x2="8" y2="10.5"/><line x1="5" y1="5.5" x2="11" y2="5.5"/><line x1="5" y1="3.5" x2="5" y2="5.5"/><rect x="3.5" y="1.8" width="3" height="2" rx="0.5" fill="currentColor" stroke="none"/><circle cx="5" cy="8.2" r="1.5" stroke="currentColor"/><rect x="9.5" y="5.5" width="3" height="2" rx="0.5" fill="currentColor" stroke="none"/><line x1="8" y1="10.5" x2="8" y2="12.5"/><rect x="5.5" y="12.5" width="5" height="3" rx="0.8" fill="currentColor" stroke="none"/></svg>`;
            case 3: // SD Card
              return `<svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.4" aria-label="SD Card"><path d="M3 1.5h7l3.5 3.5V15H3V1.5z"/><line x1="5" y1="9" x2="5" y2="14" stroke-width="1"/><line x1="7.5" y1="9" x2="7.5" y2="14" stroke-width="1"/><line x1="10" y1="9" x2="10" y2="14" stroke-width="1"/></svg>`;
            default:
              return `<svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" aria-label="Analog (XLR)"><circle cx="8" cy="8" r="6.5" stroke-width="1.5" stroke-dasharray="28.63 4 8.21"/><rect x="5.5" y="0.2" width="5" height="2.2" rx="0.4" fill="currentColor" stroke="none"/><circle cx="11.6" cy="8" r="1.0" fill="currentColor" stroke="none"/><circle cx="8" cy="11.6" r="1.0" fill="currentColor" stroke="none"/><circle cx="4.4" cy="8" r="1.0" fill="currentColor" stroke="none"/><circle cx="8" cy="8" r="3.6" fill="currentColor" stroke="none"/><circle cx="8" cy="8" r="1.0" fill="rgba(0,0,0,0.6)" stroke="none"/></svg>`;
          }
        };

        // Helper function to get tooltip text for input source
        const getInputSourceTooltip = (inputsrc) => {
          const src = (inputsrc === null || inputsrc === undefined) ? 0 : inputsrc;
          switch (src) {
            case 0: return 'Input: Analog (XLR)';
            case 1: return 'Input: Network';
            case 2: return 'Input: USB';
            case 3: return 'Input: SD Card';
            default: return 'Input: Analog';
          }
        };

        // Helper function to get CSS class for input source
        const getInputSourceClass = (inputsrc) => {
          if (inputsrc === null || inputsrc === undefined) return 'source-analog';
          switch (inputsrc) {
            case 0: return 'source-analog';
            case 1: return 'source-network';
            case 2: return 'source-usb';
            case 3: return 'source-sdcard';
            default: return 'source-analog';
          }
        };

        // Render function for creating fader HTML
        const renderFader = (mapping) => {
            // Extract channel number from ChannelSelector object
            const channelType = mapping.mixer.channel.type || 'LINE';
            const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;


            // Get channel data for this type
            const channelData = channelDataCache[channelType.toLowerCase()] || { names: [], colors: [], icons: [], links: [], inputSources: [] };

            const channelInfo = channelData.names.find(c => c.channel === channelNum);
            const channelName = channelInfo ? channelInfo.name : `Ch ${channelNum}`;


            const channelColorInfo = channelData.colors.find(c => c.channel === channelNum);
            // Use default grey color if mixer doesn't provide color
            let channelColor = channelColorInfo?.color || DEFAULT_COLOR;

            // Ensure channelColor is a valid string (not an object or null)
            if (typeof channelColor !== 'string' || !channelColor) {
              channelColor = DEFAULT_COLOR;
            }

            const channelIconInfo = channelData.icons.find(c => c.channel === channelNum);

            // Temporary debugging for channels 3, 9, and 10-14 to see what icon IDs the mixer reports
            const channelIcon = channelIconInfo?.icon ? getIconForId(channelIconInfo.icon, channelType, channelNum) : getIconForId('', channelType, channelNum);

            // Check if channel is part of stereo pair
            const channelLinkInfo = channelData.links.find(c => c.channel === channelNum);
            const isLinked = channelLinkInfo?.link || false;

            // Get input source for this channel
            // For stereo pairs, check the RIGHT channel (channelNum + 1) to determine USB vs LINE
            const inputSourceChannel = isLinked ? channelNum + 1 : channelNum;
            const channelInputSourceInfo = channelData.inputSources?.find(c => c.channel === inputSourceChannel);

            // Debug logging for input source
            const inputSourceLabel = getInputSourceLabel(channelInputSourceInfo?.inputsrc);
            const inputSourceClass = getInputSourceClass(channelInputSourceInfo?.inputsrc);
            const inputSourceTooltip = getInputSourceTooltip(channelInputSourceInfo?.inputsrc);

            // Convert hex format if needed (e.g., "b2fdfcff" -> "#b2fdfc")
            if (channelColor && !channelColor.startsWith('#') && channelColor.length >= 6) {
              channelColor = '#' + channelColor.substring(0, 6);
            }

            // Override color for FX channels to match Universal Control (light purple/pink)
            if (channelType === 'FX' || channelType === 'FXRETURN') {
              channelColor = '#d4a5d4'; // Light purple/pink color
            }

            // Create unique ID that includes type and channel
            const faderId = `${channelType}-${channelNum}`;

            // Store color for this fader to preserve it across updates
            faderColors.set(faderId, channelColor);

            // Separate channel number and name for better layout
            // For stereo channels, show "11/12" format
            // Add channel type prefix for non-LINE channels
            let channelNumber;
            if (channelType === 'MAIN') {
              channelNumber = 'MAIN';
            } else if (channelType === 'LINE') {
              channelNumber = isLinked ? `${channelNum}/${channelNum + 1}` : `${channelNum}`;
            } else if (channelType === 'AUX') {
              channelNumber = `AUX ${channelNum}`;
            } else if (channelType === 'FX') {
              channelNumber = `FXB ${channelNum}`;
            } else if (channelType === 'FXRETURN') {
              // Convert channel number to letter (1=A, 2=B, 3=C, 4=D)
              const letter = String.fromCharCode(64 + channelNum); // 65 is 'A'
              channelNumber = `FXR ${letter}`;
            } else if (channelType === 'TALKBACK') {
              channelNumber = 'TALK';
            } else if (channelType === 'RETURN') {
              channelNumber = 'DigRet';
            } else if (channelType === 'SUB') {
              channelNumber = `SUB ${channelNum}`;
            } else if (channelType === 'DCA') {
              channelNumber = `DCA ${channelNum}`;
            } else {
              // Fallback for any other channel types
              channelNumber = isLinked ? `${channelNum}/${channelNum + 1}` : `${channelNum}`;
            }
            // Show name for SUB channels and other non-MAIN channels
            const channelLabel = channelType === 'MAIN' ? '' : channelName;

            // Calculate appropriate text color based on background brightness
            const textColor = getTextColorForBackground(channelColor);

            // Apply color as background of label with appropriate text color
            const labelStyle = `background: ${channelColor}; color: ${textColor};`;

            // Get MIDI mapping info ‚Äî plain text (used for both display and title)
            const midiInfo = mapping.midi.type === 'none'
              ? ''
              : mapping.midi.type === 'cc'
              ? `${getCCShorthand(mapping.midi.controller)} Ch${mapping.midi.channel}`
              : mapping.midi.type === 'note-value'
              ? `Note ${mapping.midi.noteMin}-${mapping.midi.noteMax} Ch${mapping.midi.channel}`
              : mapping.midi.type === 'note'
              ? `Note ${mapping.midi.note} Ch${mapping.midi.channel}`
              : '';

            // Check if this channel has MIDI mapping
            const isMapped = mapping.midi.type !== 'none';

            // Device color ‚Üí background of the mapping label (not a badge dot)
            const mappedDevice = mapping.midi.device || '';
            const deviceMissing = isMapped && mappedDevice && !connectedMidiDevices.has(mappedDevice);
            const deviceColor = mappedDevice ? (midiDeviceColors[mappedDevice] || '') : '';
            const midiLabelStyle = (!deviceMissing && deviceColor)
              ? `background:${deviceColor};color:${getTextColorForBackground(deviceColor)};border-color:${deviceColor};`
              : '';
            const midiLabelClass = isMapped ? (deviceMissing ? 'mapped device-missing' : 'mapped') : '';
            // When mapped and has device color, override the default green border
            const containerMappedStyle = isMapped && deviceColor && !deviceMissing
              ? `border-color:${deviceColor}; box-shadow: 0 0 4px ${deviceColor}66;`
              : '';
            const containerMissingClass = deviceMissing ? ' device-missing' : '';

            // Determine if this channel type can be assigned to main
            // AUX, TALKBACK, MAIN, and DCA channels cannot be assigned to main
            const canAssignToMain = !['AUX', 'TALKBACK', 'MAIN', 'DCA'].includes(channelType);

            // Determine if this channel type has input sources
            // LINE, FX (FX Bus), and FXRETURN (FX Return) channels have selectable input sources (LINE/USB/SD/AVB)
            const hasInputSource = ['LINE', 'FX', 'FXRETURN'].includes(channelType);

            // Render stereo channels as dual L/R faders
            if (isLinked) {
              const faderIdR = `${channelType}-${channelNum + 1}`;
              return `
                <div class="fader-channel" data-fader-id="${faderId}">
                  <div class="fader-indicators" style="display: flex; flex-direction: column; gap: 2px; margin-bottom: 4px;">
                    ${canAssignToMain ? `<span class="fader-indicator main-assign unassigned" id="main-indicator-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleMainAssign('${channelType}', ${channelNum})" style="cursor: pointer;">Main</span>` : '<span class="fader-indicator main-assign" style="visibility: hidden;">Main</span>'}
                    ${hasInputSource ? `<span class="fader-indicator input-source ${inputSourceClass}" id="input-indicator-${faderId}" title="${inputSourceTooltip}">${inputSourceLabel}</span>` : '<span class="fader-indicator input-source" style="visibility: hidden;"></span>'}
                  </div>
                  <div class="fader-controls">
                    <button class="mute-btn" id="mute-btn-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleMute('${channelType}', ${channelNum})" title="">M</button>
                    <button class="solo-btn" id="solo-btn-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleSolo('${channelType}', ${channelNum})" title="">S</button>
                  </div>
                  <div class="fader-value" id="fader-value-${faderId}">0%</div>
                  <div class="fader-wrapper">
                    <div class="fader-levels">
                      <div class="level-labels">
                        <span>10</span>
                        <span>5</span>
                        <span>0</span>
                        <span>-5</span>
                        <span>-10</span>
                        <span>-20</span>
                        <span>-30</span>
                        <span>‚àû</span>
                      </div>
                      <div class="fader-meter" id="fader-meter-${faderId}" style="${currentLevelVisibility === 'meter' ? '' : 'display:none'}">
                        <div class="fader-meter-fill" id="fader-meter-fill-${faderId}"></div>
                        <div class="fader-meter-peak" id="fader-meter-peak-${faderId}"></div>
                        <div class="fader-meter-tick" style="bottom:100%"></div>
                        <div class="fader-meter-tick" style="bottom:83.3%"></div>
                        <div class="fader-meter-tick" style="bottom:66.7%"></div>
                        <div class="fader-meter-tick" style="bottom:50%"></div>
                      </div>
                    </div>
                    <div class="fader-container-wrapper">
                      <div style="display: flex; gap: 2px;">
                        <div class="fader-container stereo${isMapped ? ' mapped' : ''}${containerMissingClass}" data-channel="${channelNum}" data-type="${channelType}" data-fader-id="${faderId}" title="${isMapped ? 'Volume: ' + midiInfo : ''}"${containerMappedStyle ? ` style="${containerMappedStyle}"` : ''}>
                          <div class="fader-fill" id="fader-fill-${faderId}" style="height: 0%"></div>
                          <div class="fader-midi-indicator" id="fader-midi-${faderId}" style="bottom: 0%; display: none;"></div>
                        </div>
                        <div class="fader-container stereo${isMapped ? ' mapped' : ''}${containerMissingClass}" data-channel="${channelNum + 1}" data-type="${channelType}" data-fader-id="${faderIdR}" title="${isMapped ? 'Volume: ' + midiInfo : ''}"${containerMappedStyle ? ` style="${containerMappedStyle}"` : ''}>
                          <div class="fader-fill" id="fader-fill-${faderIdR}" style="height: 0%"></div>
                          <div class="fader-midi-indicator" id="fader-midi-${faderIdR}" style="bottom: 0%; display: none;"></div>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="fader-icon" style="${channelIcon ? '' : 'visibility: hidden;'}">${channelIcon || 'üéµ'}</div>
                  <div class="fader-channel-number"><span class="fader-indicator-dot" id="fader-dot-${faderId}"></span>${channelNumber}</div>
                  <div class="fader-label" style="${labelStyle}">${channelLabel}</div>
                  ${isMapped ? `<div class="fader-mapping-info ${midiLabelClass}" title="Volume: ${midiInfo}" style="${midiLabelStyle}">${midiInfo}</div>` : '<div class="fader-mapping-info" style="visibility:hidden;"></div>'}
                </div>
              `;
            } else {
              // Mono channel - single fader
              return `
                <div class="fader-channel" data-fader-id="${faderId}">
                  <div class="fader-indicators" style="display: flex; flex-direction: column; gap: 2px; margin-bottom: 4px;">
                    ${canAssignToMain ? `<span class="fader-indicator main-assign unassigned" id="main-indicator-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleMainAssign('${channelType}', ${channelNum})" style="cursor: pointer;">Main</span>` : '<span class="fader-indicator main-assign" style="visibility: hidden;">Main</span>'}
                    ${hasInputSource ? `<span class="fader-indicator input-source ${inputSourceClass}" id="input-indicator-${faderId}" title="${inputSourceTooltip}">${inputSourceLabel}</span>` : '<span class="fader-indicator input-source" style="visibility: hidden;"></span>'}
                  </div>
                  <div class="fader-controls">
                    <button class="mute-btn" id="mute-btn-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleMute('${channelType}', ${channelNum})" title="">M</button>
                    <button class="solo-btn" id="solo-btn-${faderId}" data-channel="${channelNum}" data-type="${channelType}" onclick="toggleSolo('${channelType}', ${channelNum})" title="">S</button>
                  </div>
                  <div class="fader-value" id="fader-value-${faderId}">0%</div>
                  <div class="fader-wrapper">
                    <div class="fader-levels">
                      <div class="level-labels">
                        <span>10</span>
                        <span>5</span>
                        <span>0</span>
                        <span>-5</span>
                        <span>-10</span>
                        <span>-20</span>
                        <span>-30</span>
                        <span>‚àû</span>
                      </div>
                      <div class="fader-meter" id="fader-meter-${faderId}" style="${currentLevelVisibility === 'meter' ? '' : 'display:none'}">
                        <div class="fader-meter-fill" id="fader-meter-fill-${faderId}"></div>
                        <div class="fader-meter-peak" id="fader-meter-peak-${faderId}"></div>
                        <div class="fader-meter-tick" style="bottom:100%"></div>
                        <div class="fader-meter-tick" style="bottom:83.3%"></div>
                        <div class="fader-meter-tick" style="bottom:66.7%"></div>
                        <div class="fader-meter-tick" style="bottom:50%"></div>
                      </div>
                    </div>
                    <div class="fader-container-wrapper">
                      <div class="fader-container${isMapped ? ' mapped' : ''}${containerMissingClass}" data-channel="${channelNum}" data-type="${channelType}" data-fader-id="${faderId}" title="${isMapped ? 'Volume: ' + midiInfo : ''}"${containerMappedStyle ? ` style="${containerMappedStyle}"` : ''}>
                        <div class="fader-fill" id="fader-fill-${faderId}" style="height: 0%"></div>
                        <div class="fader-midi-indicator" id="fader-midi-${faderId}" style="bottom: 0%; display: none;"></div>
                      </div>
                    </div>
                  </div>
                  <div class="fader-icon" style="${channelIcon ? '' : 'visibility: hidden;'}">${channelIcon || 'üéµ'}</div>
                  <div class="fader-channel-number"><span class="fader-indicator-dot" id="fader-dot-${faderId}"></span>${channelNumber}</div>
                  <div class="fader-label" style="${labelStyle}">${channelLabel}</div>
                  ${isMapped ? `<div class="fader-mapping-info ${midiLabelClass}" title="Volume: ${midiInfo}" style="${midiLabelStyle}">${midiInfo}</div>` : '<div class="fader-mapping-info" style="visibility:hidden;"></div>'}
                </div>
              `;
            }
        };

        // Render regular faders
        if (sortedRegularMappings.length === 0 && sortedMainMappings.length === 0) {
          container.innerHTML = '<div class="empty-state">No volume mappings yet. Add some mappings to see faders here.</div>';
          mainContainer.innerHTML = '';
        } else {
          container.innerHTML = sortedRegularMappings.map(renderFader).join('');
          mainContainer.innerHTML = sortedMainMappings.map(renderFader).join('');

          // Add mouse interaction to faders
          setupFaderInteraction();

          // Load initial fader positions, mute states, solo states, and main assign states from mixer
          const allMappings = [...sortedRegularMappings, ...sortedMainMappings];
          loadInitialFaderPositions(allMappings);
          loadInitialMuteStates(allMappings);
          loadInitialSoloStates(allMappings);
          loadInitialMainAssignStates(allMappings);

          // Update mute/solo button tooltips and mapped indicators
          updateMuteSoloMappingIndicators(allMappings);
        }

        // Load mute groups (after mappings are loaded)
        loadMuteGroups();

        // Cache meter DOM element references for efficient per-frame updates
        buildMeterElCache();

        updateStatusInit('Ready');
      } catch (error) {
        console.error('[Renderer] Error in loadFaders:', error);
        const errorMsg = `Error: ${error.message || 'Failed to load faders'}`;
        updateStatusInit(errorMsg);
        addStatusLog(errorMsg, 'error');
      } finally {
        isLoadingFaders = false;
      }
    }

    // Load initial fader positions from the mixer
    async function loadInitialFaderPositions(volumeMappings) {
      for (const mapping of volumeMappings) {
        try {
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          const channelType = mapping.mixer.channel.type || 'LINE';
          const level = await ipcRenderer.invoke('get-mixer-level', channelType, channelNum);
          if (level !== null) {
            updateFaderByValue(channelType, channelNum, level);
          }

          // For stereo channels, set the right channel to match the left channel initially
          const isLinked = await ipcRenderer.invoke('get-channel-link', channelType, channelNum);
          if (isLinked) {
            if (channelNum >= 11 && channelNum <= 14) {
            }
            // Force update the right channel fader to match left channel
            if (level !== null) {
              const faderIdR = `${channelType}-${channelNum + 1}`;
              const faderFillR = document.getElementById(`fader-fill-${faderIdR}`);

              if (faderFillR) {
                const roundedPercentage = Math.round(level);
                faderFillR.style.transition = 'none'; // No transition for initial load
                faderFillR.style.height = `${roundedPercentage}%`;

                if (channelNum >= 11 && channelNum <= 14) {
                }
              } else {
                if (channelNum >= 11 && channelNum <= 14) {
                }
              }
            }
          }
        } catch (error) {
          console.error('[Renderer] Error loading initial fader position:', error);
        }
      }
    }

    // Load initial mute states from the mixer
    async function loadInitialMuteStates(volumeMappings) {
      for (const mapping of volumeMappings) {
        try {
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          const channelType = mapping.mixer.channel.type || 'LINE';
          const muted = await ipcRenderer.invoke('get-channel-mute', channelType, channelNum);
          if (muted !== null) {
            updateMuteButton(channelType, channelNum, muted);
          }
        } catch (error) {
          // Silent error handling
        }
      }
    }

    // Load initial solo states from the mixer
    async function loadInitialSoloStates(volumeMappings) {
      for (const mapping of volumeMappings) {
        try {
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          const channelType = mapping.mixer.channel.type || 'LINE';
          const soloed = await ipcRenderer.invoke('get-channel-solo', channelType, channelNum);
          if (soloed !== null) {
            updateSoloButton(channelType, channelNum, soloed);
          }
        } catch (error) {
          // Silent error handling
        }
      }
    }

    // Update mute and solo button tooltips and mapped classes based on MIDI mappings
    function updateMuteSoloMappingIndicators(volumeMappings) {
      for (const mapping of volumeMappings) {
        const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
        const channelType = mapping.mixer.channel.type || 'LINE';
        const faderId = `${channelType}-${channelNum}`;

        // Check for mute mapping
        const muteMapping = currentMappings.find(m =>
          m.mixer.action === 'mute' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        // Check for solo mapping
        const soloMapping = currentMappings.find(m =>
          m.mixer.action === 'solo' &&
          (m.mixer.channel.type || 'LINE') === channelType &&
          (m.mixer.channel.channel || m.mixer.channel) == channelNum
        );

        // Update mute button
        const muteBtn = document.getElementById(`mute-btn-${faderId}`);
        if (muteBtn) {
          if (muteMapping) {
            muteBtn.classList.add('mapped');
            const midiInfo = muteMapping.midi.type === 'cc'
              ? `CC${muteMapping.midi.controller} Ch${muteMapping.midi.channel}`
              : `Note ${muteMapping.midi.note} Ch${muteMapping.midi.channel}`;
            muteBtn.title = `Mute: ${midiInfo}`;
            const muteDevColor = muteMapping.midi?.device ? (midiDeviceColors[muteMapping.midi.device] || '') : '';
            muteBtn.style.borderColor = muteDevColor || '';
            muteBtn.style.boxShadow = muteDevColor ? `0 0 4px ${muteDevColor}66` : '';
          } else {
            muteBtn.classList.remove('mapped');
            muteBtn.title = '';
            muteBtn.style.borderColor = '';
            muteBtn.style.boxShadow = '';
          }
        }

        // Update solo button
        const soloBtn = document.getElementById(`solo-btn-${faderId}`);
        if (soloBtn) {
          if (soloMapping) {
            soloBtn.classList.add('mapped');
            const midiInfo = soloMapping.midi.type === 'cc'
              ? `CC${soloMapping.midi.controller} Ch${soloMapping.midi.channel}`
              : `Note ${soloMapping.midi.note} Ch${soloMapping.midi.channel}`;
            soloBtn.title = `Solo: ${midiInfo}`;
            const soloDevColor = soloMapping.midi?.device ? (midiDeviceColors[soloMapping.midi.device] || '') : '';
            soloBtn.style.borderColor = soloDevColor || '';
            soloBtn.style.boxShadow = soloDevColor ? `0 0 4px ${soloDevColor}66` : '';
          } else {
            soloBtn.classList.remove('mapped');
            soloBtn.title = '';
            soloBtn.style.borderColor = '';
            soloBtn.style.boxShadow = '';
          }
        }
      }
    }

    // Load initial main assign states from the mixer
    async function loadInitialMainAssignStates(volumeMappings) {
      for (const mapping of volumeMappings) {
        try {
          const channelNum = mapping.mixer.channel.channel || mapping.mixer.channel;
          const channelType = mapping.mixer.channel.type || 'LINE';
          const mainAssigned = await ipcRenderer.invoke('get-channel-main-assign', channelType, channelNum);
          if (mainAssigned !== null) {
            updateMainAssignIndicator(channelType, channelNum, mainAssigned);
          }
        } catch (error) {
          console.error(`[Renderer] Error loading main assign for ${channelType}-${channelNum}:`, error);
        }
      }
    }

    // Toggle main assign for a channel
    async function toggleMainAssign(type, channel) {
      try {
        // For now, just log - we'll need to add the IPC handler
        const currentState = await ipcRenderer.invoke('get-channel-main-assign', type, channel);
        // TODO: Add toggle-main-assign IPC handler
      } catch (error) {
        console.error(`[Renderer] Error toggling main assign:`, error);
      }
    }

    // Update main assign indicator visibility
    function updateMainAssignIndicator(channelType, channelNum, isAssigned) {
      const faderId = `${channelType}-${channelNum}`;
      const indicator = document.getElementById(`main-indicator-${faderId}`);
      if (indicator) {
        if (isAssigned) {
          indicator.classList.remove('unassigned');
          indicator.classList.add('assigned');
        } else {
          indicator.classList.remove('assigned');
          indicator.classList.add('unassigned');
        }
      }
    }

    // Update input source indicator
    function updateInputSourceIndicator(channelType, channelNum, inputSrc) {
      const faderId = `${channelType}-${channelNum}`;
      const indicator = document.getElementById(`input-indicator-${faderId}`);
      if (indicator) {
        // Remove all source classes
        indicator.classList.remove('source-analog', 'source-network', 'source-usb', 'source-sdcard');

        // Inline SVG icons matching getInputSourceLabel()
        const icons = {
          0: { cls: 'source-analog',  tip: 'Input: Analog (XLR)', svg: `<svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" aria-label="Analog (XLR)"><circle cx="8" cy="8" r="6.5" stroke-width="1.5" stroke-dasharray="28.63 4 8.21"/><rect x="5.5" y="0.2" width="5" height="2.2" rx="0.4" fill="currentColor" stroke="none"/><circle cx="11.6" cy="8" r="1.0" fill="currentColor" stroke="none"/><circle cx="8" cy="11.6" r="1.0" fill="currentColor" stroke="none"/><circle cx="4.4" cy="8" r="1.0" fill="currentColor" stroke="none"/><circle cx="8" cy="8" r="3.6" fill="currentColor" stroke="none"/><circle cx="8" cy="8" r="1.0" fill="rgba(0,0,0,0.6)" stroke="none"/></svg>` },
          1: { cls: 'source-network', tip: 'Input: Network', svg: `<svg viewBox="0 0 16 16" width="16" height="16" fill="currentColor" aria-label="Network"><rect x="5" y="1" width="6" height="3.5" rx="0.8"/><rect x="1" y="11.5" width="4" height="3.5" rx="0.8"/><rect x="6" y="11.5" width="4" height="3.5" rx="0.8"/><rect x="11" y="11.5" width="4" height="3.5" rx="0.8"/><rect x="7.3" y="4.5" width="1.4" height="3" rx="0.3"/><rect x="1.5" y="8.8" width="13" height="1.4" rx="0.3"/><rect x="2.5" y="8.8" width="1.4" height="2.7" rx="0.3"/><rect x="7.3" y="8.8" width="1.4" height="2.7" rx="0.3"/><rect x="12.1" y="8.8" width="1.4" height="2.7" rx="0.3"/></svg>` },
          2: { cls: 'source-usb',     tip: 'Input: USB', svg: `<svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.4" aria-label="USB"><line x1="8" y1="2" x2="8" y2="10.5"/><line x1="5" y1="5.5" x2="11" y2="5.5"/><line x1="5" y1="3.5" x2="5" y2="5.5"/><rect x="3.5" y="1.8" width="3" height="2" rx="0.5" fill="currentColor" stroke="none"/><circle cx="5" cy="8.2" r="1.5" stroke="currentColor"/><rect x="9.5" y="5.5" width="3" height="2" rx="0.5" fill="currentColor" stroke="none"/><line x1="8" y1="10.5" x2="8" y2="12.5"/><rect x="5.5" y="12.5" width="5" height="3" rx="0.8" fill="currentColor" stroke="none"/></svg>` },
          3: { cls: 'source-sdcard',  tip: 'Input: SD Card', svg: `<svg viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.4" aria-label="SD Card"><path d="M3 1.5h7l3.5 3.5V15H3V1.5z"/><line x1="5" y1="9" x2="5" y2="14" stroke-width="1"/><line x1="7.5" y1="9" x2="7.5" y2="14" stroke-width="1"/><line x1="10" y1="9" x2="10" y2="14" stroke-width="1"/></svg>` },
        };
        const info = icons[inputSrc] || icons[0];

        indicator.innerHTML = info.svg;
        indicator.classList.add(info.cls);
        indicator.title = info.tip;
      }
    }

    // Update channel icon
    function updateChannelIcon(channelType, channelNum, iconId) {
      const faderId = `${channelType}-${channelNum}`;
      const iconElement = document.querySelector(`[data-fader-id="${faderId}"] .fader-icon`);
      if (iconElement) {
        // Map icon ID to emoji (same mapping as in loadFaders)
        const iconMap = {
          0: 'üé§', 1: 'üé∏', 2: 'üéπ', 3: 'ü•Å', 4: 'üé∫', 5: 'üéª',
          6: 'üéµ', 7: 'üé∂', 8: 'üîä', 9: 'üéß', 10: 'üìª', 11: 'üéôÔ∏è'
        };
        const icon = iconMap[iconId] || 'üéµ';
        iconElement.textContent = icon;
        iconElement.style.visibility = 'visible';
      }
    }

    // Update channel name
    function updateChannelName(channelType, channelNum, name) {
      const faderId = `${channelType}-${channelNum}`;
      const labelElement = document.querySelector(`[data-fader-id="${faderId}"] .fader-label`);
      if (labelElement) {
        labelElement.textContent = name || '';
      }
    }

    // Toggle mute for a channel
    async function toggleMute(type, channel) {
      try {
        const result = await ipcRenderer.invoke('toggle-mute', type, channel);
        if (result.success) {
          // Get the new state and update the button
          const muted = await ipcRenderer.invoke('get-channel-mute', type, channel);
          if (muted !== null) {
            updateMuteButton(type, channel, muted);
          }
        }
      } catch (error) {
        // Silent error handling
      }
    }

    // Update mute button visual state
    function updateMuteButton(channelType, channelNum, muted) {
      const faderId = `${channelType}-${channelNum}`;
      const muteBtn = document.getElementById(`mute-btn-${faderId}`);
      if (muteBtn) {
        if (muted) {
          muteBtn.classList.add('active');
        } else {
          muteBtn.classList.remove('active');
        }
      }
    }

    // Toggle solo for a channel
    async function toggleSolo(type, channel) {
      try {
        const result = await ipcRenderer.invoke('toggle-solo', type, channel);
        if (result.success) {
          // Get the new state and update the button
          const soloed = await ipcRenderer.invoke('get-channel-solo', type, channel);
          if (soloed !== null) {
            updateSoloButton(type, channel, soloed);
          }
        }
      } catch (error) {
        // Silent error handling
      }
    }

    // Update solo button visual state
    function updateSoloButton(channelType, channelNum, soloed) {
      const faderId = `${channelType}-${channelNum}`;
      const soloBtn = document.getElementById(`solo-btn-${faderId}`);
      if (soloBtn) {
        if (soloed) {
          soloBtn.classList.add('active');
        } else {
          soloBtn.classList.remove('active');
        }
      }
    }

    // Setup fader mouse interaction
    function setupFaderInteraction() {
      const faderContainers = document.querySelectorAll('.fader-container');

      faderContainers.forEach(container => {
        let isDragging = false;
        let channel = parseInt(container.getAttribute('data-channel'));
        const channelType = container.getAttribute('data-type') || 'LINE';
        const faderId = container.getAttribute('data-fader-id');

        const updateFaderFromMouse = async (e) => {
          const rect = container.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const height = rect.height;

          // Calculate percentage (inverted because 0 is at top, 100 at bottom)
          let percentage = Math.max(0, Math.min(100, ((height - y) / height) * 100));

          // Check if this channel is the RIGHT side of a stereo pair
          // If so, we need to use the LEFT channel as the primary channel
          let primaryChannel = channel;
          let isRightChannel = false;

          if (channel % 2 === 0) {
            // Even channel - might be the right side of a stereo pair
            const leftChannelLink = await ipcRenderer.invoke('get-channel-link', channelType, channel - 1);
            if (leftChannelLink) {
              // This is the right channel of a stereo pair, use the left channel as primary
              primaryChannel = channel - 1;
              isRightChannel = true;
            }
          }

          // Update both faders in the stereo pair
          const faderIdL = `${channelType}-${primaryChannel}`;
          const faderIdR = `${channelType}-${primaryChannel + 1}`;

          // Update left fader UI
          const fillL = document.getElementById(`fader-fill-${faderIdL}`);
          const valueDisplayL = document.getElementById(`fader-value-${faderIdL}`);
          if (fillL && valueDisplayL) {
            fillL.style.height = `${percentage}%`;
            valueDisplayL.textContent = `${Math.round(percentage)}%`;
          }

          // Send to mixer for left channel
          ipcRenderer.invoke('set-mixer-volume', channelType, primaryChannel, percentage).catch(err => {
            // Silent error handling
          });

          // Check if this is a stereo pair and update the right channel too
          const isLinked = await ipcRenderer.invoke('get-channel-link', channelType, primaryChannel);
          if (isLinked) {
            const fillR = document.getElementById(`fader-fill-${faderIdR}`);
            if (fillR) {
              fillR.style.height = `${percentage}%`;
            }
            // Send to mixer for right channel
            ipcRenderer.invoke('set-mixer-volume', channelType, primaryChannel + 1, percentage).catch(err => {
              // Silent error handling
            });
          }

          // Indicate UI change
          indicateFaderChange(channelType, primaryChannel, 'ui');
        };

        container.addEventListener('mousedown', (e) => {
          isDragging = true;
          container.classList.add('dragging');
          updateFaderFromMouse(e);
          e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
          if (isDragging) {
            updateFaderFromMouse(e);
          }
        });

        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            container.classList.remove('dragging');
          }
        });
      });

      // Add click handler for selection and editing
      const faderChannels = document.querySelectorAll('.fader-channel');
      faderChannels.forEach(channel => {
        // Single click to select (only on background, not on interactive elements)
        channel.addEventListener('click', (e) => {
          // Don't select if clicking on interactive elements
          if (e.target.closest('.fader-container') ||
              e.target.closest('.mute-btn') ||
              e.target.closest('.solo-btn') ||
              e.target.closest('.fader-label') ||
              e.target.closest('.fader-icon') ||
              e.target.closest('.fader-value') ||
              e.target.closest('.fader-mapping-info')) {
            return;
          }
          channel.classList.toggle('selected');
          e.stopPropagation();
        });

        // Double click to edit
        channel.addEventListener('dblclick', (e) => {
          const faderId = channel.getAttribute('data-fader-id');
          editFaderMapping(faderId);
          e.stopPropagation();
        });

        // Right click for context menu on channel background
        channel.addEventListener('contextmenu', (e) => {
          // Check if clicking on specific elements
          if (e.target.closest('.fader-container')) {
            // Right-click on fader slider - show fader volume menu
            e.preventDefault();
            const faderId = channel.getAttribute('data-fader-id');
            showFaderVolumeContextMenu(faderId, e.clientX, e.clientY);
            return;
          }

          if (e.target.closest('.mute-btn')) {
            // Right-click on mute button - show mute menu
            e.preventDefault();
            const faderId = channel.getAttribute('data-fader-id');
            showMuteContextMenu(faderId, e.clientX, e.clientY);
            return;
          }

          if (e.target.closest('.solo-btn')) {
            // Right-click on solo button - show solo menu
            e.preventDefault();
            const faderId = channel.getAttribute('data-fader-id');
            showSoloContextMenu(faderId, e.clientX, e.clientY);
            return;
          }

          // Right-click on channel background - show channel menu
          e.preventDefault();
          const faderId = channel.getAttribute('data-fader-id');
          showChannelContextMenu(faderId, e.clientX, e.clientY);
        });
      });
    }

    // Update status
    async function updateStatus() {
      try {
        const mixerStatus = await ipcRenderer.invoke('get-mixer-status');
        const midiStatus = await ipcRenderer.invoke('get-midi-status');
        const currentPreset = await ipcRenderer.invoke('get-current-preset');

        // Update mixer status (sidebar) - only if elements exist
        const mixerIndicator = document.getElementById('mixer-status');
        const mixerStatusText = document.getElementById('mixer-status-text');
        const mixerIp = document.getElementById('mixer-ip');

        // Track previous connection state to detect changes
        const wasConnected = window.previousMixerConnected || false;
        const isNowConnected = mixerStatus.connected;

        if (mixerIndicator && mixerStatusText && mixerIp) {
          if (mixerStatus.connected) {
            mixerIndicator.classList.add('connected');
            mixerStatusText.textContent = 'Connected';
            mixerIp.textContent = mixerStatus.ip || '‚Äî';
          } else {
            mixerIndicator.classList.remove('connected');
            mixerStatusText.textContent = 'Disconnected';
            mixerIp.textContent = '‚Äî';
          }
        }

        // Update mixer status (header and status bar)
        const mixerStatusDot = document.getElementById('mixer-status-dot');
        const mixerStatusShort = document.getElementById('mixer-status-short');
        const statusMixer = document.getElementById('status-mixer');

        if (mixerStatusDot) {
          if (mixerStatus.connected) {
            mixerStatusDot.classList.add('connected');
            mixerStatusDot.classList.remove('configured');
            // Show {deviceName} if defined, else {model}
            const displayName = mixerStatus.deviceName || mixerStatus.model || mixerStatus.name || mixerStatus.ip || 'Mixer';
            if (mixerStatusShort) mixerStatusShort.textContent = displayName;

            // Update tooltip with all fields including serial
            const mixerConnectionEl = document.getElementById('mixer-connection-status');
            if (mixerConnectionEl) {
              mixerConnectionEl.classList.remove('device-warning');
              const tooltipParts = [`IP: ${mixerStatus.ip || 'Unknown'}`];
              if (mixerStatus.model) tooltipParts.push(`Model: ${mixerStatus.model}`);
              if (mixerStatus.deviceName) tooltipParts.push(`Device Name: ${mixerStatus.deviceName}`);
              if (mixerStatus.serial) tooltipParts.push(`Serial: ${mixerStatus.serial}`);
              tooltipParts.push('Click to open connection panel');
              mixerConnectionEl.title = tooltipParts.join('\n');
            }

            if (statusMixer) {
              statusMixer.textContent = displayName;
              statusMixer.classList.add('connected');
              statusMixer.classList.remove('disconnected');
            }
          } else if (mixerStatus.preferredIp) {
            // Configured but not connected ‚Äî red dot
            mixerStatusDot.classList.remove('connected');
            mixerStatusDot.classList.add('configured');
            if (mixerStatusShort) mixerStatusShort.textContent = 'Mixer';

            const mixerConnectionEl = document.getElementById('mixer-connection-status');
            if (mixerConnectionEl) {
              mixerConnectionEl.classList.add('device-warning');
              mixerConnectionEl.title = `Mixer: Not connected\nPreferred: ${mixerStatus.preferredIp}\nClick to open connection panel`;
            }

            if (statusMixer) {
              statusMixer.textContent = 'Not connected';
              statusMixer.classList.remove('connected');
              statusMixer.classList.add('disconnected');
            }
          } else {
            mixerStatusDot.classList.remove('connected');
            mixerStatusDot.classList.remove('configured');
            if (mixerStatusShort) mixerStatusShort.textContent = 'Mixer';

            // Update tooltip
            const mixerConnectionEl = document.getElementById('mixer-connection-status');
            if (mixerConnectionEl) {
              mixerConnectionEl.classList.remove('device-warning');
              mixerConnectionEl.title = 'Mixer: Disconnected\nClick to open connection panel';
            }

            if (statusMixer) {
              statusMixer.textContent = 'Disconnected';
              statusMixer.classList.remove('connected');
              statusMixer.classList.add('disconnected');
            }
          }
        }

        // If mixer just connected, reload faders and mappings to get channel names
        // Note: mixer-state-ready event will also trigger loadFaders, but our duplicate
        // prevention flag will ensure it only runs once
        if (!wasConnected && isNowConnected) {
          // Don't call loadFaders here - let mixer-state-ready handle it
          loadMappings();
        }

        // Update previous state
        window.previousMixerConnected = isNowConnected;

        // Update MIDI status (sidebar) - only if elements exist
        const midiIndicator = document.getElementById('midi-status');
        const midiStatusText = document.getElementById('midi-status-text');
        const midiDevice = document.getElementById('midi-device');

        if (midiIndicator && midiStatusText && midiDevice) {
          if (midiStatus.connected) {
            midiIndicator.classList.add('connected');
            midiStatusText.textContent = 'Connected';
            midiDevice.textContent = midiStatus.device || '‚Äî';
          } else {
            midiIndicator.classList.remove('connected');
            midiStatusText.textContent = 'Disconnected';
            midiDevice.textContent = '‚Äî';
          }
        }

        // Update MIDI status (header and status bar)
        const midiStatusDot = document.getElementById('midi-status-dot');
        const midiStatusShort = document.getElementById('midi-status-short');
        const statusMidi = document.getElementById('status-midi');

        if (midiStatusDot) {
          const connectedDevices = midiStatus.devices || (midiStatus.device ? [midiStatus.device] : []);
          const preferredDevices = midiStatus.preferredDevices || [];
          // Keep connectedMidiDevices Set in sync so border logic is always current
          const newSet = new Set(connectedDevices);
          const changed = newSet.size !== connectedMidiDevices.size ||
            [...newSet].some(d => !connectedMidiDevices.has(d));
          if (changed) {
            connectedMidiDevices = newSet;
            updateMissingDeviceBorders();
          }

          // Striped warning on the MIDI button if any mapped channel's device is missing
          const midiConnectionEl = document.getElementById('midi-connection-status');
          if (midiConnectionEl) {
            const anyMissing = currentMappings.some(m =>
              m.midi?.device && !connectedMidiDevices.has(m.midi.device)
            );
            midiConnectionEl.classList.toggle('device-warning', anyMissing);
          }
          if (midiStatus.connected && connectedDevices.length > 0) {
            midiStatusDot.classList.add('connected');
            midiStatusDot.classList.remove('configured');

            let shortLabel;
            if (connectedDevices.length === 1) {
              shortLabel = shortenMidiDeviceName(connectedDevices[0]);
            } else {
              shortLabel = `${connectedDevices.length} MIDI`;
            }
            if (midiStatusShort) midiStatusShort.textContent = shortLabel || 'MIDI';

            // Update tooltip listing all connected devices
            const midiConnectionEl = document.getElementById('midi-connection-status');
            if (midiConnectionEl) {
              const deviceList = connectedDevices.map(d => `  ‚Ä¢ ${shortenMidiDeviceName(d)}`).join('\n');
              midiConnectionEl.title = `MIDI Devices:\n${deviceList}\nClick to manage connections`;
            }

            if (statusMidi) {
              statusMidi.textContent = shortLabel || 'Connected';
              statusMidi.classList.add('connected');
              statusMidi.classList.remove('disconnected');
            }
          } else if (preferredDevices.length > 0) {
            // Configured but not connected ‚Äî red dot
            midiStatusDot.classList.remove('connected');
            midiStatusDot.classList.add('configured');
            if (midiStatusShort) midiStatusShort.textContent = 'MIDI';

            const midiConnectionEl = document.getElementById('midi-connection-status');
            if (midiConnectionEl) {
              const prefList = preferredDevices.map(d => `  ‚Ä¢ ${shortenMidiDeviceName(d)}`).join('\n');
              midiConnectionEl.title = `MIDI: Not connected\nConfigured devices:\n${prefList}\nClick to manage connections`;
            }

            if (statusMidi) {
              statusMidi.textContent = 'Not connected';
              statusMidi.classList.remove('connected');
              statusMidi.classList.add('disconnected');
            }
          } else {
            midiStatusDot.classList.remove('connected');
            midiStatusDot.classList.remove('configured');
            if (midiStatusShort) midiStatusShort.textContent = 'MIDI';

            const midiConnectionEl = document.getElementById('midi-connection-status');
            if (midiConnectionEl) {
              midiConnectionEl.title = 'MIDI: Disconnected\nClick to open connection panel';
            }

            if (statusMidi) {
              statusMidi.textContent = 'Disconnected';
              statusMidi.classList.remove('connected');
              statusMidi.classList.add('disconnected');
            }
          }
        }

        // Update preset in sidebar and status bar
        document.getElementById('current-preset').textContent = currentPreset || 'None';
        updateStatusProfile(currentPreset);
      } catch (error) {
        // Silent error handling
      }
    }

    // Load initial state
    async function loadInitialState() {
      // Set real version immediately and kick off update check ‚Äî both must run
      // regardless of which connection path (auto-connect / discovery / manual) is taken.
      ipcRenderer.invoke('get-app-version').then(v => {
        const el = document.getElementById('status-version');
        if (el && v) el.textContent = String(v);
      }).catch(() => {});

      checkForUpdates().catch(err => {
        console.error('[Renderer] Update check failed:', err);
      });

      try {
        // Check if there's a preferred mixer (use get-mixer-status to get all stored metadata)
        const prefStatus = await ipcRenderer.invoke('get-mixer-status');
        const preferredIp = prefStatus.preferredIp;

        if (preferredIp) {
          const prefModel = prefStatus.preferredModel || '';
          const prefDeviceName = prefStatus.preferredDeviceName || '';
          const prefSerial = prefStatus.preferredSerial || '';
          const displayLabel = prefDeviceName || prefModel || preferredIp;

          // If main process already connected on startup, skip redundant connect-mixer call.
          // A second connect would disconnect and reconnect, causing mixer-state-ready to fire
          // at the wrong time (and get skipped as a duplicate by the 15-second guard).
          if (prefStatus.connected) {
            await updateStatusInitWithDelay(`Connected to ${displayLabel}`);
            updateStatus();
            // mixer-state-ready will arrive soon from the startup connection; if it already
            // fired (and was handled), load faders directly.
            if (mixerStateReadyHandled) {
              await loadMappings();
              await loadFaders();
            }
            // else: wait for the incoming mixer-state-ready event to trigger loadFaders
            return;
          }

          await updateStatusInitWithDelay(`Connecting to ${displayLabel}...`);

          const result = await ipcRenderer.invoke('connect-mixer', preferredIp, prefModel || undefined, prefDeviceName || undefined, prefSerial || undefined);
          if (result.success) {
            // Connection successful ‚Äî mixer-state-ready event will trigger loadFaders
            await updateStatusInitWithDelay('Loading preset...');
            updateStatus();
            return;
          } else {
            addStatusLog(`Failed to connect to preferred mixer ${preferredIp}: ${result.error}`, 'warning');
          }
        }

        // No preferred mixer or connection failed, do discovery
        await updateStatusInitWithDelay('Discovering mixers...');

        const mixers = await ipcRenderer.invoke('get-discovered-mixers');
        const listEl = document.getElementById('mixer-list');

        if (mixers.length > 0) {
          listEl.innerHTML = '';
          for (const mixer of mixers) {
            const ip = mixer.ip || '';
            const modelName = mixer.model || mixer.name || '';
            const deviceName = mixer.deviceName || '';
            const serial = mixer.serial || '';

            const div = document.createElement('div');
            div.className = 'mixer-item';
            div.title = `IP: ${ip}\nModel: ${modelName}${deviceName ? '\nDevice Name: ' + deviceName : ''}\nSerial: ${serial}`;

            const infoDiv = document.createElement('div');
            infoDiv.className = 'mixer-info';

            const nameDiv = document.createElement('div');
            nameDiv.className = 'mixer-name';
            nameDiv.textContent = ip + ' ' + modelName + (deviceName ? ' ' + deviceName : '');

            const detailDiv = document.createElement('div');
            detailDiv.className = 'mixer-details';
            detailDiv.textContent = 'Serial: ' + serial;

            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.textContent = 'Connect';
            btn.addEventListener('click', () => connectToMixer(ip, modelName, deviceName));

            infoDiv.appendChild(nameDiv);
            infoDiv.appendChild(detailDiv);
            div.appendChild(infoDiv);
            div.appendChild(btn);
            listEl.appendChild(div);
          }
        }

        await updateStatusInitWithDelay('Loading preset...');
      } catch (error) {
        console.error('[Renderer] Error in loadInitialState:', error);
        const errorMsg = `Initialization failed: ${error.message || error}`;
        updateStatusInit(errorMsg);
        addStatusLog(errorMsg, 'error');
      }

      updateStatus();

      // Note: Don't call loadMappings() or loadFaders() here
      // If we connected to a preferred mixer, we already returned early (line 4555)
      // If we're here, it means no preferred mixer or discovery mode
      // The mixer-state-ready event will handle loading when a mixer connects

      updateStatusInit('Ready');
    }

    // Update status every 2 seconds
    setInterval(updateStatus, 2000);

    // Hide context menus on any mouse press outside them.
    // mousedown fires for all buttons including right-click; 'click' is left-only.
    document.addEventListener('mousedown', (e) => {
      const menus = [
        document.getElementById('fader-context-menu'),
        document.getElementById('mute-context-menu'),
        document.getElementById('solo-context-menu'),
        document.getElementById('channel-context-menu'),
        document.getElementById('mutegroup-context-menu'),
      ];
      if (menus.every(m => !m || !m.contains(e.target))) {
        hideAllContextMenus();
      }
    });

    // Cmd/Ctrl+S ‚Äî quick save current preset
    document.addEventListener('keydown', async (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 's') {
        e.preventDefault();
        const currentPath = await ipcRenderer.invoke('get-current-preset-path');
        if (currentPath) {
          const result = await ipcRenderer.invoke('save-preset-to-path', currentPath);
          if (result.success) {
            addStatusLog('Preset saved', 'success');
          }
        } else {
          // No current path ‚Äî open save dialog
          const result = await ipcRenderer.invoke('save-preset-dialog');
          if (result && result.success) {
            addStatusLog('Preset saved', 'success');
          }
        }
      }
    });

    // Load initial state when page loads
    loadInitialState();

    // Version click handler must live outside loadInitialState() to survive the preferred-mixer early return
    (function attachVersionClickHandler() {
      const versionEl = document.getElementById('status-version');
      if (versionEl) {
        versionEl.style.cursor = 'pointer';
        versionEl.title = 'Click to view changelog';
        versionEl.addEventListener('click', showChangelogModal);
      }
    })();
  </script>
</body>
</html>

